<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MinIO</title>
    <url>/blog/2023/10/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/MinIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>本项目采用MinIO构建分布式文件系统，MinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等。<br>它一大特点就是轻量，使用简单，功能强大，支持各种平台，单个文件最大5TB，兼容 Amazon S3接口，提供了 Java、Python、GO等多版本SDK支持。</p>
<p>官网：<a href="https://min.io/">https://min.io</a></p>
<p>中文：<a href="https://www.minio.org.cn/%EF%BC%8Chttp://docs.minio.org.cn/docs/">https://www.minio.org.cn/，http://docs.minio.org.cn/docs/</a></p>
<p>MinIO集群采用去中心化共享架构，每个结点是对等关系，通过Nginx可对MinIO进行负载均衡访问。</p>
<p>去中心化有什么好处？</p>
<p>在大数据领域，通常的设计理念都是无中心和分布式。Minio分布式模式可以帮助你搭建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真实物理位置。</p>
<p>它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式Minio避免了单点故障。如下图：</p>
<p><img src="/blog/images/img/MinIO1.png" alt="MinIO1"></p>
<p>Minio使用纠删码技术来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数据分块冗余的分散存储在各各节点的磁盘上，所有的可用磁盘组成一个集合，上图由8块硬盘组成一个集合，当上传一个文件时会通过纠删码算法计算对文件进行分块存储，除了将文件本身分成4个数据块，还会生成4个校验块，数据块和校验块会分散的存储在这8块硬盘上。</p>
<p>使用纠删码的好处是即便丢失一半数量（N&#x2F;2）的硬盘，仍然可以恢复数据。 比如上边集合中有4个以内的硬盘损害仍可保证数据恢复，不影响上传和下载，如果多于一半的硬盘坏了则无法恢复。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>MinIO</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/blog/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/maven/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><ol>
<li>排除依赖（引用方：exclusions）</li>
<li>可选依赖 (被引用方：optional)</li>
</ol>
<h1 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h1><p><img src="/blog/images/img/maven-scope.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门</title>
    <url>/blog/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote>
<p>简介</p>
</blockquote>
<p>Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP&#x2F;POP3&#x2F;SMTP 服务。</p>
<p>Nginx 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。</p>
<p>Nginx 特点是占有内存少，并发能力强。</p>
<p>事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 Nginx ，我们的项目架构可能是这样：</p>
<p><img src="/blog/images/img/nginx01.png" alt="nginx01"></p>
<p>在这样的架构中 ， Nginx 所代表的角色叫做<strong>负载均衡服务器</strong>或者<strong>反向代理服务器</strong>，所有请求首先到达 Nginx 上，再由 Nginx 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 Tomcat 上去。</p>
<p>那么这里涉及到两个概念：</p>
<ul>
<li>负载均衡服务器</li>
</ul>
<p>就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 DNS 就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 F5 和 Nginx （目前 Nginx 已经被 F5 收购），早些年，也可以使用 Apache 来做负载均衡，但是效率不如 Nginx ，所以现在主流方案是 Nginx 。</p>
<ul>
<li>反向代理服务器：</li>
</ul>
<p>另一个概念是反向代理服务器，要说反向代理，得先说正向代理，看下面一张图：</p>
<p><img src="/blog/images/img/nginx02.png" alt="nginx02"></p>
<p>在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。</p>
<p>那么什么是反向代理呢？反向代理有点类似于大家打 10086 客服，看下面一张图：</p>
<p><img src="/blog/images/img/nginx03.png" alt="nginx03"></p>
<p>在这个过程中，10086 这个号码相当于是一个代理，真正提供服务的，是话务员，但是对于客户来说，他不关心到底是哪一个话务员提供的服务，他只需要记得 10086 这个号码就行了。</p>
<p>所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。</p>
<blockquote>
<p>Tips：代理服务器代理的是客户端就是正向代理，代理的是服务端就是反向代理</p>
</blockquote>
<blockquote>
<p>Nginx 的优势<br>在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点：</p>
</blockquote>
<ol>
<li><p>使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。</p>
</li>
<li><p>使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。</p>
</li>
<li><p>支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。</p>
</li>
</ol>
<blockquote>
<p>Nginx 安装</p>
</blockquote>
<p>由于基本上都是在 Linux 上使用 Nginx，因此松哥这里主要向大家展示 CentOS 7 安装 Nginx：</p>
<ol>
<li>首先下载 Nginx</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.17.0.tar.gz</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>然后解压下载的目录，进入解压目录中，在编译安装之前，需要安装两个依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install pcre-devel</span><br><span class="line"></span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure></li>
<li><p>然后开始编译安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>如果编译提示：.&#x2F;configure: error: C compiler cc is not found，安装C语言编译器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf automake make</span><br></pre></td></tr></table></figure>
</li>
<li><p>装好之后，默认安装位置在 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li>
<li><p>进入到该目录的 sbin 目录下，执行 nginx 即可启动 Nginx ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>更新2023年9月29日12点42分</p>
</blockquote>
<h1 id="CentOS开机自启nginx"><a href="#CentOS开机自启nginx" class="headerlink" title="CentOS开机自启nginx"></a>CentOS开机自启nginx</h1><ol>
<li>vi &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service</li>
</ol>
<p>编辑如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">#防止启动超时</span><br><span class="line">TimeoutSec=0 </span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">cription=nacos</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">TimeoutSec=0</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">#/usr/local/nginx为自己nginx的安装目录</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx   </span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>重新加载服务的配置文件 systemctl daemon-reload</p>
</li>
<li><p>设置开机启动systemctl enable nginx.service</p>
</li>
<li><p>启动nginx服务 systemctl start nginx</p>
</li>
<li><p>查看服务状态 systemctl status nginx</p>
</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/blog/2023/06/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/docker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Docker是一个开源的容器化平台，用于自动化部署、打包和运行应用程序。它允许开发人员将应用程序及其依赖打包成一个可移植的容器，然后在不同的环境中进行部署和运行，而不需要担心环境差异和依赖问题。</p>
<p>Docker使用轻量级的容器来实现应用程序和所需环境的隔离，每个容器都有自己的文件系统、网络和进程空间，可以独立运行，互不干扰。这种隔离性使得应用程序能够在任何操作系统上运行，不受操作系统和硬件的限制。</p>
<p>Docker的核心概念包括镜像（image）、容器（container）、仓库（repository）和服务（service）。镜像是一个只读的模板，用于创建容器；容器是镜像的运行实例，可以被启动、停止、重启和删除；仓库是用于存放镜像的地方，可以是本地或远程的；服务是多个容器的集合，一起进行部署和管理。</p>
<p>使用Docker，开发人员可以更快速地搭建开发环境、测试环境和生产环境，提高开发效率。同时，Docker还具有轻量级、可移植、可扩展和可重复部署等特性，使得应用程序更加稳定、可靠和易于管理。</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>以下是在CentOS上进行Docker基本操作的一些步骤：</p>
<ol>
<li><p>安装Docker：通过运行以下命令来安装Docker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install docker</span><br></pre></td></tr></table></figure></li>
<li><p>启动Docker服务：运行以下命令来启动Docker服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>检查Docker状态：运行以下命令来检查Docker服务的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure></li>
<li><p>获取镜像：使用以下命令从Docker Hub 获取CentOS镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker pull centos</span><br></pre></td></tr></table></figure></li>
<li><p>运行容器：使用以下命令在CentOS镜像上运行一个容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --name my-container centos /bin/bash</span><br></pre></td></tr></table></figure>
<p>这个命令会在一个新的容器中启动一个bash终端，并命名为my-container。</p>
</li>
<li><p>列出运行中的容器：使用以下命令列出当前正在运行的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure></li>
<li><p>停止容器：使用以下命令停止一个运行中的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker stop my-container</span><br></pre></td></tr></table></figure>
<p>其中，my-container是容器的名称。</p>
</li>
<li><p>删除容器：使用以下命令删除一个已停止的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker rm my-container</span><br></pre></td></tr></table></figure>
<p>同样，my-container是容器的名称。</p>
</li>
</ol>
<p>这些是在CentOS上进行Docker基本操作的一些步骤，你可以根据具体需求进行相应的操作和配置。注意，在使用Docker命令时，可能需要使用sudo来获取root权限。<br>9. 复制外部文件至容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp /etc/nginx/default.conf my_nginx:/etc/nginx/conf.d/default.conf </span><br></pre></td></tr></table></figure>
<h1 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h1><p>以下是一些Docker高级操作的示例：</p>
<ol>
<li>使用Dockerfile构建自定义镜像：Dockerfile是一个文本文件，包含构建Docker镜像的指令。您可以使用它定义自己的镜像构建过程。以下是一个简单的Dockerfile示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum update &amp;&amp; yum install -y httpd</span><br><span class="line">COPY index.html /var/www/html/</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;apachectl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure>
在Dockerfile所在目录下，运行以下命令来构建镜像：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker build -t my-apache-image .</span><br></pre></td></tr></table></figure></li>
<li>使用Docker Compose管理容器组：Docker Compose是一个通过定义YAML文件来管理和编排多个容器的工具。以下是一个简单的docker-compose.yml文件示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data:/var/www/html</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: my-secret-pw</span><br></pre></td></tr></table></figure>
在包含docker-compose.yml文件的目录下，运行以下命令来启动容器组：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure></li>
<li>使用Docker网络和链接容器：Docker提供了网络功能，使容器可以相互通信。可以使用以下命令创建一个自定义网络：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker network create my-network</span><br></pre></td></tr></table></figure>
然后可以使用以下命令来运行容器并将其链接到自定义网络：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name container1 --network my-network image1</span><br><span class="line">sudo docker run -d --name container2 --network my-network image2</span><br></pre></td></tr></table></figure>
容器container1和container2现在可以使用它们的容器名称进行通信。</li>
</ol>
<p>这些是一些Docker的高级操作示例，希望对你有所帮助。你可以根据具体需求进行深入研究和配置，以更好地使用Docker进行应用程序开发和部署。</p>
<h1 id="镜像基本操作"><a href="#镜像基本操作" class="headerlink" title="镜像基本操作"></a>镜像基本操作</h1><p>以下是Docker镜像的基本操作示例：</p>
<ol>
<li><p>拉取镜像：从Docker Hub或其他镜像仓库中拉取镜像。使用以下命令来拉取一个镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker pull image_name:tag</span><br></pre></td></tr></table></figure>
<p>其中，<code>image_name</code>是镜像名称，<code>tag</code>是镜像标签（可选）。</p>
</li>
<li><p>列出镜像：列出已经下载到本地的镜像。使用以下命令来列出镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像：删除本地的镜像。使用以下命令来删除镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker rmi image_name:tag</span><br></pre></td></tr></table></figure>
<p>其中，<code>image_name</code>是镜像名称，<code>tag</code>是镜像标签（可选）。</p>
</li>
<li><p>构建镜像：使用Dockerfile来构建自定义镜像。在包含Dockerfile的目录下，使用以下命令来构建镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker build -t image_name:tag .</span><br></pre></td></tr></table></figure>
<p>其中，<code>image_name</code>是镜像名称，<code>tag</code>是镜像标签（可选）。</p>
</li>
<li><p>运行容器：使用镜像来创建并运行容器。使用以下命令来运行容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name container_name image_name:tag</span><br></pre></td></tr></table></figure>
<p>其中，<code>container_name</code>是容器名称，<code>image_name</code>是镜像名称，<code>tag</code>是镜像标签（可选）。</p>
</li>
<li><p>导出和导入镜像：可以导出镜像为一个tar文件，然后在另一个Docker环境中导入。使用以下命令来导出镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker save -o image_name.tar image_name:tag</span><br></pre></td></tr></table></figure>
<p>使用以下命令来导入镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker load -i image_name.tar</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="容器开机自启"><a href="#容器开机自启" class="headerlink" title="容器开机自启"></a>容器开机自启</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker update --restart=always &lt;container_name&gt;</span><br></pre></td></tr></table></figure>

<p>这些是Docker镜像的基本操作示例。你可以根据具体需求在这些基础上进行更多的操作和配置。</p>
<h1 id="docker-安装nginx"><a href="#docker-安装nginx" class="headerlink" title="docker 安装nginx"></a>docker 安装nginx</h1><p>要在Docker中安装Nginx，您可以执行以下步骤：</p>
<ol>
<li><p>拉取Nginx镜像：使用以下命令从Docker Hub拉取Nginx镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker pull nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行Nginx容器：使用以下命令来运行一个Nginx容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name my-nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>在这个命令中，<code>my-nginx</code>是容器的名称，<code>80:80</code>将Docker主机的80端口映射到容器的80端口，让外部能够访问Nginx服务。</p>
</li>
<li><p>测试Nginx：打开一个Web浏览器，并访问<code>http://localhost</code>，你应该能够看到Nginx的默认欢迎页面。</p>
</li>
</ol>
<p>以上是一个简单的示例，使用Docker运行Nginx。您也可以使用自定义的配置文件或者修改容器的访问端口。根据您的需求来进行相应的配置和调整。</p>
<h1 id="docker-配置nginx"><a href="#docker-配置nginx" class="headerlink" title="docker 配置nginx"></a>docker 配置nginx</h1><p>要在Docker中进行Nginx的配置，您可以使用以下步骤：</p>
<ol>
<li><p>创建一个自定义的Nginx配置文件：首先，创建一个 <code>nginx.conf</code> 文件，定义您想要的Nginx配置。您可以在本地计算机上使用任何文本编辑器创建该文件，并确保它是有效的Nginx配置。</p>
</li>
<li><p>将自定义配置文件挂载到Nginx容器中：在运行Nginx容器时，使用 <code>-v</code> 参数将自定义配置文件挂载到容器中的对应路径。假设您的自定义配置文件位于 <code>/path/to/nginx.conf</code>，并且您希望将其挂载到容器中的 <code>/etc/nginx/nginx.conf</code>，您可以使用以下命令运行容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name my-nginx -p 80:80 -v /path/to/nginx.conf:/etc/nginx/nginx.conf nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动Nginx容器：在挂载自定义配置文件后，您需要重新启动Nginx容器使其使用新的配置。使用以下命令重新启动容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker restart my-nginx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>现在，您的Nginx容器将使用您自定义的配置文件进行工作。</p>
<p>注意：请确保您的自定义配置文件正确且能够正常运行。在修改配置文件后，您需要重新启动容器使更改生效。</p>
<p>您还可以使用其他高级的Nginx配置选项，例如挂载SSL证书、配置虚拟主机等。请根据您的需求做相应的配置和调整。同时，请务必了解Nginx的配置语法和配置选项以确保正确的使用。</p>
<h1 id="docker-mysql-主从"><a href="#docker-mysql-主从" class="headerlink" title="docker mysql 主从"></a>docker mysql 主从</h1><p>要使用Docker搭建MySQL主从复制，您可以按照以下步骤进行操作：</p>
<ol>
<li><p>拉取MySQL镜像：在Docker中拉取MySQL官方镜像，使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建网络：创建一个Docker网络，以便于主从容器之间的通信。使用以下命令创建网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network create mysql-net</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建主容器：使用以下命令创建主数据库容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql-master --network mysql-net -e MYSQL_ROOT_PASSWORD=&lt;root_password&gt; -p 3306:3306 mysql</span><br></pre></td></tr></table></figure>
<p>在这个命令中，<code>mysql-master</code>是主数据库容器的名称，<code>&lt;root_password&gt;</code>是设置的MySQL root用户的密码。</p>
</li>
<li><p>创建从容器：使用以下命令创建从数据库容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql-slave --network mysql-net -e MYSQL_ROOT_PASSWORD=&lt;root_password&gt; mysql</span><br></pre></td></tr></table></figure>
<p>在这个命令中，<code>mysql-slave</code>是从数据库容器的名称，<code>&lt;root_password&gt;</code>是设置的MySQL root用户的密码。</p>
</li>
<li><p>配置主数据库：首先，连接到主数据库容器，使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-master mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>在MySQL命令行提示符下，执行以下SQL语句，创建一个用于复制的用户并授予相应权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;&lt;replication_password&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>在上述命令中，<code>&lt;replication_password&gt;</code>是用于复制的用户的密码。</p>
</li>
</ol>
<p>接下来，执行以下SQL语句，查看主数据库的状态信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> MASTER STATUS;</span><br></pre></td></tr></table></figure>
<p>记录下这些状态信息，您稍后将在从数据库中使用它们。</p>
<p>退出MySQL命令行提示符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>配置从数据库：连接到从数据库容器，使用以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-slave mysql -uroot -p</span><br></pre></td></tr></table></figure>
在MySQL命令行提示符下，执行以下SQL语句，配置从数据库开始复制主数据库：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;&lt;master_host&gt;&#x27;</span>, MASTER_USER<span class="operator">=</span><span class="string">&#x27;&lt;replication_username&gt;&#x27;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;&lt;replication_password&gt;&#x27;</span>, MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;&lt;master_log_file&gt;&#x27;</span>, MASTER_LOG_POS<span class="operator">=</span><span class="operator">&lt;</span>master_log_position<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
在上述命令中，<code>&lt;master_host&gt;</code>是主数据库的主机名或IP地址，<code>&lt;replication_username&gt;</code>和<code>&lt;replication_password&gt;</code>分别是步骤5中创建的复制用户的用户名和密码，<code>&lt;master_log_file&gt;</code>和<code>&lt;master_log_position&gt;</code>是您在步骤5中记录的主数据库的状态信息。</li>
</ol>
<p>开始从主数据库复制数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></table></figure>
<p>退出MySQL命令行提示符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>现在，您已经成功搭建了MySQL的主从复制。通过在主数据库中进行更改，您将看到从数据库也开始同步这些更改。</p>
<p>请注意，以上步骤只是搭建MySQL主从复制的基本过程，您可能还需要添加其他的配置以满足您的需求。建议您参考MySQL官方文档进行更详细的配置和调整。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>rocketmq</title>
    <url>/blog/2024/01/25/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件，具有以下特性</p>
<ol>
<li>支持发布&#x2F;订阅（Pub&#x2F;Sub）和点对点（P2P）消息模型</li>
<li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li>
<li>支持拉（pull）和推（push）两种消息模式</li>
<li>单一队列百万消息的堆积能力</li>
<li>支持多种消息协议，如 JMS、MQTT 等</li>
<li>分布式高可用的部署架构,满足至少一次消息传递语义</li>
<li>提供 docker 镜像用于隔离测试和云集群部署</li>
<li>提供配置、指标和监控等功能丰富的 Dashboard</li>
</ol>
<h1 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h1><ul>
<li>Producer</li>
</ul>
<p>也就是常说的生产者，生产者的作用就是将消息发送到 MQ，生产者本身既可以产生消息，如读取文本信息，将读取的文本信息发送到 MQ。也可以对外提供接口，由外部应用来调用接口，生产者将收到的请求体内容发送到 MQ。拥有相同 Producer Group 的生产者称为一个生产者集群。</p>
<ul>
<li>Producer Group</li>
</ul>
<p>生产者组，简单来说发送同一类消息的多个生产者就是一个生产者组。</p>
<ul>
<li>Consumer</li>
</ul>
<p>也就是常说的消费者，接收 MQ 消息的应用程序就是一个消费者。拥有相同 Consumer Group 的消费者称为一个消费者集群。</p>
<ul>
<li>Consumer Group</li>
</ul>
<p>消费者组，和生产者类似，消费同一类消息的多个消费者组成一个消费者组。</p>
<ul>
<li>Topic</li>
</ul>
<p>主题是对消息的逻辑分类，比如说有订单类相关的消息，也有库存类相关的消息，那么就需要进行分类，一个是订单 Topic 专门用来存放订单相关的消息，一个是库存 Topic 专门用来存放库存相关的消息。</p>
<ul>
<li>Tag</li>
</ul>
<p>标签可以被认为是对主题的进一步细化，可以理解为二级分类，一般在相同业务模块中通过引入标签来标记不同用途，同时消费者也可以根据不同的标签进行消息的过滤。</p>
<ul>
<li><p>key<br>一般用于消息在业务层面的唯一标识。对发送的消息设置好 Key，以后可以根据这个 Key 来查找消息。比如消息异常，消息丢失，进行查找会很 方便。RocketMQ 会创建专门的索引文件，用来存储 Key 与消息的映射，由于是 Hash 索引，应尽量使 Key 唯一，避免潜在的哈希冲突。Tag 和 Key 的主要差别是使用场景不同，Tag 用在 Consumer 代码中，用于服务端消息过滤，Key 主要用于通过命令进行查找消息RocketMQ 并不能保证 message id 唯一，在这种情况下，生产者在 push 消息的时候可以给每条消息设定唯一的 key, 消费者可以通过 message key 保证对消息幂等处理。</p>
</li>
<li><p>Broker</p>
</li>
</ul>
<p>Broker 是 RocketMQ 系统的主要角色，就是前面一直说的 MQ。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。</p>
<ul>
<li>Name Server</li>
</ul>
<p>Name Server 提供轻量级的服务发现和路由信息，每个 NameServer 记录完整的路由信息，提供等效的读写服务，并支持快速存储扩展。</p>
<p>通俗地讲：</p>
<p>NameService</p>
<p>可以理解为简化的zk，起到一个注册中心的作用区别与ZK是他没有监听的概念，而是通过心跳包来维持自己与Broker之间的关系NameService集群之间的每个节点互相之间没有通信，是无状态的NameService的压力不会太大，主要是维护Topic-Broker之间的映射关系但若是broker中的topic信息量太大，broker向nameService注册信息的时候会导致传输时间过长超时，NameService会误判认为Broker下线。</p>
<p>Broker</p>
<p>每台broker节点与所有的nameService保持长连接及心跳，并定时将Topic信息注册到nameService中每个topic默认创建4个队列，相同的队列中保证顺序消费Broker同样分为master和salve，相同的BrokerName，不同的BrokerId，一个master对应多个salve，一个salve只对应一个master，Broker上存topic信息，topic由多个队列组成，队列会均匀分布到所有的broker上Producer在发送消息时，会尽量平均分布到队列中，这样保证最终所有的消息在broker上是平均分配的</p>
<p>Producer</p>
<p>producer与随机的一个nameService节点建立长连接，定期从nameSerive中拉取topic-broker的映射信息与提供topic的broker master建立一个长连接，producer每隔30秒向broker 发送一个心跳，broker每隔10秒扫描一下存活的链接Producer发送消息支持三种模式</p>
<p>同步</p>
<p>异步</p>
<p>单向</p>
<p>Comsumer</p>
<p>comsumer同样采用集群部署，支持pull、push两种消费模式</p>
<p>comsumer可分为广播消息消费和集群消费</p>
<h1 id="逻辑架构图"><a href="#逻辑架构图" class="headerlink" title="逻辑架构图"></a>逻辑架构图</h1><p><img src="/blog/images/img/mqluoji.png"></p>
<p>Rocketmq的概念模型</p>
<p><img src="/blog/images/img/mqcore.png"></p>
<p>这三者是RocketMq中最最基本的概念。Producer是消息的生产者。Consumer是消息的消费者。消息通过Topic进行传递。Topic存放的是消息的逻辑地址。</p>
<p>具体来说是Producer将消息发往具体的Topic。Consumer订阅Topic，主动拉取或被动接受消息。</p>
<p>实际上，Topic还需要拆封出更多概念</p>
<p><img src="/blog/images/img/mqcoreplus.png"></p>
<p>这张图里有两个生产者，ProducerA和ProducerB。定义了两个Topic-TopicA和TopicB。ProducerA会发送两种消息。</p>
<p>所以这里的知识点是一个Producer可以发中Topic。</p>
<p>TopicA有3个MessageQueue，MessageQueue记录的是消息的物理存储地址（在consumelog里的位置），分布在两个broker上。Broker是一个集群部署架构上的概念，可以理解为对应的物理机器。最右边是ConsumerGroup，每一组下又有多个Consumer，实际上也就是启动的用来消费的JVM。一个Consumer可以订阅多个不同的Topic。这里我有话要说，虽然从代码层面上支持这种订阅。但是强烈不建议一个Consumer订阅多个不同的Topic。推荐用法是一组ConsumerGroup只订阅一种Topic。</p>
<p>另外多组ConsumerGroup之间，对于同一个Topic是广播订阅的。（翻译一下就是说：Topic的一条消息会广播给所有订阅的ConsumerGroup，就是每个ConsumerGroup都会收到），但是在一个ConsumerGroup内部给个Consumer是负载消费消息的，（翻译一下就是：一条消息在一个group内只会被一个Consumer消费）</p>
<h1 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h1><p><img src="/blog/images/img/mqstoremodel.png"></p>
<p>左边的是CommitLog。这个是真正存储消息的地方。可以看出RocketMQ所有生产者的消息都是往这一个地方存的。</p>
<p>右边是ConsumeQueue。这是一个逻辑队列。和上文中Topic下的messageQueue是一一对应的。消费者是直接和ConsumeQueue打交道。ConsumeQueue记录了消费位点，这个消费位点关联了commitlog的位置。所以即使ConsumeQueue出问题，只要commitlog还在，消息就没丢，可以恢复出来。还可以通过修改消费位点来重放或跳过一些消息。</p>
<h1 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h1><p><img src="/blog/images/img/mqdevmodel.png"></p>
<p>在部署RocketMQ时，会部署两种角色。NameServer和Broker。NameServer主要做路由服务。生产者发送消息时，首先向NameServer拿到Topic的路由信息，即这个Topic在哪些Broker上有。Consumer也是一样，需要知道消费队列的路由情况。当然不是每次收发消息都去NameServer查询一遍，简单的说只有第一次初始化，和以后发送或这首出现问题时需要查询一下。</p>
<p>Broker一般我们会部署主备两个节点。</p>
<p>RocketMq没有选举，broker的角色是在部署时就人工确定好的。如果主挂了，备不会自动切换为主。</p>
<p>对于一个2主2备的集群来说，如果挂了一个主，是没有问题的。只要另一个主上你之前也创建了Topic，那么发送的消息流量会导流到存活的主节点上，业务代码端是无影响的。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明并初始化一个producer</span></span><br><span class="line">        <span class="comment">//需要一个producer group名字作为构造方法的参数，这里为producer1</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producer1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置NameServer地址,此处应改为实际NameServer地址，多个地址之间用；分隔</span></span><br><span class="line">        <span class="comment">//NameServer的地址必须有，但是也可以通过环境变量的方式设置，不一定非得写死在代码里</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start()方法启动一个producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送10条消息到Topic为TopicTest，tag为TagA，消息内容为“Hello RocketMQ”拼接上i的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="comment">// topic</span></span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,<span class="comment">// tag</span></span><br><span class="line">                        (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)<span class="comment">// body</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用producer的send()方法发送消息</span></span><br><span class="line">                <span class="comment">//这里调用的是同步的方式，所以会有返回结果</span></span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印返回结果，可以看到消息发送的状态以及一些相关信息</span></span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送完消息之后，调用shutdown()方法关闭producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明并初始化一个consumer</span></span><br><span class="line">        <span class="comment">//需要一个consumer group名字作为构造方法的参数，这里为consumer1</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;consumer1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同样也要设置NameServer地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里设置的是一个consumer的消费策略</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置consumer所订阅的Topic和Tag，*代表全部的Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置一个Listener，主要进行消息的逻辑处理</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Receive New Messages: &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//返回消费状态</span></span><br><span class="line">                <span class="comment">//CONSUME_SUCCESS 消费成功</span></span><br><span class="line">                <span class="comment">//RECONSUME_LATER 消费失败，需要稍后重新消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start()方法启动consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RocketMQ的消息类型"><a href="#RocketMQ的消息类型" class="headerlink" title="RocketMQ的消息类型"></a>RocketMQ的消息类型</h1><p>普通消息 &#x2F; 有序消息 &#x2F; 延时消息</p>
<h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>普通消息也叫做无序消息，简单来说就是没有顺序的消息，producer 只管发送消息，consumer 只管接收消息，至于消息和消息之间的顺序并没有保证，可能先发送的消息先消费，也可能先发送的消息后消费。</p>
<p>举个简单例子，producer 依次发送 order id 为 1、2、3 的消息到 broker，consumer 接到的消息顺序有可能是 1、2、3，也有可能是 2、1、3 等情况，这就是普通消息。</p>
<p>因为不需要保证消息的顺序，所以消息可以大规模并发地发送和消费，吞吐量很高，适合大部分场景。</p>
<h2 id="有序消息"><a href="#有序消息" class="headerlink" title="有序消息"></a>有序消息</h2><p>有序消息就是按照一定的先后顺序的消息类型。</p>
<p>举个例子来说，producer 依次发送 order id 为 1、2、3 的消息到 broker，consumer 接到的消息顺序也就是 1、2、3 ，而不会出现普通消息那样的 2、1、3 等情况。</p>
<p>那么有序消息是如何保证的呢？我们都知道消息首先由 producer 到 broker，再从 broker 到 consumer，分这两步走。那么要保证消息的有序，势必这两步都是要保证有序的，即要保证消息是按有序发送到 broker，broker 也是有序将消息投递给 consumer，两个条件必须同时满足，缺一不可。进一步还可以将有序消息分成</p>
<ul>
<li>全局有序消息</li>
<li>局部有序消息</li>
</ul>
<p>之前我们讲过，topic 只是消息的逻辑分类，内部实现其实是由 queue 组成。当 producer 把消息发送到某个 topic 时，默认是会消息发送到具体的 queue 上。</p>
<p><img src="/blog/images/img/mqmsg.png"></p>
<p>举个例子，producer 发送 order id 为 1、2、3、4 的四条消息到 topicA 上，假设 topicA 的 queue 数为 3 个（queue0、queue1、queue2），那么消息的分布可能就是这种情况，id 为 1 的在 queue0，id 为 2 的在 queue1，id 为 3 的在 queue2，id 为 4 的在 queue0。同样的，consumer 消费时也是按 queue 去消费，这时候就可能出现先消费 1、4，再消费 2、3，和我们的预期不符。那么我们如何实现 1、2、3、4 的消费顺序呢？道理其实很简单，只需要把订单 topic 的 queue 数改为 1，如此一来，只要 producer 按照 1、2、3、4 的顺序去发送消息，那么 consumer 自然也就按照 1、2、3、4 的顺序去消费，这就是全局有序消息。</p>
<p>由于一个 topic 只有一个 queue ，即使我们有多个 producer 实例和 consumer 实例也很难提高消息吞吐量。就好比过独木桥，大家只能一个挨着一个过去，效率低下。</p>
<p>那么有没有吞吐量和有序之间折中的方案呢？其实是有的，就是局部有序消息。</p>
<p><img src="/blog/images/img/mqmsg1.png"></p>
<p>我们知道订单消息可以再细分为订单创建、订单付款、订单完成等消息，这些消息都有相同的 order id。同时，也只有按照订单创建、订单付款、订单完成的顺序去消费才符合业务逻辑。但是不同 order id 的消息是可以并行的，不会影响到业务。这时候就常见做法就是将 order id 进行处理，将 order id 相同的消息发送到 topicB 的同一个 queue，假设我们 topicB 有 2 个 queue，那么我们可以简单的对 id 取余，奇数的发往 queue0，偶数的发往 queue1，消费者按照 queue 去消费时，就能保证 queue0 里面的消息有序消费，queue1 里面的消息有序消费。</p>
<p>由于一个 topic 可以有多个 queue，所以在性能比全局有序高得多。假设 queue 数是 n，理论上性能就是全局有序的 n 倍，当然 consumer 也要跟着增加才行。在实际情况中，这种局部有序消息是会比全局有序消息用的更多。</p>
<p>示例代码</p>
<ul>
<li>生产者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 声明并初始化一个producer</span></span><br><span class="line">            <span class="comment">// 需要一个producer group名字作为构造方法的参数，这里为ordered_producer</span></span><br><span class="line">            <span class="type">DefaultMQProducer</span> <span class="variable">orderedProducer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ordered_producer&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置NameServer地址,此处应改为实际NameServer地址，多个地址之间用；分隔</span></span><br><span class="line">            <span class="comment">//NameServer的地址必须有，但是也可以通过环境变量的方式设置，不一定非得写死在代码里</span></span><br><span class="line">            orderedProducer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用start()方法启动一个producer实例</span></span><br><span class="line">            orderedProducer.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自定义一个tag数组</span></span><br><span class="line">            String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送10条消息到Topic为TopicTestOrdered，tag为tags数组按顺序取值，</span></span><br><span class="line">            <span class="comment">// key值为“KEY”拼接上i的值，消息内容为“Hello RocketMQ”拼接上i的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> i % <span class="number">10</span>;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTestOrdered&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i,</span><br><span class="line">                                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> orderedProducer.send(msg, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 选择发送消息的队列</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// arg的值其实就是orderId</span></span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) arg;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// mqs是队列集合，也就是topic所对应的所有队列</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> id % mqs.size();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 这里根据前面的id对队列集合大小求余来返回所对应的队列</span></span><br><span class="line">                        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, orderId);</span><br><span class="line"></span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            orderedProducer.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于是要实现全局有序，还是局部有序，在此示例代码中，就取决于 TopicTestOrdered 这个 Topic 的队列数了。</p>
<ul>
<li>消费者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明并初始化一个consumer</span></span><br><span class="line">        <span class="comment">//需要一个consumer group名字作为构造方法的参数，这里为concurrent_consumer</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;ordered_consumer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同样也要设置NameServer地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里设置的是一个consumer的消费策略</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置consumer所订阅的Topic和Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTestOrdered&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置一个Listener，主要进行消息的逻辑处理</span></span><br><span class="line">        <span class="comment">//注意这里使用的是MessageListenerOrderly这个接口</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Receive New Messages: &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//返回消费状态</span></span><br><span class="line">                <span class="comment">//SUCCESS 消费成功</span></span><br><span class="line">                <span class="comment">//SUSPEND_CURRENT_QUEUE_A_MOMENT 消费失败，暂停当前队列的消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start()方法启动consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>延时消息，简单来说就是当 producer 将消息发送到 broker 后，会延时一定时间后才投递给 consumer 进行消费。</p>
<p>RcoketMQ的延时等级为：1s，5s，10s，30s，1m，2m，3m，4m，5m，6m，7m，8m，9m，10m，20m，30m，1h，2h。level&#x3D;0，表示不延时。level&#x3D;1，表示 1 级延时，对应延时 1s。level&#x3D;2 表示 2 级延时，对应5s，以此类推。</p>
<p>这种消息一般适用于消息生产和消费之间有时间窗口要求的场景。比如说我们网购时，下单之后是有一个支付时间，超过这个时间未支付，系统就应该自动关闭该笔订单。那么在订单创建的时候就会就需要发送一条延时消息（延时15分钟）后投递给 consumer，consumer 接收消息后再对订单的支付状态进行判断是否关闭订单。</p>
<p>设置延时非常简单，只需要在Message设置对应的延时级别即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="comment">// topic</span></span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,<span class="comment">// tag</span></span><br><span class="line">                        (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)<span class="comment">// body</span></span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 这里设置需要延时的等级即可</span></span><br><span class="line">                msg.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br></pre></td></tr></table></figure>

<h1 id="RocketMQ的消息发送方式"><a href="#RocketMQ的消息发送方式" class="headerlink" title="RocketMQ的消息发送方式"></a>RocketMQ的消息发送方式</h1><ol>
<li>同步发送</li>
<li>异步发送</li>
<li>单向发送</li>
</ol>
<h2 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h2><p><img src="/blog/images/img/mqsycn.png"> </p>
<p>简单来说，同步发送就是指 producer 发送消息后，会在接收到 broker 响应后才继续发下一条消息的通信方式。</p>
<p>由于这种同步发送的方式确保了消息的可靠性，同时也能及时得到消息发送的结果，故而适合一些发送比较重要的消息场景，比如说重要的通知邮件、营销短信等等。在实际应用中，这种同步发送的方式还是用得比较多的。</p>
<h2 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h2><p><img src="/blog/images/img/mqyb.png"> </p>
<p>接着就是异步发送，异步发送是指 producer 发出一条消息后，不需要等待 broker 响应，就接着发送下一条消息的通信方式。需要注意的是，不等待 broker 响应，并不意味着 broker 不响应，而是通过回调接口来接收 broker 的响应。所以要记住一点，异步发送同样可以对消息的响应结果进行处理。</p>
<p>由于异步发送不需要等待 broker 的响应，故在一些比较注重 RT（响应时间）的场景就会比较适用。比如，在一些视频上传的场景，我们知道视频上传之后需要进行转码，如果使用同步发送的方式来通知启动转码服务，那么就需要等待转码完成才能发回转码结果的响应，由于转码时间往往较长，很容易造成响应超时。此时，如果使用的是异步发送通知转码服务，那么就可以等转码完成后，再通过回调接口来接收转码结果的响应了。</p>
<h2 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h2><p><img src="/blog/images/img/mqsinglesend.png"> </p>
<p>单向发送，见名知意，就是一种单方向通信方式，也就是说 producer 只负责发送消息，不等待 broker 发回响应结果，而且也没有回调函数触发，这也就意味着 producer 只发送请求不等待响应结果。</p>
<p>由于单向发送只是简单地发送消息，不需要等待响应，也没有回调接口触发，故发送消息所耗费的时间非常短，同时也意味着消息不可靠。所以这种单向发送比较适用于那些耗时要求非常短，但对可靠性要求并不高的场景，比如说日志收集。</p>
<h1 id="pull和push消费模式"><a href="#pull和push消费模式" class="headerlink" title="pull和push消费模式"></a>pull和push消费模式</h1><p>pull是主动型消费，即能从服务器拉取到数据就开始消费。首先通过打算消费的topic拿到MessageQueue中的集合消息，然后遍历拿取，并记录下次取消息时的offset位</p>
<p>push是被动型消费，多了一个注册消费监听器，本质还是从服务器拉取数据，但是要等到消费监听器被触发以后，才会进行消费。push方式中，注册MessageListener监听器，取到消息后，唤醒MessageListener中的consumerMessage（）来消费</p>
<h1 id="RocketMQ的消费模式"><a href="#RocketMQ的消费模式" class="headerlink" title="RocketMQ的消费模式"></a>RocketMQ的消费模式</h1><ol>
<li>集群消费</li>
<li>广播消费</li>
<li>( 使用集群消费模拟广播消费 )</li>
</ol>
<p>首先明确一点，RocketMQ 是基于发布订阅模型的消息中间件。所谓的发布订阅就是说，consumer 订阅了 broker 上的某个 topic，当 producer 发布消息到 broker 上的该 topic 时，consumer 就能收到该条消息。</p>
<p>之前我们讲过 consumer group 的概念，即消费同一类消息的多个 consumer 实例组成一个消费者组，也可以称为一个 consumer 集群，这些 consumer 实例使用同一个 group name。需要注意一点，除了使用同一个 group name，订阅的 tag 也必须是一样的，只有符合这两个条件的 consumer 实例才能组成 consumer 集群。</p>
<p>集群消费</p>
<p><img src="/blog/images/img/mqmorecum.png"> </p>
<p>当 consumer 使用集群消费时，每条消息只会被 consumer 集群内的任意一个 consumer 实例消费一次。举个例子，当一个 consumer 集群内有 3 个consumer 实例（假设为consumer 1、consumer 2、consumer 3）时，一条消息投递过来，只会被consumer 1、consumer 2、consumer 3中的一个消费。</p>
<p>同时记住一点，使用集群消费的时候，consumer 的消费进度是存储在 broker 上，consumer 自身是不存储消费进度的。消息进度存储在 broker 上的好处在于，当你 consumer 集群是扩大或者缩小时，由于消费进度统一在broker上，消息重复的概率会被大大降低了。</p>
<p>注意：在集群消费模式下，并不能保证每一次消息失败重投都投递到同一个 consumer 实例。</p>
<p>广播消费</p>
<p><img src="/blog/images/img/mqpub.png"> </p>
<p>当 consumer 使用广播消费时，每条消息都会被 consumer 集群内所有的 consumer 实例消费一次，也就是说每条消息至少被每一个 consumer 实例消费一次。举个例子，当一个 consumer 集群内有 3 个 consumer 实例（假设为 consumer 1、consumer 2、consumer 3）时，一条消息投递过来，会被 consumer 1、consumer 2、consumer 3都消费一次。</p>
<p>与集群消费不同的是，consumer 的消费进度是存储在各个 consumer 实例上，这就容易造成消息重复。还有很重要的一点，对于广播消费来说，是不会进行消费失败重投的，所以在 consumer 端消费逻辑处理时，需要额外关注消费失败的情况。</p>
<p>虽然广播消费能保证集群内每个 consumer 实例都能消费消息，但是消费进度的维护、不具备消息重投的机制大大影响了实际的使用。因此，在实际使用中，更推荐使用集群消费，因为集群消费不仅拥有消费进度存储的可靠性，还具有消息重投的机制。而且，我们通过集群消费也可以达到广播消费的效果。</p>
<p>使用集群消费模拟广播消费</p>
<p><img src="/blog/images/img/mqjq.png"> </p>
<p>如果业务上确实需要使用广播消费，那么我们可以通过创建多个 consumer 实例，每个 consumer 实例属于不同的 consumer group，但是它们都订阅同一个 topic。举个例子，我们创建 3 个 consumer 实例，consumer 1（属于consumer group 1）、consumer 2（属于 consumer group 2）、consumer 3（属于consumer group 3），它们都订阅了 topic A ，那么当 producer 发送一条消息到 topic A 上时，由于 3 个consumer 属于不同的 consumer group，所以 3 个consumer都能收到消息，也就达到了广播消费的效果了。除此之外，每个 consumer 实例的消费逻辑可以一样也可以不一样，每个consumer group还可以根据需要增加 consumer 实例，比起广播消费来说更加灵活。 </p>
<h1 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h1><p>说到消息过滤，就不得不说到 tag。没错，就是我们之前在专业术语中提到过的 tag。也称为消息标签，用来标记 Topic 下的不同用途的消息。</p>
<p>在 RocketMQ 中消费者是可以按照 Tag 对消息进行过滤。举个电商交易场景的例子，用户下完订单之后，在后台会产生一系列的消息，比如说订单消息、支付消息和物流消息。假设这些消息都发送到 Topic 为 Trade 中，同时用 tag 为 order 来标记订单消息，用 tag 为 pay 来标记支付消息，用 tag 为 logistics 来标记物流消息。需要支付消息的支付系统（相当于一个 consumer）订阅 Trade 中 tag 为 pay 的消息，此时，broker 则只会把 tag 为 pay 的消息投递给支付系统。而如果是一个实时计算系统，它可能需要接收所有和交易相关的消息，那么只要它订阅 Trade 中 tag 为 order、pay、logistics 的消息，broker 就会把带有这些 tag 的消息投递给实时计算系统。</p>
<p>对于消息分类，我们可以选择创建多个 Topic 来区分，也可以选择在同一个 Topic 下创建多个 tag 来区分。这两种方式都是可行的，但是一般情况下，不同的 Topic 之间的消息是没有什么必然联系的，使用 tag 来区分同一个 Topic 下相互关联的消息则更加合适一些。</p>
<h1 id="订阅关系一致性"><a href="#订阅关系一致性" class="headerlink" title="订阅关系一致性"></a>订阅关系一致性</h1><p>讲完了消息过滤，我们接着讲讲什么是订阅关系一致性呢？其实在讲 RocketMQ 消费模式的时候提到过，除了使用同一个 group name，订阅的 tag 也必须是一样的，只有符合这两个条件的 consumer 实例才能组成 consumer 集群。这里所说的其实就是订阅关系一致性。在 RocketMQ 中，订阅关系由 Topic和 Tag 组成，因此要保证订阅关系一致性，就必须同时保证这两点：</p>
<ul>
<li><p>订阅的 Topic 必须一致</p>
</li>
<li><p>订阅的 Topic 中的 tag 必须一致</p>
</li>
</ul>
<p>保证订阅关系一致性是非常重要的，一旦订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失，这对于大部分业务场景来说都是不允许的，甚至是致命的。在实际使用中，切记同一个消费者集群内的所有消费者实例务必要保证订阅关系的一致性。</p>
<p><img src="/blog/images/img/mqyzx.png"></p>
<p> 备注：图中 “*” 代表订阅该Topic下所有的 tag。</p>
<p>我们用具体的例子来解释一下，如图 1 所示，消费者集群中有 3 个 consumer 实例，分别为 C1、C2、C3，各自订阅的 topic 和 tag 各不相同。首先 C1 和 C2 都订阅 TopicA，满足了订阅关系一致性的第一点，但是 C1 订阅的是 TopicA 的 Tag1，而 C2 订阅的是 TopicA 的 Tag2，不满足订阅关系一致性的第二点，所以 C1、C2 不满足订阅关系一致性。而 C3 订阅的 Topic 和 Tag 都与 C1 和 C2不一样，同样也不满足订阅关系一致性。</p>
<p><img src="/blog/images/img/mqyzx1.png"></p>
<p>备注：图中 “||” 用来连接不用的 tag，表示与的意思。</p>
<p>在图 2 中，消费者集群中有 3 个 consumer 实例，分别为 C1、C2、C3，都是订阅 TopicA 下的 Tag1 和 Tag2，满足了订阅关系一致性的两点要求，所以满足了订阅关系一致性。</p>
<p><img src="/blog/images/img/mqyzx2.png"></p>
<p>如图 3 所示，一个 consumer 也可以订阅多个 Topic，同时也必须保证该 consumer 集群里的多个消费者实例的订阅关系一致性，才不会造成不必要的麻烦。</p>
<p>在实际使用中，消息过滤可以帮助我们只消费我们所需要的消息，这是在broker端就帮我们处理好的，大大减少了在 consumer 端的消息过滤处理，一方面减少了代码量，另一方面更减少了不必要消息的网络传输消耗。</p>
<p>订阅消息一致性则保证了同一个消费者集群中 consumer 实例的正常运行，避免消息逻辑的混乱和消息的丢失。所以在实际使用中，在 producer 端要做好消息的分类，便于 consumer 可以使用 tag 进行消息的准确订阅，而在 consumer 端，则要保证订阅关系一致性。</p>
<h1 id="RocketMQ的消息重试"><a href="#RocketMQ的消息重试" class="headerlink" title="RocketMQ的消息重试"></a>RocketMQ的消息重试</h1><p>首先明确之前说过的，消息重试只针对集群消费模式，广播消费没有消息重试的特性，消费失败之后，只会继续消费下一条消息。这也是为什么我们一再强调，推荐大家使用集群消费模式，其消息重试的特性能给开发者带来极大的方便。</p>
<p>那么什么是消息重试呢？简单来说，就是当消费者消费消息失败后，broker 会重新投递该消息，直到消费成功。在 RocketMQ 中，当消费者使用集群消费模式时，消费者接收到消息并进行相应的逻辑处理之后，最后都要返回一个状态值给 broker。这样 broker 才知道是否消费成功，需不需要重新投递消息。也就是说，我们可以通过设置返回的状态值来告诉 broker 是否重新投递消息。</p>
<p>到这里，可能大家会有一个疑问，那如果这条消息本身就是一条脏数据，就算你消费 100 次也不会消费成功，难道还是一直去重试嘛？其实 RocketMQ 并不会无限制地重试下去，默认每条消息最多重试 16 次，而每次重试的间隔时间如下表所示：</p>
<p><img src="/blog/images/img/mqretry.png"></p>
<p>那么如果消息重试 16 次之后还是消费失败怎么办呢？那么消息就不会再投递给消费者，而是将消息放到相对应的死信队列中。这时候我们就需要对死信队列的消息做一些人工补偿处理，因为这些消息可能本身就有问题，也有可能和消费逻辑调用的服务有关等，所以需要人工判断之后再进行处理。</p>
<p>到这里不知道大家有没有一个疑问，那就是什么样的情况才叫消费失败呢？可以分为 3 种情况：</p>
<ol>
<li><p>返回 ConsumeConcurrentlyStatus.RECONSUME_LATER</p>
</li>
<li><p>返回 null</p>
</li>
<li><p>抛出异常</p>
</li>
</ol>
<p>前两种情况都比较好理解，就是前面说过的设置状态值，也就是说，只需要消费者返回 ConsumeConcurrentlyStatus.RECONSUME_LATER 或者 null，就相当于告诉 broker 说，这条消息我消费失败了，你给我重新投递一次。而对于抛出异常这种情况，只要在你处理消费逻辑的地方抛出了异常,那么 broker 也重新投递这条消息。注意一点，如果是被捕获的异常，则不会进行消息重试。</p>
<h1 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h1><p>首先什么是消费幂等呢？简单来说就是对于一条消息的处理结果，不管这条消息被处理多少次，最终的结果都一样。比如说，你收到一条消息是要更新一个商品的价格为 6.8 元，那么当这条消息执行 1 次，还是执行 100 次，最终在数据库里的该商品价格就是 6.8 元，这就是所谓的幂等。 那么为什么消费需要幂等呢？因为在实际使用中，尤其在网络不稳定的情况下，RocketMQ 的消息有可能会出现重复，包括两种情况：</p>
<p>发送时消息重复；</p>
<p>投递时消息重复；</p>
<p>第一种情况是生产者发送消息的场景，消息已成功发送到 broker ，但是此时可能发生网络闪断或者生产者宕机了，导致 broker 发回的响应失败。这时候生产者由于没有收到响应，认为消息发送失败，于是尝试再次发送消息给 broker。这样一来，broker 就会再收到一条一模一样内容的消息，最终造成了消<br>费者也收到两条内容一模一样的消息。</p>
<p>第二种情况是消费者消费消息的场景，消息已投递到消费者并完成消费逻辑处理，当消费者给 broker 反馈消费状态时可能发生网络闪断。broker 收不到消费者的消费状态，为了保证至少消费一次的语义，broker 将在网络恢复后再次尝试投递之前已经被处理过的消息，最终造成消费者收到两条内容一模一样的消息。</p>
<p>当然对于一些允许消息重复的场景，大可以不必关心消费幂等。但是对于那些不允许消息重复的业务场景来说，处理建议就是通过业务上的唯一标识来作为幂等处理的依据。</p>
<p>消息重试，保证了消费消息的容错性，即使消费失败，也不需要开发者自己去编写代码来做补偿，大大提高了开发效率，同时也是 RocketMQ 相较于其他 MQ 的一个非常好的特性。而消费幂等主要是针对那些不允许消息重复的场景，应该说大部分 MQ 都需要幂等处理，这属于代码逻辑或者说业务上的需要，最好的处理方式就是前面所说的根据业务上唯一标识来作为幂等处理的依据。</p>
<h1 id="消息的重复消费问题及措施"><a href="#消息的重复消费问题及措施" class="headerlink" title="消息的重复消费问题及措施"></a>消息的重复消费问题及措施</h1><p>消息的重复消费问题及措施出现消息的重复消费的原因是因为我们的rocketmq支持失败重试的机制，一些极端情况下，例如消费超时，或者mq没有收到消费端的ACK确认码，将消息发给其他消费者而出现的重复问题</p>
<ol>
<li>针对普通场景，建立一个消息表。对于每条消息，创建唯一的标识，这样避免相同的消息出现重复消费</li>
<li>针对并发较高的场景，可以通过redis来代替消息表</li>
<li>甚至可以考虑布隆过滤器，但是布隆过滤器存在一定的误报风险，当误报时，会认为该条消息已存在（实际不存在），导致正常消息无法被消费</li>
</ol>
<h1 id="Rocketmq刷盘策略"><a href="#Rocketmq刷盘策略" class="headerlink" title="Rocketmq刷盘策略"></a>Rocketmq刷盘策略</h1><p>所有消息都是持久化的，先写入pagecache区，再写入磁盘，保证磁盘和内存均有一份数据，读取时读取内存数据</p>
<p>使用哪种刷盘方式可以调整broker配置文件中的</p>
<p>flushType &#x3D; SYNC_FLUSH  or ASYNC_FLUSH</p>
<ul>
<li>同步刷盘</li>
</ul>
<ol>
<li>消息存储磁盘后才会返回成功</li>
<li>当消息存入pagecache区域时，立即通知刷盘线程，完成刷盘工作后，返回成功</li>
<li>同步刷盘更稳定，但是吞吐较低，适用于要求消息可靠性更高的场景</li>
</ol>
<ul>
<li>异步刷盘</li>
</ul>
<ol>
<li>消息存入pagecache区，即返回成功，当内存区域数据达到一定容量时，统一写入磁盘</li>
<li>异步刷盘高吞吐，写操作返回快</li>
<li>意外情况下断电，会导致pagecache区域尚未刷入磁盘的部分数据丢失，但是吞吐性更高</li>
</ol>
<h1 id="Rocketmq复制策略"><a href="#Rocketmq复制策略" class="headerlink" title="Rocketmq复制策略"></a>Rocketmq复制策略</h1><p>当broker以集群形式分布，需要进行消息的主从同步时，会使用到复制策略</p>
<ul>
<li>同步复制</li>
</ul>
<p>master和salve均写入成功后，返回成功</p>
<p>master和salve数据同步，不易丢失，但是吞吐相对较低</p>
<ul>
<li>异步复制</li>
</ul>
<p>master数据写入成功后，立即返回成功</p>
<p>master莫名其妙宕机后，可能会出现master和salve的数据不一致的情况，吞吐性能更高</p>
<p>建议推荐方式：异步刷盘+同步复制</p>
<h1 id="RocketMq消息丢失场景及解决方案"><a href="#RocketMq消息丢失场景及解决方案" class="headerlink" title="RocketMq消息丢失场景及解决方案"></a>RocketMq消息丢失场景及解决方案</h1><p><img src="/blog/images/img/mqlosemsg.png"></p>
<ol>
<li>生产者将消息发送给mq途中，因出现网络抖动，导致消息丢失</li>
<li>消息存储在pagecache区，且尚未触发异步刷盘，而出现断电一类，导致数据丢失。或是存入磁盘后，磁盘损坏导致数据丢失</li>
<li>Consumer从mq中拿取数据，尚未完成消费，就通知mq消费完毕，然后消费者宕机，导致消息丢失</li>
</ol>
<p>解决方案</p>
<p>场景一：</p>
<p>基于生产者的分布式事务来解决</p>
<p>若是消息推送mq过程中丢失，则执行回滚操作</p>
<p>生产者发送完消息以后，mq即使接收到响应成功后，暂时消费者也不会消费的（此时处于半消息状态）</p>
<p>生产者会执行自己的链路，若是执行完毕且成功，会再次通知mq将消息commit（二次确认机制），否则进行rollback操作</p>
<p>场景二：</p>
<p>将异步刷盘改为同步刷盘，同时对于broker进行集群化部署，进行主从复制策略</p>
<p>场景三：</p>
<p>mq会在消费端注册一个监听，当consumer拿去到消息消费时，只有消费成功后，才会发送一个COMSUME_SUCCESS的状态，mq会知道消费成功<br>（类似与一个ACK的确认机制）</p>
<p>当节点挂掉时，rocketmq长时间收不到响应（监听也没了），就会进行故障转移，将消息发给其他消费者处理</p>
<h1 id="rocket-mq-消息投递状态"><a href="#rocket-mq-消息投递状态" class="headerlink" title="rocket mq 消息投递状态"></a>rocket mq 消息投递状态</h1><ol>
<li><p>NOT_ONLINE 订阅端不在线</p>
</li>
<li><p>CONSUMED 消息已经被投递</p>
</li>
</ol>
<p>订阅端返回ReconsumerLater，或者返回NULL，或者抛出异常，消息都会走重试流程，消息投递状态都是CONSUMED。</p>
<ol start="3">
<li>CONSUMED_BUT_FILTERED 消息已经被投递且被过滤</li>
</ol>
<p><strong>比如，发布端发布消息topicA，tagA，订阅端订阅topicA，tagB, tagA的消息就被集群消费的消费者忽略掉了</strong></p>
<ol start="4">
<li>NOT_CONSUME_YET 消息未被投递</li>
</ol>
<p>有可能消息发生了堆积，还未被消费；也有可能消费线程hang住了，导致消费线程迟迟没有返回。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>rocketmq</category>
      </categories>
  </entry>
  <entry>
    <title>redis入门</title>
    <url>/blog/2023/09/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h1><ol>
<li>下载</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解压</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz </span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编译<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.6</span><br><span class="line"></span><br><span class="line">make install PREFIX=/usr/local/redis</span><br><span class="line"></span><br></pre></td></tr></table></figure>
若编译失败，安装C语言编译器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf automake make</span><br></pre></td></tr></table></figure></li>
<li>开机自启<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /lib/systemd/system/</span><br><span class="line"></span><br><span class="line">vim redis.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis.service内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line"># ExecStart需要按照实际情况修改成自己的地址</span><br><span class="line">ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
没有redis.conf文件，从解压文件里拷贝</li>
</ol>
<p>重新加载服务的配置文件 systemctl daemon-reload</p>
<p>设置开机启动systemctl enable redis.service</p>
<p>启动服务 systemctl start redis.service</p>
<p>查看服务状态 systemctl status redis.service</p>
<ol start="5">
<li>解决客户端连接不上的问题</li>
</ol>
<p>修改redis.conf文件</p>
<p><img src="/blog/images/img/redis1.png" alt="redis1"></p>
<p><img src="/blog/images/img/redis2.png" alt="redis2"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>shiro</title>
    <url>/blog/2023/11/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/shiro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="一、什么是shiro？"><a href="#一、什么是shiro？" class="headerlink" title="一、什么是shiro？"></a>一、什么是shiro？</h1><ul>
<li>Apache Shiro是Java的一个安全（权限）框架。</li>
<li>Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。</li>
<li>Shiro可以完成：认证、授权、加密、会话管理、与Web集成、缓存等。</li>
<li>Shiro官网:<a href="http://shiro.apache.org/">http://shiro.apache.org/</a></li>
</ul>
<h1 id="二、shiro基础架构"><a href="#二、shiro基础架构" class="headerlink" title="二、shiro基础架构"></a>二、shiro基础架构</h1><p><img src="/blog/images/img/ShiroBasicArchitecture.png" alt="ShiroBasicArchitecture"></p>
<ul>
<li>Subject：任何直接与应用代码交互的对象。Subject代表了当前“用户”，这个用户不具体指代某个人，只要与当前应用交互的任何东西都是Subject，如第三方服务、网络爬虫、机器人等；所有Subject实例都必须被绑定到一个SecurityManager上,SecurityManager才是实际的执行者;</li>
<li>SecurityManager（安全管理器）：与安全有关的操作都会与SecurityManager进行交互；管理着所有的Subject；它是Shiro的核心，负责与Shiro的其他组件进行交互，相当于SpringMVC中DispatcherServlet的角色；</li>
<li>Realm：担当Shiro和你的应用程序的安全数据之间的“桥梁”或“连接器”。Shiro可以从Realm中获取安全数据（如用户、角色、权限），即认证和授权等操作所需要的安全数据都需要从Realm中获得；</li>
</ul>
<h1 id="三、Shiro的核心架构"><a href="#三、Shiro的核心架构" class="headerlink" title="三、Shiro的核心架构"></a>三、Shiro的核心架构</h1><p><img src="/blog/images/img/ShiroArchitecture.png" alt="ShiroArchitecture"></p>
<ul>
<li>Subject：任何直接与应用代码交互的对象；</li>
<li>SecurityManager（安全管理器）：所有与安全相关的操作都会与SecurityManager进行交互；它管理着所有的Subject；它是Shiro的核心，负责与Shiro的其他组件进行交互，相当于SpringMVC中DispatcherServlet的角色；</li>
<li>Authenticator：负责Subject认证，当一个用户尝试登录时，该逻辑被 Authenticator执行；且它是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过；</li>
<li>Authorizer（授权器）：即访问控制器，用来决定主体（Subject）是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li>
<li>Realm：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全数据；可以是JDBC实现，也可以是内存实现等等；它由用户提供，所以一般在应用中都需要实现自己的Realm；</li>
<li>SessionManager：管理所有用户登录后的会话信息。用户登录后用Subject.getSession() 即可获取会话，在没有退出之前，用户的所有信息都在会话中；会话可以是普通JavaSE环境，也可以是Web环境的；</li>
<li>CacheManager（缓存控制器）：管理如用户、角色、权限等信息的缓存；因为这些数据 基本上很少改变，放到缓存中后可以提高访问的性能；</li>
<li>Cryptography：密码模块，Shiro提供了一些常见的加密组件用于如密码加密&#x2F;解密；</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>shiro</category>
      </categories>
  </entry>
  <entry>
    <title>nacos</title>
    <url>/blog/2023/07/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/nacos/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      <categories>
        <category>中间件</category>
        <category>nacos</category>
      </categories>
  </entry>
  <entry>
    <title>英语语法体系</title>
    <url>/blog/2023/11/16/%E5%85%B6%E4%BB%96/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="语法综述"><a href="#语法综述" class="headerlink" title="语法综述"></a>语法综述</h1><h2 id="所有的英语都是由（主语-谓语）组成"><a href="#所有的英语都是由（主语-谓语）组成" class="headerlink" title="所有的英语都是由（主语+谓语）组成"></a>所有的英语都是由（主语+谓语）组成</h2><p>主语：人&#x2F;物</p>
<p>谓语：动作&#x2F;发生了什么事</p>
<ul>
<li>动作：</li>
</ul>
<ol>
<li><p>可以独立完成的动作，比如没有承受者的不及物动词。</p>
<p> He sleeps.</p>
<p> 主语+谓语</p>
<p> 主语+不及物动词</p>
</li>
<li><p>有一个动作承受者，比如有承受者的及物动词。</p>
<p> I like you</p>
<p> 主语+谓语+宾语</p>
<p> 主语+单及物动词+宾语</p>
</li>
<li><p>有两个动作承受者，比如双及物动词。</p>
<p> He teaches you English</p>
<p> 主语+双及物动词+间接宾语+直接宾语</p>
</li>
<li><p>只有一个动作承受者（但需补充）</p>
<p> He considers you smart</p>
<p> 主语+复杂及物动词+宾语+（宾语）补语    </p>
</li>
<li><p>非”动作”</p>
<p> 主语+系动词+（主语）补语&#x2F;表语</p>
<p> 系动词：连系之词，相当于&#x3D;</p>
<p> 补语&#x2F;表语：修饰主语的词</p>
</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
        <category>英语</category>
      </categories>
  </entry>
  <entry>
    <title>Vue2</title>
    <url>/blog/2023/06/01/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="什么是-Vue？​"><a href="#什么是-Vue？​" class="headerlink" title="什么是 Vue？​"></a>什么是 Vue？​</h1><p>Vue (发音为 &#x2F;vjuː&#x2F;，类似 view) 是一款用于构建用户界面的 <strong>JavaScript 框架</strong>。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p>
<p>其特点是组件化（vue文件封装DOM，css，js）、声明式编码（不直接DOM操作DOM，而是用vue自定义的指令（实际就是不用自己写js脚本操作DOM）、渐进式（可以用简单的核心包搭建项目，后续可以根据需要增加必要的插件））。</p>
<p><em>注：Vue 2 将于 2023 年 12 月 31 日停止维护。</em></p>
<h1 id="1-模板语法"><a href="#1-模板语法" class="headerlink" title="1.模板语法"></a>1.模板语法</h1><p>插值语法：用于解析标签体内容</p>
<p>指令语法：用于解析标签属性，内容，绑定事件等等（vue自定义的指令，以v-开头）。</p>
<h1 id="2-数据绑定"><a href="#2-数据绑定" class="headerlink" title="2.数据绑定"></a>2.数据绑定</h1><h2 id="v-bind-和-v-model"><a href="#v-bind-和-v-model" class="headerlink" title="v-bind 和 v-model"></a>v-bind 和 v-model</h2><p>v-bind是单向绑定，vue实例属性变化标签value会变化，标签value变化不会引起vue实例属性的变化。一般简写成:value。</p>
<p>v-model是双向绑定，标签value和vue实例属性变化任意一方变化，都会引起一方变化。只能用于form表单元素。因为是对form表单元素value的绑定，所以一般v-model:value写成v-model。</p>
<p><em><strong>tips：由vue管理的函数不要用箭头函数，不然函数体里的this就不是vue函数</strong></em></p>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>MVVM指的是Model，View，ViewModel。在vue中，Model指的是一般的js对象，View指的是DOM，ViewModel指的是vue实例对象。</p>
<h1 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>Object.defineProperty 设置的对象属性不参与枚举（遍历）。</li>
</ul>
<p><em>如果想枚举属性，可以设置参数enumerable为true。</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&quot;sex&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 属性是否可以枚举</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span> <span class="comment">// 属性是否可以修改</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span> <span class="comment">// 属性是否可以删除</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>getter和setter函数。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&quot;age&quot;</span>,&#123;</span><br><span class="line">    <span class="comment">// 当读取person属性age时，get函数（getter）就会被调用，且返回值就是age</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当读取person属性age时，set函数（setter）就会被调用，且收到修改的值</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        number = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据代理定义"><a href="#数据代理定义" class="headerlink" title="数据代理定义"></a>数据代理定义</h2><p>通过一个对象代理对另一个对象的属性操作（读写）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">x</span>:<span class="number">100</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">y</span>:<span class="number">200</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj2,<span class="string">&#x27;x&#x27;</span>,&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj1.<span class="property">x</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        obj1.<span class="property">x</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>obj2代理对obj1中x属性操作。</p>
<h1 id="vue数据代理"><a href="#vue数据代理" class="headerlink" title="vue数据代理"></a>vue数据代理</h1><p>通过vm对象代理data属性中的操作（读写）<br>原理：通过 Object.defineProperty()把data对象中的属性添加到vm对象上，为每一个添加到vm的属性指定getter和setter，通过getter和setter操作data中的属性。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>指令：v-on:事件名称 简写@事件名称</p>
<blockquote>
<p>事件修饰符</p>
</blockquote>
<ul>
<li><p>stop 阻止事件冒泡</p>
</li>
<li><p>prevent 阻止默认事件</p>
</li>
<li><p>self 只有event.target是当前操作元素才触发</p>
</li>
<li><p>capture 使用事件的捕获方式</p>
</li>
<li><p>once 事件只触发一次</p>
</li>
<li><p>passive 立即执行，无需等待事件回调</p>
<blockquote>
<p>键盘事件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 仅在 <span class="string">`key`</span> 为 <span class="string">`Enter`</span> 时调用 <span class="string">`submit`</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>Vue 为一些常用的按键提供了别名：</p>
</li>
<li><p>enter</p>
</li>
<li><p>tab</p>
</li>
<li><p>delete (捕获“Delete”和“Backspace”两个按键)</p>
</li>
<li><p>esc</p>
</li>
<li><p>space</p>
</li>
<li><p>up</p>
</li>
<li><p>down</p>
</li>
<li><p>left</p>
</li>
<li><p>right</p>
</li>
</ul>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">author</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,</span><br><span class="line">        <span class="attr">books</span>: [</span><br><span class="line">          <span class="string">&#x27;Vue 2 - Advanced Guide&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Vue 3 - Basic Guide&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Vue 4 - The Mystery&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 一个计算属性的 getter</span></span><br><span class="line">    <span class="title function_">publishedBooksMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// `this` 指向当前组件实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">author</span>.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;Yes&#x27;</span> : <span class="string">&#x27;No&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和method相比，计算属性有缓存，效率高。</p>
<h1 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h1><p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">      <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">fullName</span>: &#123;</span><br><span class="line">      <span class="comment">// getter</span></span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// setter</span></span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：我们这里使用的是解构赋值语法</span></span><br><span class="line">        [<span class="variable language_">this</span>.<span class="property">firstName</span>, <span class="variable language_">this</span>.<span class="property">lastName</span>] = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h1><p>计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。</p>
<p>在选项式 API 中，我们可以使用 watch 选项在每次响应式属性发生变化时触发一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">answer</span>: <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 每当 question 改变时，这个函数就会执行</span></span><br><span class="line">    <span class="title function_">question</span>(<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newQuestion.<span class="title function_">includes</span>(<span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAnswer</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">getAnswer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Thinking...&#x27;</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">answer</span> = (<span class="keyword">await</span> res.<span class="title function_">json</span>()).<span class="property">answer</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">someObject</span>: &#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：在嵌套的变更中，</span></span><br><span class="line">        <span class="comment">// 只要没有替换对象本身，</span></span><br><span class="line">        <span class="comment">// 那么这里的 `newValue` 和 `oldValue` 相同</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="this-watch"><a href="#this-watch" class="headerlink" title="this.$watch()"></a>this.$watch()</h1><p>我们也可以使用组件实例的 $watch() 方法来命令式地创建一个侦听器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$watch(<span class="string">&#x27;question&#x27;</span>, <span class="function">(<span class="params">newQuestion</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>tips: watch一般做异步调用</em></p>
<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 class 和 style 都是 attribute，我们可以和其他 attribute 一样使用 v-bind 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p>
<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p>v-if v-show</p>
<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><p>v-for</p>
<blockquote>
<p>列表中key的原理<br>虚拟DOM根据key进行diff算法比较</p>
</blockquote>
<h1 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h1><p>配合css控制页面插值标签显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">style &#123;</span><br><span class="line">  [v-cloak]: &#123;</span><br><span class="line">    display:none</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h1><p>完成模板解析并把真实DOM加载到页面</p>
<h1 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VueComponent.prototype.__proto__===Vue.prototype</span><br></pre></td></tr></table></figure>
<h1 id="组件自定义事件"><a href="#组件自定义事件" class="headerlink" title="组件自定义事件"></a>组件自定义事件</h1><p>子组件给父组件传值</p>
<p>1.通过父组件给子组件传递函数类型的props</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;School :getSchoolName=&quot;getSchoolName&quot;&gt;&lt;/School&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义事件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;School @getMsg=&quot;getSchoolName&quot;&gt;&lt;/school&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> name: &#x27;App&#x27;,</span><br><span class="line"> components: &#123;</span><br><span class="line">   School</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line">   // getSchoolName(name) &#123;</span><br><span class="line">   //   console.log(&quot;接受到来自子组件school的值：&quot;+name)</span><br><span class="line">   // &#125;</span><br><span class="line">   getSchoolName(name) &#123;</span><br><span class="line">     console.log(&quot;@@@@@@@@@&quot;+name)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=&quot;sendMsg&quot;&gt;把学校名给APP&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">       name: &#x27;School&#x27;,</span><br><span class="line">       props: [&#x27;getSchoolName&#x27;],</span><br><span class="line">       data() &#123;</span><br><span class="line">           return &#123;</span><br><span class="line">               name: &quot;墨家学院&quot;,</span><br><span class="line">               address: &quot;开普勒-452b&quot;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line">           sendMsg() &#123;</span><br><span class="line">               this.$emit(&#x27;getMsg&#x27;,this.name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>ref<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;School ref=&quot;school&quot;&gt;&lt;/school&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    School</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // getSchoolName(name) &#123;</span><br><span class="line">    //   console.log(&quot;接受到来自子组件school的值：&quot;+name)</span><br><span class="line">    // &#125;</span><br><span class="line">    getSchoolName(name) &#123;</span><br><span class="line">      console.log(&quot;@@@@@@@@@&quot;+name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">   this.$refs.school.$on(&#x27;getMsg&#x27;,this.getSchoolName) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=&quot;sendMsg&quot;&gt;把学校名给APP&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">        name: &#x27;School&#x27;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                name: &quot;墨家学院&quot;,</span><br><span class="line">                address: &quot;开普勒-452b&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sendMsg() &#123;</span><br><span class="line">                this.$emit(&#x27;getMsg&#x27;,this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  beforecreated: &#123;</span><br><span class="line">    Vue.prototype.$bus=this </span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h1><h1 id="默认插槽，具名插槽，作用域插槽"><a href="#默认插槽，具名插槽，作用域插槽" class="headerlink" title="默认插槽，具名插槽，作用域插槽"></a>默认插槽，具名插槽，作用域插槽</h1><h1 id="history-和-hash"><a href="#history-和-hash" class="headerlink" title="history 和 hash"></a>history 和 hash</h1><p>hash “<a href="http://127.0.0.1/index/#/user%E2%80%9D">http://127.0.0.1/index/#/user”</a> #后面的内容不会发给服务器。<br>history 会请求服务器地址 </p>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins应用</title>
    <url>/blog/2023/07/05/%E5%B7%A5%E5%85%B7/Jenkins%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      <categories>
        <category>工具</category>
        <category>Jenkins</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装es-kibana</title>
    <url>/blog/2023/09/29/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85es-kibana/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="elasticsearch安装配置"><a href="#elasticsearch安装配置" class="headerlink" title="elasticsearch安装配置"></a>elasticsearch安装配置</h1><ol>
<li><p>需要jdk的支持，没有安装请安装</p>
</li>
<li><p>下载es</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -c https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.2.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>解压es</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xf elasticsearch-5.6.2.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>移动到&#x2F;usr&#x2F;local</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv elasticsearch-5.6.2 /usr/local/elasticsearch</span><br></pre></td></tr></table></figure></li>
<li><p>创建数据目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /data</span><br><span class="line">mkdir /data/search</span><br><span class="line">mkdir /data/search/log</span><br><span class="line">useradd elasticsearch</span><br><span class="line">chown -R elasticsearch:elasticsearch /data/search</span><br><span class="line">chown -R elasticsearch:elasticsearch /usr/local/elasticsearch</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件</p>
</li>
</ol>
<p>vi &#x2F;usr&#x2F;local&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node.name: node-1</span><br><span class="line">node.attr.rack: r1</span><br><span class="line">path.data: /data/search</span><br><span class="line">path.logs: /data/search/log</span><br><span class="line">network.host: 127.0.0.1</span><br><span class="line">http.port: 9200</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>系统配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.max_map_count=65536</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">vi /usr/local/elasticsearch/config/jvm.options </span><br><span class="line"></span><br><span class="line">-Xms512M</span><br><span class="line">-Xmx512M</span><br><span class="line">-XX:-AssumeMP</span><br><span class="line"></span><br><span class="line">vi /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">* soft nproc 65535</span><br><span class="line">* hard nproc 65535</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>开机自启<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/search.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Elasticsearch</span><br><span class="line">After=default.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=elasticsearch</span><br><span class="line">Group=elasticsearch</span><br><span class="line">Type=forking</span><br><span class="line"># 按需处理环境变量</span><br><span class="line"># Environment=&quot;JAVA_HOME=/usr/local/jdk&quot;</span><br><span class="line">ExecStart=/usr/local/elasticsearch/bin/elasticsearch -d</span><br><span class="line">PrivateTmp=true</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line">StartLimitInterval=0</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable search</span><br><span class="line">systemctl start search</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="kibana安装配置"><a href="#kibana安装配置" class="headerlink" title="kibana安装配置"></a>kibana安装配置</h1><p>1.下载安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.0.0-x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install -y kibana-6.0.0-x86_64.rpm </span><br></pre></td></tr></table></figure>
<p>2.修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/kibana/kibana.yml </span><br><span class="line">server.port: 5601        							//监听端口</span><br><span class="line">server.host: &quot;127.0.0.1&quot;      					//监听IP地址，建议内网ip</span><br><span class="line">elasticsearch.url: &quot;127.0.0.1:9200&quot;      		//elasticsearch连接kibana的URL</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>启动服务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable kibana</span><br><span class="line">systemctl start kibana</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>es</category>
        <category>kibana</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装jdk</title>
    <url>/blog/2023/09/29/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85jdk/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li>下载安装包<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li>解压<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u131-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li>移动到&#x2F;usr&#x2F;local&#x2F;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv jdk1.8.0_131 /usr/local/</span><br></pre></td></tr></table></figure></li>
<li>配置环境变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>
最有一行增如如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_131</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
5.配置文件生效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
6.查看是否安装成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>jdk</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装minIO</title>
    <url>/blog/2023/10/05/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85minIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li><p>在home目录下创建minio文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/minio</span><br></pre></td></tr></table></figure></li>
<li><p>进入minio，下载文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://dl.min.io/server/minio/release/linux-amd64/minio</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>创建数据文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/minio/data</span><br></pre></td></tr></table></figure></li>
<li><p>创建日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/minio</span><br><span class="line">mkdir log</span><br><span class="line">cd log</span><br><span class="line">touch minio.log</span><br></pre></td></tr></table></figure></li>
<li><p>赋予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 minio</span><br><span class="line">或 </span><br><span class="line">chmod +x minio</span><br></pre></td></tr></table></figure></li>
<li><p>修改超管账号密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">export MINIO_ROOT_USER=minioadmin</span><br><span class="line">export MINIO_ROOT_PASSWORD=admin@123</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 前台启动命令</span><br><span class="line">./minio server /data/minio/data</span><br><span class="line"># 后台启动命令</span><br><span class="line">nohup ./minio server /data/minio/data &gt; /data/minio/log/minio.log &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将Minio设置成服务 配置Systemd服务启动</p>
</li>
</ol>
<p>1&gt; 创建minIO 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/default/minio.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对应minio的安装目录位置</span><br><span class="line">MINIO_VOLUMES=&quot;/data/minio/data&quot; </span><br><span class="line"># 注意这里的ip要改成你们自己的ip地址, 这里的ip特别注意，需要内网ip,否则服务起不来。固定端口号设置，避免重启后 端口号随机</span><br><span class="line">MINIO_OPTS=&quot;--address 0.0.0.0:9001 --console-address 0.0.0.0:9010 &quot;</span><br><span class="line"></span><br><span class="line"># 设置用户名和密码</span><br><span class="line">## 启动的时候看提示 新版本</span><br><span class="line">MINIO_ROOT_USER=root</span><br><span class="line">MINIO_ROOT_PASSWORD=admin@123 </span><br><span class="line"></span><br><span class="line"># 如果MinIO版本比较旧，修改用户名密码为</span><br><span class="line"># MINIO_ACCESS_KEY=username </span><br><span class="line"># MINIO_SECRET_KEY=password</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2&gt; 创建service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/minio.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Minio</span><br><span class="line">Documentation=https://docs.minio.io</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br><span class="line">#minio文件具体位置</span><br><span class="line">AssertFileIsExecutable=/usr/local/minio/minio</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/data/minio/data</span><br><span class="line"># User and group 用户/组</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">PermissionsStartOnly=true</span><br><span class="line"></span><br><span class="line">#创建的配置文件 minio.conf</span><br><span class="line">EnvironmentFile=/etc/default/minio.conf</span><br><span class="line"></span><br><span class="line">ExecStartPre=/bin/bash -c &quot;[ -n \&quot;$&#123;MINIO_VOLUMES&#125;\&quot; ] || echo \&quot;Variable MINIO_VOLUMES not set in /etc/default/minio\&quot;&quot;</span><br><span class="line"># $MINIO_OPTS $MINIO_VOLUMES  //这其实就是minio服务启动命令 /root/minio是服务位置 后面是端口号和数据存放目录</span><br><span class="line">ExecStart=/usr/local/minio/minio server $MINIO_OPTS $MINIO_VOLUMES</span><br><span class="line"></span><br><span class="line">## 如果不用/etc/default/minio 默认配置，通过--confit-dir 指定自定义conf。 /path/to/minio 可执行文件路径，/path/to/config替换为MinIO的配置文件路径。  </span><br><span class="line">## ExecStart=/path/to/minio server --config-dir=/path/to/config</span><br><span class="line"></span><br><span class="line">StandardOutput=journal</span><br><span class="line">StandardError=inherit</span><br><span class="line"></span><br><span class="line"># Specifies the maximum file descriptor number that can be opened by this process*</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line"># Disable timeout logic and wait until process is stopped*</span><br><span class="line">TimeoutStopSec=0</span><br><span class="line"></span><br><span class="line"># SIGTERM signal is used to stop Minio*</span><br><span class="line">KillSignal=SIGTERM</span><br><span class="line"></span><br><span class="line">SendSIGKILL=no</span><br><span class="line">SuccessExitStatus=0</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3&gt; 重新加载systemd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>4&gt; 开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable minio.service</span><br></pre></td></tr></table></figure>
<p>5&gt; 其他服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动服务</span><br><span class="line">systemctl start minio.service</span><br><span class="line">#停止服务</span><br><span class="line">systemctl stop minio.service</span><br><span class="line">#重启服务</span><br><span class="line">systemctl restrat minio.service</span><br><span class="line">#查看服务状态</span><br><span class="line">systemctl status minio.service</span><br></pre></td></tr></table></figure>
<h1 id="开放下载，设置永久访问链接"><a href="#开放下载，设置永久访问链接" class="headerlink" title="开放下载，设置永久访问链接"></a>开放下载，设置永久访问链接</h1><p>很多情况下，我们的图片是需要浏览器直接访问的，这里通过minio的客户端进行设置</p>
<p>1、下载客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://dl.minio.io/client/mc/release/linux-amd64/mc</span><br></pre></td></tr></table></figure>
<p>2、赋予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 mc</span><br></pre></td></tr></table></figure>
<p>3、添加server（注意自己的端口和账户名密码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mc config host add minio http://192.168.25.18:9001/ root admin@123</span><br></pre></td></tr></table></figure>
<p>4、设置需要开放下载的bucket, 注意需要带minio</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mc  anonymous  set  download  minio/dev</span><br></pre></td></tr></table></figure>
<p>5、访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.25.18:9001/dev/test/e94f512bgy1h9all19btxj20yi22o44l.jpg</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>MinIO</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装maven</title>
    <url>/blog/2023/10/04/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85maven/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li>maven环境安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载maven</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz</span><br><span class="line">解压</span><br><span class="line">tar -zxvf apache-maven-3.8.8-bin.tar.gz</span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"># maven</span><br><span class="line">export MAVEN_HOME=/usr/local/maven</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>maven</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装mongodb</title>
    <url>/blog/2023/09/29/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85mongodb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li><p>下载安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-rhel70-4.4.3.tgz                     # 解压</span><br><span class="line"></span><br><span class="line">mv mongodb-src-r4.4.3  /usr/local/mongodb                           # 将解压后的文件拷贝到指定目录</span><br></pre></td></tr></table></figure></li>
<li><p>编辑&#x2F;etc&#x2F;profile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/mongodb4/bin:$PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>source &#x2F;etc&#x2F;profile</p>
</li>
<li><p>创建数据和日志目录，并分配权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/lib/mongodb</span><br><span class="line">sudo mkdir -p /var/log/mongodb</span><br><span class="line">sudo chown `whoami` /var/lib/mongodb   # 设置权限</span><br><span class="line">sudo chown `whoami` /var/log/mongodb   # 设置权限</span><br></pre></td></tr></table></figure>
<p>chown <code>whoami</code>命令用来指定文件所有者为用户自身，whoami为显示自身名称的命令。</p>
</li>
<li><p>bin文件夹增加配置文件</p>
</li>
</ol>
<p>vi mongod.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#指定数据库路径</span><br><span class="line">dbpath=/var/lib/mongodb</span><br><span class="line">#指定MongoDB日志文件</span><br><span class="line">logpath=/var/log/mongodb/mongod.log</span><br><span class="line">#使用追加的方式写日志</span><br><span class="line">logappend=true</span><br><span class="line">#端口号</span><br><span class="line">port=27017</span><br><span class="line">#方便外网访问</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line"># 以守护进程的方式运行MongoDB，创建服务器进程</span><br><span class="line">fork=true </span><br><span class="line">#启用用户验证</span><br><span class="line">#auth=true</span><br><span class="line">#绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定则默认本地所有IP</span><br><span class="line">#bind_ip=0.0.0.0 </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动服务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongod -f mongod.confx</span><br></pre></td></tr></table></figure></li>
<li>看是否成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -10f /var/log/mongodb/mongod.log</span><br></pre></td></tr></table></figure></li>
<li>开机自启</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /lib/systemd/system/mongodb.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Mongodb Service</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/mongodb/bin/mongod --config /usr/local/mongodb/bin/mongod.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/usr/local/mongodb/bin/mongod --config /usr/local/mongodb/bin/mongod.conf --shutdown</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">#刷新配置(在启动前，必须先执行，否则报警告)</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">#启动服务</span><br><span class="line">systemctl start mongodb</span><br><span class="line"></span><br><span class="line">#关闭服务</span><br><span class="line">systemctl stop mongodb</span><br><span class="line"></span><br><span class="line">#服务加入开机自启</span><br><span class="line">systemctl enable  mongodb</span><br><span class="line"></span><br><span class="line">#查看状态</span><br><span class="line">systemctl status mongodb</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装mysql57</title>
    <url>/blog/2023/09/09/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85mysql57/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="1-检查是否有安装过mysql"><a href="#1-检查是否有安装过mysql" class="headerlink" title="1.检查是否有安装过mysql"></a>1.检查是否有安装过mysql</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>

<h1 id="2-如果有安装过则删除掉mysql的文件"><a href="#2-如果有安装过则删除掉mysql的文件" class="headerlink" title="2.如果有安装过则删除掉mysql的文件"></a>2.如果有安装过则删除掉mysql的文件</h1><blockquote>
<p>yum安装</p>
</blockquote>
<p>yum remove mysql mysql-server mysql-libs compat-mysql51</p>
<p>rm -rf &#x2F;var&#x2F;lib&#x2F;mysql</p>
<p>rm &#x2F;etc&#x2F;my.cnf</p>
<blockquote>
<p>rpm安装</p>
</blockquote>
<p>rpm -qa | grep mysql</p>
<p>使用rpm -e命令将上个命令中包列表全部删除</p>
<p>然后删除相关服务</p>
<p>chkconfig –list | grep -i mysql</p>
<p>chkconfig –del mysql</p>
<p>最后找出OS中分散的mysql文件夹，并删除</p>
<h1 id="3-下载mysql的repo源，"><a href="#3-下载mysql的repo源，" class="headerlink" title="3.下载mysql的repo源，"></a>3.下载mysql的repo源，</h1><p>wget <a href="http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm">http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm</a></p>
<p>【如果没有安装wget需要安装一下，yum -y install wget】</p>
<h1 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h1><p>yum -y install mysql57-community-release-el7-10.noarch.rpm</p>
<p>yum -y install mysql-community-server</p>
<p>安装mysql-community-server时提示公钥尚未安装</p>
<p>    方法一，运行这个命令：rpm –import <a href="https://repo.mysql.com/RPM-GPG-KEY-mysql-2022">https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</a></p>
<p>   方法二，修改文件：&#x2F;etc&#x2F;yum.repos.d&#x2F;mysql-community.repo，修改对应安装版本的gpgcheck&#x3D;0即可</p>
<h1 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5.启动服务"></a>5.启动服务</h1><p>启动mysql服务：systemctl start mysqld.service</p>
<p>查看是否启动mysql服务：systemctl status mysqld.service</p>
<h1 id="6-修改密码"><a href="#6-修改密码" class="headerlink" title="6.修改密码"></a>6.修改密码</h1><p>查看mysql初始密码：grep “password” &#x2F;var&#x2F;log&#x2F;mysqld.log</p>
<p>进入mysql：mysql -u root -p</p>
<p>修改密码：alter user user() identified by “newPassword”</p>
<p>    如果提示密码强度过低</p>
<p>        set global validate_password_policy&#x3D;0;  # 密码强度设为最低等级</p>
<p>        set global validate_password_length&#x3D;4;  # 密码允许最小长度为4，也可以是1</p>
<p>        flush privileges;  # 更新授权表，生效</p>
<h1 id="8-修改允许的连接人"><a href="#8-修改允许的连接人" class="headerlink" title="8.修改允许的连接人"></a>8.修改允许的连接人</h1><p>最后进入mysql配置远程访问权限（远程登录的用户名为root，密码为”root”）</p>
<p>控制台执行语句1： GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ IDENTIFIED BY ‘yourpassword’ WITH GRANT OPTION;</p>
<p>控制台执行语句2： FLUSH PRIVILEGES;</p>
<p>如果提示密码强度低</p>
<p>set global validate_password_policy&#x3D;0  # 密码强度设为最低等级</p>
<p>set global validate_password_length&#x3D;4  # 密码允许最小长度为4，也可以是1</p>
<p>flush privileges;  # 更新授权表，生效</p>
<h1 id="9-开机自启"><a href="#9-开机自启" class="headerlink" title="9.开机自启"></a>9.开机自启</h1><p>systemctl enable mysqld.service</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装mysql8</title>
    <url>/blog/2023/09/21/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85mysql8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="1-卸载mariadb"><a href="#1-卸载mariadb" class="headerlink" title="1.卸载mariadb"></a>1.卸载mariadb</h1><p>rpm -qa|grep mariadb</p>
<p>rpm -e –nodeps mariadb-libs-5.5.68-1.el7.x86_64</p>
<h1 id="2-wget下载mysql8"><a href="#2-wget下载mysql8" class="headerlink" title="2.wget下载mysql8"></a>2.wget下载mysql8</h1><p>wget <a href="https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz">https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz</a></p>
<h1 id="3-解压"><a href="#3-解压" class="headerlink" title="3.解压"></a>3.解压</h1><p>.tar.gz 后缀</p>
<p>tar -zxvf 文件名</p>
<p> .tar.xz 后缀</p>
<p>tar -Jxvf 文件名</p>
<h1 id="4-移动到-x2F-usr-x2F-local-x2F"><a href="#4-移动到-x2F-usr-x2F-local-x2F" class="headerlink" title="4.移动到&#x2F;usr&#x2F;local&#x2F;"></a>4.移动到&#x2F;usr&#x2F;local&#x2F;</h1><p>mv 文件名 &#x2F;usr&#x2F;local</p>
<h1 id="5-重命名"><a href="#5-重命名" class="headerlink" title="5.重命名"></a>5.重命名</h1><p>mv 原文件夹名 mysql8</p>
<h1 id="6-修改环境变量"><a href="#6-修改环境变量" class="headerlink" title="6.修改环境变量"></a>6.修改环境变量</h1><p>vi &#x2F;etc&#x2F;profile</p>
<p>export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql8&#x2F;bin</p>
<p>source &#x2F;etc&#x2F;profile</p>
<h1 id="7-确定安装成功"><a href="#7-确定安装成功" class="headerlink" title="7.确定安装成功"></a>7.确定安装成功</h1><p>mysql –version</p>
<h1 id="8-创建用户组、用户"><a href="#8-创建用户组、用户" class="headerlink" title="8.创建用户组、用户"></a>8.创建用户组、用户</h1><p>groupadd mysql</p>
<p>useradd -r -g mysql mysql</p>
<h1 id="9-创建数据目录"><a href="#9-创建数据目录" class="headerlink" title="9.创建数据目录"></a>9.创建数据目录</h1><p>mkdir -p &#x2F;data&#x2F;mysql8_data</p>
<h1 id="10-赋予权限"><a href="#10-赋予权限" class="headerlink" title="10.赋予权限"></a>10.赋予权限</h1><p>更改属主和数组</p>
<p>chown -R mysql:mysql &#x2F;data&#x2F;mysql8_data</p>
<p>更改模式</p>
<p>chmod -R 750 &#x2F;data&#x2F;mysql8_data</p>
<h1 id="11-创建配置文件"><a href="#11-创建配置文件" class="headerlink" title="11.创建配置文件"></a>11.创建配置文件</h1><p>touch &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf</p>
<h1 id="12-配置内容"><a href="#12-配置内容" class="headerlink" title="12.配置内容"></a>12.配置内容</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 默认字符集</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line">port       = 3306</span><br><span class="line">socket     = /tmp/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">port       = 3306</span><br><span class="line">server-id  = 3306</span><br><span class="line">user       = mysql</span><br><span class="line">socket     = /tmp/mysql.sock</span><br><span class="line"># 安装目录</span><br><span class="line">basedir    = /usr/local/mysql8</span><br><span class="line"># 数据存放目录</span><br><span class="line">datadir    = /data/mysql8_data/mysql</span><br><span class="line">log-bin    = /data/mysql8_data/mysql/mysql-bin</span><br><span class="line">innodb_data_home_dir      =/data/mysql8_data/mysql</span><br><span class="line">innodb_log_group_home_dir =/data/mysql8_data/mysql</span><br><span class="line"># 日志及进程数据的存放目录</span><br><span class="line">log-error =/data/mysql8_data/mysql/mysql.log</span><br><span class="line">pid-file  =/data/mysql8_data/mysql/mysql.pid</span><br><span class="line"># 服务端字符集</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">autocommit =1</span><br><span class="line">##### 以上涉及文件夹明，注意修改</span><br><span class="line">skip-external-locking</span><br><span class="line">key_buffer_size = 256M</span><br><span class="line">max_allowed_packet = 1M</span><br><span class="line">table_open_cache = 1024</span><br><span class="line">sort_buffer_size = 4M</span><br><span class="line">net_buffer_length = 8K</span><br><span class="line">read_buffer_size = 4M</span><br><span class="line">read_rnd_buffer_size = 512K</span><br><span class="line">myisam_sort_buffer_size = 64M</span><br><span class="line">thread_cache_size = 128</span><br><span class="line">#query_cache_size = 128M</span><br><span class="line">tmp_table_size = 128M</span><br><span class="line">explicit_defaults_for_timestamp = true</span><br><span class="line">max_connections = 500</span><br><span class="line">max_connect_errors = 100</span><br><span class="line">open_files_limit = 65535</span><br><span class="line">binlog_format=mixed</span><br><span class="line">binlog_expire_logs_seconds =864000</span><br><span class="line"># 创建表时使用的默认存储引擎</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">innodb_data_file_path = ibdata1:10M:autoextend</span><br><span class="line">innodb_buffer_pool_size = 1024M</span><br><span class="line">innodb_log_file_size = 256M</span><br><span class="line">innodb_log_buffer_size = 8M</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">innodb_lock_wait_timeout = 50</span><br><span class="line">transaction-isolation=READ-COMMITTED</span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">max_allowed_packet = 16M</span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size = 256M</span><br><span class="line">sort_buffer_size = 4M</span><br><span class="line">read_buffer = 2M</span><br><span class="line">write_buffer = 2M</span><br><span class="line">[mysqlhotcopy]</span><br><span class="line">interactive-timeout</span><br></pre></td></tr></table></figure>
<h1 id="13-初始化"><a href="#13-初始化" class="headerlink" title="13.初始化"></a>13.初始化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --defaults-file=/usr/local/etc/my.cnf --basedir=/usr/local/mysql8 --datadir=/data/mysql8_data/mysql --user=mysql --initialize-insecure</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>–defaults-file：指定配置文件（要放在–initialize 前面）</p>
<p>–user： 指定用户</p>
<p>–basedir：指定安装目录</p>
<p>–datadir：指定初始化数据目录</p>
<p>–intialize-insecure：初始化无密码（否则生成随机密码）</p>
<h1 id="14-启动-MySQL"><a href="#14-启动-MySQL" class="headerlink" title="14.启动 MySQL"></a>14.启动 MySQL</h1><p>查看 MySQL 的 &#x2F;bin 下是否包含 mysqld_safe</p>
<p>用于后台安全启动 MySQL</p>
<h1 id="15-启动服务"><a href="#15-启动服务" class="headerlink" title="15.启动服务"></a>15.启动服务</h1><p>mysqld_safe –defaults-file&#x3D;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf &amp;</p>
<p>ps -aux|grep mysql 查看启动的服务</p>
<h1 id="16-登录"><a href="#16-登录" class="headerlink" title="16.登录"></a>16.登录</h1><p>无密码：若以 –initialize-insecure 初始化，首次登录时跳过密码。</p>
<p>mysql -u root –skip-password</p>
<p>有密码：若初始化时设置了随机密码，在 &#x2F;data&#x2F;mysql8_data&#x2F;mysql&#x2F;mysql.log 查看</p>
<p>mysql -u root -p</p>
<h1 id="17-修改密码"><a href="#17-修改密码" class="headerlink" title="17.修改密码"></a>17.修改密码</h1><h2 id="首次修改"><a href="#首次修改" class="headerlink" title="首次修改"></a>首次修改</h2><p>MySQL 初始化的 root 用户、新创建的用户，都需要设置首次密码。</p>
<p>建议使用本地密码插件 mysql_native_password。</p>
<p>修改密码<br>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;</p>
<p>刷新权限<br>FLUSH PRIVILEGES;</p>
<h2 id="平时修改"><a href="#平时修改" class="headerlink" title="平时修改"></a>平时修改</h2><p>mysqladmin -u用户名 -p旧密码 password 新密码</p>
<p>或者</p>
<p>设置密码<br>SET PASSWORD FOR ‘用户名‘@’主机’ &#x3D; PASSWORD(‘密码’);<br>刷新权限<br>FLUSH PRIVILEGES;</p>
<h1 id="18-再次登录"><a href="#18-再次登录" class="headerlink" title="18.再次登录"></a>18.再次登录</h1><p>mysql -uroot -proot;</p>
<h1 id="19-远程连接-MySQL"><a href="#19-远程连接-MySQL" class="headerlink" title="19.远程连接 MySQL"></a>19.远程连接 MySQL</h1><p>选择 mysql 数据库，查看当前用户</p>
<p>USE mysql;</p>
<p>SELECT user,host,plugin,authentication_string FROM user;</p>
<p>host 字段 表示可访问当前数据库的主机，目前仅本地可访问。</p>
<p><img src="/blog/images/img/mysql8.png" alt="mysql8"></p>
<p>创建用户，任意远程访问</p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>CREATE user ‘root‘@’%’;</p>
<h2 id="设置首次密码"><a href="#设置首次密码" class="headerlink" title="设置首次密码"></a>设置首次密码</h2><p>ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘密码’;</p>
<h2 id="授权用户所有权限，刷新权限"><a href="#授权用户所有权限，刷新权限" class="headerlink" title="授权用户所有权限，刷新权限"></a>授权用户所有权限，刷新权限</h2><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’;<br>FLUSH PRIVILEGES;</p>
<h1 id="20-设置-mysql开机自启动"><a href="#20-设置-mysql开机自启动" class="headerlink" title="20.设置 mysql开机自启动"></a>20.设置 mysql开机自启动</h1><h2 id="在-x2F-etc-x2F-rc-d-x2F-init-d-x2F-编辑一个新文件autostartmysql-sh"><a href="#在-x2F-etc-x2F-rc-d-x2F-init-d-x2F-编辑一个新文件autostartmysql-sh" class="headerlink" title="在&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;编辑一个新文件autostartmysql.sh"></a>在&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;编辑一个新文件autostartmysql.sh</h2><p>cd &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;</p>
<p>vim .&#x2F;autostartmysql.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"> </span><br><span class="line"># chkconfig: 2345 10 90</span><br><span class="line"># description: myservice...</span><br><span class="line">/usr/local/mysql8/bin/mysqld_safe --defaults-file=/usr/local/etc/my.cnf &amp;</span><br></pre></td></tr></table></figure>

<h2 id="为autostartmysql-sh赋予权限"><a href="#为autostartmysql-sh赋予权限" class="headerlink" title="为autostartmysql.sh赋予权限"></a>为autostartmysql.sh赋予权限</h2><p>chmod +x .&#x2F;autostartmysql.sh</p>
<h2 id="将autostartmysql-sh添加到-chkconfig-中"><a href="#将autostartmysql-sh添加到-chkconfig-中" class="headerlink" title="将autostartmysql.sh添加到 chkconfig 中"></a>将autostartmysql.sh添加到 chkconfig 中</h2><p>chkconfig –add .&#x2F;autostartmysql.sh </p>
<p>chkconfig autostartmysql.sh on</p>
<p>查看是否添加成功</p>
<p>chkconfig –list</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>安装mysql8</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装nacos</title>
    <url>/blog/2023/09/29/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85nacos/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li><p>下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/alibaba/nacos/releases/download/2.2.3/nacos-server-2.2.3.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xf nacos-server-2.2.3.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>移动到&#x2F;usr&#x2F;local</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv nacos /usr/local/</span><br></pre></td></tr></table></figure></li>
<li><p>开机自启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/nacos.service</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Nacos Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/nacos/bin/startup.sh -m standalone</span><br><span class="line">ExecStop=/usr/local/nacos/bin/shutdown.sh</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改nacos的startup.sh<br><img src="/blog/images/img/nacos1.png" alt="nacos1"></p>
</li>
<li><p>重新加载服务的配置文件</p>
</li>
</ol>
<p>重新加载服务的配置文件 systemctl daemon-reload</p>
<p>设置开机启动systemctl enable nacos</p>
<p>启动服务 systemctl start nacos</p>
<p>查看服务状态 systemctl status nacos</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>nacos</category>
      </categories>
  </entry>
  <entry>
    <title>centos7替换yum源</title>
    <url>/blog/2023/09/21/%E5%B7%A5%E5%85%B7/centos7%E6%9B%BF%E6%8D%A2yum%E6%BA%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="1、yum源进行备份"><a href="#1、yum源进行备份" class="headerlink" title="1、yum源进行备份"></a>1、yum源进行备份</h1><p>[root@Server01 &#x2F;]# cd &#x2F;etc&#x2F;yum.repos.d</p>
<p>[root@Server01 &#x2F;]# mv Centos-Base.repo Centos-Base.repo.bak</p>
<h1 id="2、下载网上yum源"><a href="#2、下载网上yum源" class="headerlink" title="2、下载网上yum源"></a>2、下载网上yum源</h1><p>[root@server01&#x2F;]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></p>
<h1 id="3、清除缓存更新yum列表"><a href="#3、清除缓存更新yum列表" class="headerlink" title="3、清除缓存更新yum列表"></a>3、清除缓存更新yum列表</h1><p>[root@Server01 &#x2F;]# yum clean all</p>
<p>[root@Server01 &#x2F;]# yum makecache</p>
<p>[root@Server01 &#x2F;]# yum update</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装rocketmq</title>
    <url>/blog/2023/09/29/%E5%B7%A5%E5%85%B7/centos7%E5%AE%89%E8%A3%85rocketmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li><p>安装jdk</p>
</li>
<li><p>下载rocketmq</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.9.2-bin-release.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>移动到&#x2F;usr&#x2F;local</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv rocketmq-all-4.9.2-bin-release /usr/local/rocketmq</span><br></pre></td></tr></table></figure></li>
<li><p>配置占用内存大小及java依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi runbroker.sh </span><br></pre></td></tr></table></figure>
<p><img src="/blog/images/img/mq1.png" alt="mq1"></p>
</li>
</ol>
<p><img src="/blog/images/img/mq2.png" alt="mq2"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">配置broker.conf</span><br></pre></td></tr></table></figure>
<p>#允许自动创建topic<br>autoCreateTopicEnable&#x3D;true<br>#添加namesrv的地址<br>namesrvAddr&#x3D;localhost:9876</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">vi runserver.sh</span><br></pre></td></tr></table></figure>
<p><img src="/blog/images/img/mq3.png" alt="mq3"></p>
<p><img src="/blog/images/img/mq4.png" alt="mq4"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi tools.sh</span><br></pre></td></tr></table></figure>
<p><img src="/blog/images/img/mq5.png" alt="mq5"></p>
<p><img src="/blog/images/img/mq6.png" alt="mq6"></p>
<ol start="6">
<li>开机自启<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/rocketmqname.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=rocketmq-nameserver</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=sample</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/local/rocketmq/bin/mqnamesrv</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">Restart=0</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">vi /usr/lib/systemd/system/rocketmqbroker.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=rocketmq-broker</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=sample</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/local/rocketmq/bin/mqbroker -c /usr/local/rocketmq/conf/broker.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">Restart=0</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">systemctl start rocketmqname.service</span><br><span class="line">systemctl start rocketmqbroker.service</span><br><span class="line"> </span><br><span class="line">systemctl enable rocketmqname.service</span><br><span class="line">systemctl enable rocketmqbroker.service</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>生产者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export NAMESRV_ADDR=&#x27;localhost:9876&#x27;</span><br><span class="line">./tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>
<p>消费者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export NAMESRV_ADDR=&#x27;localhost:9876&#x27;</span><br><span class="line">./tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>


<h1 id="RocketMQ-Dashboard"><a href="#RocketMQ-Dashboard" class="headerlink" title="RocketMQ Dashboard"></a>RocketMQ Dashboard</h1><p>服务器得有maven环境</p>
<ol>
<li>下载RocketMQ Dashboard<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用git下载</span><br><span class="line"></span><br><span class="line">提示没有git的话，使用yum下载</span><br><span class="line"></span><br><span class="line">yum install -y git</span><br><span class="line"></span><br><span class="line">git clone https://github.com/apache/rocketmq-dashboard.git</span><br><span class="line"></span><br><span class="line">下载完后进入目录</span><br><span class="line"></span><br><span class="line">cd rocketmq-dashboard/</span><br><span class="line"></span><br><span class="line">vim src/main/resources/application.yml</span><br><span class="line"></span><br><span class="line">修改端口</span><br><span class="line"></span><br><span class="line">maven打包</span><br><span class="line"></span><br><span class="line">回到rocketmq-dashboard目录下</span><br><span class="line"></span><br><span class="line">mvn clean package -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line">显示BUILD SUCCESS即为打包成功</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line"></span><br><span class="line">nohup java -jar rocketmq-dashboard-1.0.1-SNAPSHOT.jar &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>编写启动，停止，重启脚本</li>
</ol>
<p>进入&#x2F;usr&#x2F;local&#x2F; 并创建文件夹rocketmq-dashboard</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">mkdir rocketmq-dashboard</span><br></pre></td></tr></table></figure>

<p>2.1 启动脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim rocketmq-dashboard-start.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 启动rocketmq dashboard</span><br><span class="line">cd /usr/local/rocketmq-dashboard/target</span><br><span class="line">if jps -ml | grep &quot;rocketmq-dashboard&quot;; then</span><br><span class="line">        echo &quot;rocketmq dashboard is running.&quot;;</span><br><span class="line">else</span><br><span class="line">        echo &quot;rocketmq dashboard is Starting ...&quot;;</span><br><span class="line">        rm -rf nohup.out;</span><br><span class="line">        nohup java -jar rocketmq-dashboard-1.0.1-SNAPSHOT.jar &amp; </span><br><span class="line">        count=0</span><br><span class="line">        while [ $count -le 10 ]; do</span><br><span class="line">          if tail -100 nohup.out | grep &quot;Tomcat started on port(s)&quot;; then</span><br><span class="line">                echo &quot;rocketmq dashboard has been started successfully&quot;;</span><br><span class="line">                break</span><br><span class="line">          else</span><br><span class="line">                count=$((count+1))</span><br><span class="line">                sleep 2</span><br><span class="line">          fi</span><br><span class="line">        done</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.2 停止脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim rocketmq-dashboard-stop.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line">APPLICATION=&quot;rocketmq-dashboard&quot;</span><br><span class="line"></span><br><span class="line"># 项目启动jar包名称</span><br><span class="line">APPLICATION_JAR=&quot;rocketmq-dashboard-1.0.1-SNAPSHOT.jar&quot;</span><br><span class="line"></span><br><span class="line">PID=$(ps -ef | grep $&#123;APPLICATION_JAR&#125; | grep -v grep | awk &#x27;&#123; print $2 &#125;&#x27;)</span><br><span class="line">if [ -z &quot;$PID&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo $&#123;APPLICATION&#125; is already stopped</span><br><span class="line">else</span><br><span class="line">    echo kill  $&#123;PID&#125;</span><br><span class="line">    kill -9 $&#123;PID&#125;</span><br><span class="line">    echo $&#123;APPLICATION&#125; stopped successfully</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.3 重启脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line">APPLICATION=&quot;rocketmq-dashboard&quot;</span><br><span class="line"></span><br><span class="line"># 停服</span><br><span class="line">echo stop $&#123;APPLICATION&#125; Application...</span><br><span class="line">sh rocketmq-dashboard-stop.sh</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line">echo start $&#123;APPLICATION&#125; Application...</span><br><span class="line">sh rocketmq-dashboard-start.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.4 赋予执行权力</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +755 rocketmq-dashboard-*</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>工具</category>
        <category>rocketmq</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA</title>
    <url>/blog/2023/06/01/%E5%B7%A5%E5%85%B7/idea/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote>
<p>智能的选取</p>
</blockquote>
<p>Ctrll+W</p>
<blockquote>
<p>丰富的导航模式,显示最近打开过的文件</p>
</blockquote>
<p>Ctrll+E</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/blog/2023/06/29/%E5%B7%A5%E5%85%B7/git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>git init </p>
<h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><p>git status</p>
<h1 id="提交到暂存区"><a href="#提交到暂存区" class="headerlink" title="提交到暂存区"></a>提交到暂存区</h1><p>git add [.|具体文件]</p>
<h1 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h1><p>git commit -m “提交信息”</p>
<h1 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h1><p>git log</p>
<h1 id="查看历史操作命令"><a href="#查看历史操作命令" class="headerlink" title="查看历史操作命令"></a>查看历史操作命令</h1><p>git reflog</p>
<h1 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h1><h2 id="回退上一个版本（-有几个就回退到之前的几个版本）"><a href="#回退上一个版本（-有几个就回退到之前的几个版本）" class="headerlink" title="回退上一个版本（^有几个就回退到之前的几个版本）"></a>回退上一个版本（^有几个就回退到之前的几个版本）</h2><p>git reset –hard HEAD^</p>
<h1 id="回退到具体版本"><a href="#回退到具体版本" class="headerlink" title="回退到具体版本"></a>回退到具体版本</h1><p>git reset –hard id </p>
<p>使用 git log 或者git reflog查看版本id（git reflog一般从过去</p>
<p>回到未来）</p>
<h1 id="提交暂缓区之前（git-add），撤销编辑的内容"><a href="#提交暂缓区之前（git-add），撤销编辑的内容" class="headerlink" title="提交暂缓区之前（git add），撤销编辑的内容"></a>提交暂缓区之前（git add），撤销编辑的内容</h1><p>git checkout – [文件]</p>
<p>注意：checkout后面有–，没有是切换分支</p>
<h1 id="提交暂缓区之后（git-add），撤销编辑的内容（此时编辑的内容撤销到工作区）"><a href="#提交暂缓区之后（git-add），撤销编辑的内容（此时编辑的内容撤销到工作区）" class="headerlink" title="提交暂缓区之后（git add），撤销编辑的内容（此时编辑的内容撤销到工作区）"></a>提交暂缓区之后（git add），撤销编辑的内容（此时编辑的内容撤销到工作区）</h1><p>git reset HEAD [文件]</p>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h2><p>git checkout -b [分支名称]</p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git checkout [分支名称]</p>
<p>切换分支还可以使用git switch -c [分支名称]</p>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>git merge [分支名称]</p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>git branch -d [分支名称]</p>
<h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，修改后保存</p>
<h1 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h1><p>git log –graph –pretty&#x3D;oneline –abbrev-commit</p>
<h1 id="暂存开发现场"><a href="#暂存开发现场" class="headerlink" title="暂存开发现场"></a>暂存开发现场</h1><p>针对当前分支开发而没有提交，需要去处理其他分支的情景，可以使用git stash 暂存开发现场。等解决完其他分支切回当前分支后执行git list查看当前stash记录。然后执行git stash pop还原当前分支开发现场（pop会还原后删除保存的记录，git stash apply则不会删除，删除需要手动执行git stash drop）。</p>
<h1 id="格式化提交时间线"><a href="#格式化提交时间线" class="headerlink" title="格式化提交时间线"></a>格式化提交时间线</h1><p>git rebase</p>
<h1 id="提交-gitignore文件中忽视的文件"><a href="#提交-gitignore文件中忽视的文件" class="headerlink" title="提交.gitignore文件中忽视的文件"></a>提交.gitignore文件中忽视的文件</h1><p>git rm -r –cached [文件夹]</p>
<h1 id="查看-x2F-修改账户密码邮箱"><a href="#查看-x2F-修改账户密码邮箱" class="headerlink" title="查看&#x2F;修改账户密码邮箱"></a>查看&#x2F;修改账户密码邮箱</h1><p>git config –list</p>
<p>git config –global user.name “账户”</p>
<p>git config –global user.password “密码”</p>
<p>git config –global user.email “邮箱”</p>
<h1 id="拉取远程"><a href="#拉取远程" class="headerlink" title="拉取远程"></a>拉取远程</h1><p>git pull origin</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>JDK动态代理和cglib动态代理</title>
    <url>/blog/2023/11/29/%E6%A1%88%E4%BE%8B/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>1、Jdk动态代理：利用拦截器（必须实现InvocationHandler接口）加上反射机制生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理</p>
<p>2、 Cglib动态代理：利用ASM框架，对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来进行代理</p>
<p>如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;</p>
<p>如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；</p>
<h2 id="Jdk动态代理"><a href="#Jdk动态代理" class="headerlink" title="Jdk动态代理"></a>Jdk动态代理</h2><p>UserService接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新用户信息&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserProxy代理类，实现InvocationHandler接口重写invoke方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserProxy</span> <span class="variable">userProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxy</span>(impl);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(impl.getClass().getClassLoader(),impl.getClass().getInterfaces(),userProxy);</span><br><span class="line">        userService.addUser();</span><br><span class="line">        userService.updateUser(<span class="string">&quot;：我是皮皮虾&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CGlib动态代理"><a href="#CGlib动态代理" class="headerlink" title="CGlib动态代理"></a>CGlib动态代理</h2><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>UserServiceImpl被代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserServiceCGlib代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceCGlib</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceCGlib</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceCGlib</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象:    是 target对象的代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建一个工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2. 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增强开始~~~&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;增强结束~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserServiceCGlib</span> <span class="variable">serviceCGlib</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceCGlib</span>(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> (UserServiceImpl)serviceCGlib.getProxyInstance();</span><br><span class="line">        userService.addUser();</span><br><span class="line">        System.out.println();</span><br><span class="line">        userService.deleteUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>案例</category>
        <category>动态代理</category>
      </categories>
  </entry>
  <entry>
    <title>Java内存泄漏排查思路</title>
    <url>/blog/2024/05/01/%E6%A1%88%E4%BE%8B/Java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>模拟堆内存溢出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            objects.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:<span class="number">265</span>)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">239</span>)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">231</span>)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:<span class="number">462</span>)</span><br><span class="line">	at com.example.thread.oom.MyOOM.main(MyOOM.java:<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>针对线上项目，是无法查看上面异常信息的，所以通过一下步骤来定位问题。</p>
<ol>
<li>获取堆内存快照dump。</li>
<li>VisualVM分析dump文件。</li>
<li>通过查看堆内存文件定位内存溢出问题。</li>
</ol>
<p>获取dump文件有2种方式。一种是使用jmap命令，一种是配置jvm参数。然而jmap只有在项目启动的时候使用，对于项目启动闪退或者过一段时间系统就退出的<br>情况jmap是无法使用的，所以采用配置jvm参数的方法。具体配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=E:\hprof</span><br></pre></td></tr></table></figure>

<p>针对参数配置的地方分为war和jar项目。war项目在tomcat中修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh。jar项目使用命令：nohup java -XX:<br>+HeadDumpOnOutOfMemoryError -XX:HeadDumpPath&#x3D;&#x2F;home&#x2F;app&#x2F;dumps&#x2F; -jar xxx.jar。</p>
<p>在idea编辑器中直接在add VM options选项中增加。</p>
<p>重新执行完上面main函数后，会在HeapDumpPath路径下生成一个hprof文件。用本地程序VisualVM打开这个文件就可以定位问题所在了。</p>
<p><img src="/blog/images/img/oom_visualVM.png" alt="oom_visualVM.png"></p>
]]></content>
      <categories>
        <category>案例</category>
        <category>java内存泄漏</category>
      </categories>
  </entry>
  <entry>
    <title>Java应用程序占用内存过高排查思路</title>
    <url>/blog/2024/05/01/%E6%A1%88%E4%BE%8B/Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li><p>使用top命令查看内存使用情况。</p>
</li>
<li><p>使用命令查看进程中线程使用的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep [进程id]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用jstack定位进程下线程占用情况。<br>上面进程和线程都是10进制的，jstack显示的线程id都是16进制。所以这里使用linux自带命令‘printf “%x\n” 线程id’转换线程id，然后就在jstack打印中找到对应的线程，在对应的线程中就能找到占用内存过高的具体代码位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>案例</category>
        <category>内存过高</category>
      </categories>
  </entry>
  <entry>
    <title>Map + Java8 函数式接口（解决大量if方法）</title>
    <url>/blog/2023/06/08/%E6%A1%88%E4%BE%8B/Map%20+%20Java8%20%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%EF%BC%88%E8%A7%A3%E5%86%B3%E5%A4%A7%E9%87%8Fif%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>需求：根据优惠券(资源)类型resourceType和编码resourceId查询派发方式grantType</p>
<p>使用策略设计模式没法俯视整个分派的业务逻辑</p>
<h1 id="Map-函数式接口"><a href="#Map-函数式接口" class="headerlink" title="Map+函数式接口"></a>Map+函数式接口</h1><p>用上了Java8的新特性lambda表达式</p>
<ul>
<li>判断条件放在key中</li>
<li>对应的业务逻辑放在value中</li>
</ul>
<p>这样子写的好处是非常直观，能直接看到判断条件对应的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryGrantTypeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">QueryGrantTypeService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GrantTypeSerive grantTypeSerive;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Function&lt;String,String&gt;&gt; grantTypeMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatcherInit</span><span class="params">()</span>&#123;</span><br><span class="line">        grantTypeMap.put(<span class="string">&quot;红包&quot;</span>,resourceId-&gt;grantTypeSerive.redPaper(resourceId));</span><br><span class="line">        grantTypeMap.put(<span class="string">&quot;购物券&quot;</span>,resourceId-&gt;grantTypeSerive.shopping(resourceId));</span><br><span class="line">        grantTypeMap.put(<span class="string">&quot;qq会员&quot;</span>,resourceId-&gt;grantTypeSerive.QQVip(resourceId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResult</span><span class="params">(String resourceType, String resourceId)</span> &#123;</span><br><span class="line">        <span class="comment">// Controller根据 优惠券类型resourceType、编码resourceId 去查询 发放方式grantType</span></span><br><span class="line">        Function&lt;String, String&gt; result = grantTypeMap.get(resourceType);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 传入 resourceId 执行这段表达式获得String型的grantType</span></span><br><span class="line">            <span class="keyword">return</span> result.apply(resourceId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询不到该优惠券的发放方式&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrantTypeSeriveImpl</span> <span class="keyword">implements</span> <span class="title class_">GrantTypeSerive</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redPaper</span><span class="params">(String resourceId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;每周末9点发放&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shopping</span><span class="params">(String resourceId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;每周三9点发放&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">QQVip</span><span class="params">(String resourceId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;每周一0点开始秒杀&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>案例</category>
        <category>java8函数式</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 的 delete、truncate、drop 有什么区别</title>
    <url>/blog/2023/07/05/%E6%A1%88%E4%BE%8B/MySQL%20%E7%9A%84%20delete%E3%80%81truncate%E3%80%81drop%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>MySQL删除数据的方式都有哪些？</p>
<p>咱们常用的三种删除方式：通过 delete、truncate、drop 关键字进行删除；这三种都可以用来删除数据，但场景不同。</p>
<h1 id="一、从执行速度上来说"><a href="#一、从执行速度上来说" class="headerlink" title="一、从执行速度上来说"></a>一、从执行速度上来说</h1><p>drop &gt; truncate &gt;&gt; DELETE</p>
<h1 id="二、从原理上讲"><a href="#二、从原理上讲" class="headerlink" title="二、从原理上讲"></a>二、从原理上讲</h1><h2 id="1、DELETE"><a href="#1、DELETE" class="headerlink" title="1、DELETE"></a>1、DELETE</h2><p>DELETE from TABLE_NAME where xxx<br>1、DELETE属于数据库DML操作语言，只删除数据不删除表的结构，会走事务，执行时会触发trigger；</p>
<p>2、在 InnoDB 中，DELETE其实并不会真的把数据删除，mysql 实际上只是给删除的数据打了个标记为已删除，因此 delete 删除表中的数据时，表文件在磁盘上所占空间不会变小，存储空间不会被释放，只是把删除的数据行设置为不可见。 虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以重用这部分空间（重用 → 覆盖）。</p>
<p>3、 DELETE执行时，会先将所删除数据缓存到rollback segement中，事务commit之后生效;</p>
<p>4、 delete from table_name删除表的全部数据,对于MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间;</p>
<p>5、对于delete from table_name where xxx 带条件的删除, 不管是InnoDB还是MyISAM都不会释放磁盘空间;</p>
<p>6、 delete操作以后使用 optimize table table_name 会立刻释放磁盘空间。不管是InnoDB还是MyISAM 。所以要想达到释放磁盘空间的目的，delete以后执行optimize table 操作。</p>
<p>示例：查看表占用硬盘空间大小的SQL语句如下：（用M做展示单位，数据库名：csjdemo，表名：demo2）</p>
<p>select concat(round(sum(DATA_LENGTH&#x2F;1024&#x2F;1024),2),’M’) as table_size<br>   from information_schema.tables<br>      where table_schema&#x3D;’csjdemo’ AND table_name&#x3D;’demo2’;</p>
<p>然后执行空间优化语句，以及执行后的表Size变化：</p>
<p>optimize table demo2</p>
<p>再看看这张表的大小，就只剩下表结构size了。</p>
<p>7、delete 操作是一行一行执行删除的，并且同时将该行的的删除操作日志记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，生成的大量日志也会占用磁盘空间。</p>
<h2 id="2、truncate"><a href="#2、truncate" class="headerlink" title="2、truncate"></a>2、truncate</h2><p>Truncate table TABLE_NAME</p>
<p>1、truncate：属于数据库DDL定义语言，不走事务，原数据不放到 rollback segment 中，操作不触发 trigger。</p>
<p>执行后立即生效，无法找回 执行后立即生效，无法找回 执行后立即生效，无法找回</p>
<p>2、 truncate table table_name 立刻释放磁盘空间 ，不管是 InnoDB和MyISAM 。truncate table其实有点类似于drop table 然后creat,只不过这个create table 的过程做了优化，比如表结构文件之前已经有了等等。所以速度上应该是接近drop table的速度;</p>
<p>3、truncate能够快速清空一个表。并且重置auto_increment的值。</p>
<p>但对于不同的类型存储引擎需要注意的地方是：</p>
<p>对于MyISAM，truncate会重置auto_increment（自增序列）的值为1。而delete后表仍然保持auto_increment。<br>对于InnoDB，truncate会重置auto_increment的值为1。delete后表仍然保持auto_increment。但是在做delete整个表之后重启MySQL的话，则重启后的auto_increment会被置为1。<br>也就是说，InnoDB的表本身是无法持久保存auto_increment。delete表之后auto_increment仍然保存在内存，但是重启后就丢失了，只能从1开始。实质上重启后的auto_increment会从 SELECT 1+MAX(ai_col) FROM t 开始。</p>
<p>4、 小心使用 truncate，尤其没有备份的时候，如果误删除线上的表。</p>
<h2 id="3、drop"><a href="#3、drop" class="headerlink" title="3、drop"></a>3、drop</h2><p>Drop table Tablename</p>
<p>1、drop：属于数据库DDL定义语言，同Truncate；</p>
<p>执行后立即生效，无法找回 执行后立即生效，无法找回 执行后立即生效，无法找回</p>
<p>2、 drop table table_name 立刻释放磁盘空间 ，不管是 InnoDB 和 MyISAM; drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index); 依赖于该表的存储过程&#x2F;函数将保留,但是变为 invalid 状态。</p>
<p>可以这么理解，一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了</p>
]]></content>
      <categories>
        <category>案例</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>springboot2 websoket在线聊天</title>
    <url>/blog/2023/06/05/%E6%A1%88%E4%BE%8B/springboot2%20websoket%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li><p>创建springboot项目,添加依赖及配置项目环境</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">servlet:</span></span><br><span class="line">      <span class="attr">content-type:</span> <span class="string">text/html</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启websocket服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写消息服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WsController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;socket open .&quot;</span>);</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        <span class="built_in">this</span>.broadcast(<span class="string">&quot;[用户&quot;</span> + session.getId() + <span class="string">&quot;]加入聊天室.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;size:&quot;</span> + sessions.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        <span class="built_in">this</span>.broadcast(<span class="string">&quot;[用户&quot;</span> + session.getId() + <span class="string">&quot;]退出聊天室.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;size:&quot;</span> + sessions.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(session.getId() + <span class="string">&quot; say &quot;</span> + message);</span><br><span class="line">        <span class="built_in">this</span>.broadcast(<span class="string">&quot;[用户&quot;</span> + session.getId() + <span class="string">&quot;]说：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable error)</span> &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        sessions.forEach(session -&gt; sendMessage(session, message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Session session, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session.getBasicRemote().sendText(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>添加页面访问控制器，前端渲染</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://code.jquery.com/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> webSocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      webSocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://127.0.0.1:9000/ws&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;webSocket not support&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    webSocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">show</span>(<span class="string">&quot;已连接&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    webSocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      $(<span class="string">&#x27;#message&#x27;</span>).<span class="title function_">append</span>(<span class="string">&#x27;&lt;div class=&quot;ms&quot;&gt;&#x27;</span> + event.<span class="property">data</span> + <span class="string">&#x27;&lt;/div&gt;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    webSocket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">show</span>(<span class="string">&quot;已关闭&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//连接发生错误的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    webSocket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">show</span>(<span class="string">&quot;连接错误&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">closeWebSocket</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      webSocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">innerHTML</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;status&#x27;</span>).<span class="property">innerHTML</span> = innerHTML;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> message = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ta&#x27;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">      webSocket.<span class="title function_">send</span>(message);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ta&#x27;</span>).<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      webSocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding: 20px&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;status&quot;</span>&gt;</span></span><br><span class="line">    连接状态：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span>&gt;</span>未连接<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;closeWebSocket()&quot;</span>&gt;</span>关闭连接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;min-height: 200px; margin: 20px 0 10px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ta&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;60&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send()&quot;</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动项目</p>
</li>
</ol>
]]></content>
      <categories>
        <category>案例</category>
        <category>websocket</category>
        <category>springboot2</category>
      </categories>
  </entry>
  <entry>
    <title>运用策略设计模式解决if-else太多</title>
    <url>/blog/2023/06/03/%E6%A1%88%E4%BE%8B/%E8%BF%90%E7%94%A8%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3if-else%E5%A4%AA%E5%A4%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="代码中if-else太多，代码难于维护和不太优雅，那怎么重构和优化？"><a href="#代码中if-else太多，代码难于维护和不太优雅，那怎么重构和优化？" class="headerlink" title="代码中if else太多，代码难于维护和不太优雅，那怎么重构和优化？"></a>代码中if else太多，代码难于维护和不太优雅，那怎么重构和优化？</h1><p>假设有一个订单系统，里面的一个功能是根据订单的不同类型作出不同的处理。</p>
<p>前置知识：</p>
<p>使用策略设计模式（定义：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户）。<br>java实现：抽取一个抽象类，然后根据类型指定不同的实现类执行方法。</p>
<ol>
<li>定义抽象处理类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(OrderDto orderDto)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>各个业务继承抽象类，重写方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(OrderDto dto)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;处理团购订单&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        EventServiceFactory.register(<span class="string">&quot;101&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(OrderDto dto)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;处理普通订单&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        EventServiceFactory.register(<span class="string">&quot;102&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PromotionHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(OrderDto dto)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;处理促销订单&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        EventServiceFactory.register(<span class="string">&quot;103&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义一个简单工厂<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventServiceFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 存放策略实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, AbstractHandler&gt; EVENT_SERVICE_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过类型找service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AbstractHandler <span class="title function_">getHandler</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EVENT_SERVICE_MAP.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将EventService 的实现类放到map中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String type,AbstractHandler eventService)</span>&#123;</span><br><span class="line">        EVENT_SERVICE_MAP.put(type,eventService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>业务操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据订单类型不同处理不同的处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderDto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">handle</span><span class="params">(OrderDto orderDto)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    /**</span></span><br><span class="line"><span class="comment">//     * 传统模式实现</span></span><br><span class="line"><span class="comment">//     * @param orderDto</span></span><br><span class="line"><span class="comment">//     * @return</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String handle(OrderDto orderDto) &#123;</span></span><br><span class="line"><span class="comment">//        if (&quot;1&quot;.equals(orderDto.getType())) &#123;</span></span><br><span class="line"><span class="comment">//            return &quot;普通订单&quot;;</span></span><br><span class="line"><span class="comment">//        &#125; else if (&quot;2&quot;.equals(orderDto.getType())) &#123;</span></span><br><span class="line"><span class="comment">//            return &quot;团购订单&quot;;</span></span><br><span class="line"><span class="comment">//        &#125; else if (&quot;3&quot;.equals(orderDto.getType())) &#123;</span></span><br><span class="line"><span class="comment">//            return &quot;促销订单&quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略模式实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderDto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(OrderDto orderDto)</span> &#123;</span><br><span class="line">        <span class="type">AbstractHandler</span> <span class="variable">eventService</span> <span class="operator">=</span> EventServiceFactory.getHandler(orderDto.getType());</span><br><span class="line">        <span class="keyword">return</span> eventService.handle(orderDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端调用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/modify&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultDto <span class="title function_">modify</span><span class="params">(<span class="meta">@RequestBody</span> OrderDto orderDto)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">handle</span> <span class="operator">=</span> orderService.handle(orderDto);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(handle)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResultDto.succ(handle);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResultDto.fail(<span class="string">&quot;更新失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>案例</category>
        <category>设计模式</category>
        <category>策略设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>springboot如何优雅的写controller</title>
    <url>/blog/2023/06/28/%E6%A1%88%E4%BE%8B/springboot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%86%99controller/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>前言</p>
<p>本篇主要要介绍的就是 controller 层的处理，一个完整的后端请求由 4 部分组成：</p>
<p>接口地址（也就是 URL 地址）<br>请求方式（一般就是 get、set，当然还有 put、delete）<br>请求数据（request，有 head 跟 body）<br>响应数据（response）<br>本篇将解决以下 3 个问题：</p>
<p>当接收到请求时，如何优雅的校验参数<br>返回响应数据该如何统一的进行处理<br>接收到请求，处理业务逻辑时抛出了异常又该如何处理</p>
<h1 id="Controller-层参数接收（太基础了，可以跳过）"><a href="#Controller-层参数接收（太基础了，可以跳过）" class="headerlink" title="Controller 层参数接收（太基础了，可以跳过）"></a>Controller 层参数接收（太基础了，可以跳过）</h1><p>常见的请求就分为 get 跟 post 两种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/product/product-info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductInfoController</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProductInfoService productInfoService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ProductInfoQueryVo <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IPage <span class="title function_">findPage</span><span class="params">(Page page, ProductInfoQueryVo vo)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RestController：</strong> @RestController&#x3D;@Controller+ResponseBody。</p>
<p>加上这个注解，Springboot 就会把这个类当成 controller 进行处理，然后把所有返回的参数放到 ResponseBody 中。</p>
<p><strong>@RequestMapping：</strong> 请求的前缀，也就是所有该 Controller 下的请求都需要加上 &#x2F;product&#x2F;product-info 的前缀。</p>
<p><strong>@GetMapping(“&#x2F;findById”)：</strong> 标志这是一个 get 请求，并且需要通过 &#x2F;findById 地址才可以访问到。</p>
<p><strong>@PostMapping(“&#x2F;page”)：</strong> 同理，表示是个 post 请求。</p>
<p>参数：至于参数部分，只需要写上 ProductInfoQueryVo，前端过来的 json 请求便会通过映射赋值到对应的对象中，例如请求这么写，productId 就会自动被映射到 vo 对应的属性当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size : 1</span><br><span class="line">current : 1</span><br><span class="line"> </span><br><span class="line">productId : 1</span><br><span class="line">productName : 泡脚</span><br></pre></td></tr></table></figure>
<h1 id="统一状态码"><a href="#统一状态码" class="headerlink" title="统一状态码"></a>统一状态码</h1><h2 id="返回格式"><a href="#返回格式" class="headerlink" title="返回格式"></a>返回格式</h2><p>为了跟前端妹妹打好关系，我们通常需要对后端返回的数据进行包装一下，增加一下状态码，状态信息，这样前端妹妹接收到数据就可以根据不同的状态码，判断响应数据状态，是否成功是否异常进行不同的显示。</p>
<p>当然这让你拥有了更多跟前端妹妹的交流机会，假设我们约定了 1000 就是成功的意思。</p>
<p>如果你不封装，那么返回的数据是这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;productId&quot;: 1,</span><br><span class="line">  &quot;productName&quot;: &quot;泡脚&quot;,</span><br><span class="line">  &quot;productPrice&quot;: 100.00,</span><br><span class="line">  &quot;productDescription&quot;: &quot;中药泡脚加按摩&quot;,</span><br><span class="line">  &quot;productStatus&quot;: 0,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过封装以后时这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 1000,</span><br><span class="line">  &quot;msg&quot;: &quot;请求成功&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;productId&quot;: 1,</span><br><span class="line">    &quot;productName&quot;: &quot;泡脚&quot;,</span><br><span class="line">    &quot;productPrice&quot;: 100.00,</span><br><span class="line">    &quot;productDescription&quot;: &quot;中药泡脚加按摩&quot;,</span><br><span class="line">    &quot;productStatus&quot;: 0,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="封装-ResultVo"><a href="#封装-ResultVo" class="headerlink" title="封装 ResultVo"></a>封装 ResultVo</h1><p>这些状态码肯定都是要预先编好的，怎么编呢？写个常量 1000？还是直接写死 1000？</p>
<p>要这么写就真的书白读的了，写状态码当然是用枚举拉：</p>
<p>① 首先先定义一个状态码的接口，所有状态码都需要实现它，有了标准才好做事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StatusCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 然后去找前端妹妹，跟他约定好状态码（这可能是你们唯一的约定了）枚举类嘛，当然不能有 setter 方法了，因此我们不能在用 @Data 注解了，我们要用 @Getter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCode</span> <span class="keyword">implements</span> <span class="title class_">StatusCode</span>&#123;</span><br><span class="line">    SUCCESS(<span class="number">1000</span>, <span class="string">&quot;请求成功&quot;</span>),</span><br><span class="line">    FAILED(<span class="number">1001</span>, <span class="string">&quot;请求失败&quot;</span>),</span><br><span class="line">    VALIDATE_ERROR(<span class="number">1002</span>, <span class="string">&quot;参数校验失败&quot;</span>),</span><br><span class="line">    RESPONSE_PACK_ERROR(<span class="number">1003</span>, <span class="string">&quot;response返回包装失败&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"> </span><br><span class="line">    ResultCode(<span class="type">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ 写好枚举类，就开始写 ResultVo 包装类了，我们预设了几种默认的方法，比如成功的话就默认传入 object 就可以了，我们自动包装成 success。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultVo</span> &#123;</span><br><span class="line">    <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 状态信息</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 手动设置返回vo</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultVo</span><span class="params">(<span class="type">int</span> code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 默认返回成功状态码，数据对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultVo</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = ResultCode.SUCCESS.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = ResultCode.SUCCESS.getMsg();</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回指定状态码，数据对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultVo</span><span class="params">(StatusCode statusCode, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = statusCode.getMsg();</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 只返回状态码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultVo</span><span class="params">(StatusCode statusCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = statusCode.getMsg();</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用，现在的返回肯定就不是 return data；这么简单了，而是需要 new ResultVo(data)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/findByVo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResultVo <span class="title function_">findByVo</span><span class="params">(<span class="meta">@Validated</span> ProductInfoVo vo)</span> &#123;</span><br><span class="line">  <span class="type">ProductInfo</span> <span class="variable">productInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductInfo</span>();</span><br><span class="line">  BeanUtils.copyProperties(vo, productInfo);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(productInfoService.getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>(productInfo)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回就会是上面带了状态码的数据了。</p>
<h1 id="统一校验"><a href="#统一校验" class="headerlink" title="统一校验"></a>统一校验</h1><h2 id="原始做法"><a href="#原始做法" class="headerlink" title="原始做法"></a>原始做法</h2><p>假设有一个添加 ProductInfo 的接口，在没有统一校验时，我们需要这么做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductInfoVo</span> &#123;</span><br><span class="line">    <span class="comment">// 商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="comment">// 商品价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal productPrice;</span><br><span class="line">    <span class="comment">// 上架状态</span></span><br><span class="line">    <span class="keyword">private</span> Integer productStatus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/findByVo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ProductInfo <span class="title function_">findByVo</span><span class="params">(ProductInfoVo vo)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isNotBlank(vo.getProductName())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">APIException</span>(<span class="string">&quot;商品名称不能为空&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> != vo.getProductPrice() &amp;&amp; vo.getProductPrice().compareTo(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">APIException</span>(<span class="string">&quot;商品价格不能为负数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  <span class="type">ProductInfo</span> <span class="variable">productInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductInfo</span>();</span><br><span class="line">  BeanUtils.copyProperties(vo, productInfo); <span class="comment">// 性能较差，不推荐使用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(productInfoService.getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>(productInfo)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这 if 写的人都傻了，能忍吗？肯定不能忍啊。</p>
<h1 id="Validated-参数校验"><a href="#Validated-参数校验" class="headerlink" title="@Validated 参数校验"></a>@Validated 参数校验</h1><p>好在有 @Validated，又是一个校验参数必备良药了。有了 @Validated 我们只需要再 vo 上面加一点小小的注解，便可以完成校验功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductInfoVo</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;商品名称不允许为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Min(value = 0, message = &quot;商品价格不允许为负数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal productPrice;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer productStatus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/findByVo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ProductInfo <span class="title function_">findByVo</span><span class="params">(<span class="meta">@Validated</span> ProductInfoVo vo)</span> &#123;</span><br><span class="line">  <span class="type">ProductInfo</span> <span class="variable">productInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductInfo</span>();</span><br><span class="line">  BeanUtils.copyProperties(vo, productInfo);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(productInfoService.getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>(productInfo)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行看看，如果参数不对会发生什么？</p>
<p>我们故意传一个价格为 -1 的参数过去：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">productName <span class="punctuation">:</span> 泡脚</span><br><span class="line">productPrice <span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line">productStatus <span class="punctuation">:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2020-04-19T03:06:37.268+0000&quot;,</span><br><span class="line">  &quot;status&quot;: 400,</span><br><span class="line">  &quot;error&quot;: &quot;Bad Request&quot;,</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;codes&quot;: [</span><br><span class="line">        &quot;Min.productInfoVo.productPrice&quot;,</span><br><span class="line">        &quot;Min.productPrice&quot;,</span><br><span class="line">        &quot;Min.java.math.BigDecimal&quot;,</span><br><span class="line">        &quot;Min&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;arguments&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;codes&quot;: [</span><br><span class="line">            &quot;productInfoVo.productPrice&quot;,</span><br><span class="line">            &quot;productPrice&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;defaultMessage&quot;: &quot;productPrice&quot;,</span><br><span class="line">          &quot;code&quot;: &quot;productPrice&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        0</span><br><span class="line">      ],</span><br><span class="line">      &quot;defaultMessage&quot;: &quot;商品价格不允许为负数&quot;,</span><br><span class="line">      &quot;objectName&quot;: &quot;productInfoVo&quot;,</span><br><span class="line">      &quot;field&quot;: &quot;productPrice&quot;,</span><br><span class="line">      &quot;rejectedValue&quot;: -1,</span><br><span class="line">      &quot;bindingFailure&quot;: false,</span><br><span class="line">      &quot;code&quot;: &quot;Min&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;message&quot;: &quot;Validation failed for object\u003d\u0027productInfoVo\u0027. Error count: 1&quot;,</span><br><span class="line">  &quot;trace&quot;: &quot;org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors\nField error in object \u0027productInfoVo\u0027 on field \u0027productPrice\u0027: rejected value [-1]; ......&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;/leilema/product/product-info/findByVo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成了吗？虽然成功校验了参数，也返回了异常，并且带上”商品价格不允许为负数”的信息。</p>
<p>但是你要是这样返回给前端，前端妹妹就提刀过来了，当年约定好的状态码，你个负心人说忘就忘？</p>
<p>用户体验小于等于 0 啊！所以我们要进行优化一下，每次出现异常的时候，自动把状态码写好，不负妹妹之约！</p>
<p>优化异常处理<br>首先我们先看看校验参数抛出了什么异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: <span class="number">1</span> errors</span><br></pre></td></tr></table></figure>
<p>我们看到代码抛出了 org.springframework.validation.BindException 的绑定异常，因此我们的思路就是 AOP 拦截所有 controller，然后异常的时候统一拦截起来，进行封装！完美！</p>
<p>完你个头啊完美，这么呆瓜的操作 Springboot 不知道吗？Spring mvc 当然知道拉，所以给我们提供了一个 @RestControllerAdvice 来增强所有 @RestController，然后使用@ExceptionHandler 注解，就可以拦截到对应的异常。</p>
<p>这里我们就拦截 BindException.class 就好了。最后在返回之前，我们对异常信息进行包装一下，包装成 ResultVo，当然要跟上 ResultCode.VALIDATE_ERROR 的异常状态码。</p>
<p>这样前端妹妹看到 VALIDATE_ERROR 的状态码，就会调用数据校验异常的弹窗提示用户哪里没填好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerExceptionAdvice</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;BindException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultVo <span class="title function_">MethodArgumentNotValidExceptionHandler</span><span class="params">(BindException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 从异常对象中拿到ObjectError对象</span></span><br><span class="line">        <span class="type">ObjectError</span> <span class="variable">objectError</span> <span class="operator">=</span> e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(ResultCode.VALIDATE_ERROR, objectError.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看效果，完美。1002 与前端妹妹约定好的状态码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 1002,</span><br><span class="line">  &quot;msg&quot;: &quot;参数校验失败&quot;,</span><br><span class="line">  &quot;data&quot;: &quot;商品价格不允许为负数&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="统一响应"><a href="#统一响应" class="headerlink" title="统一响应"></a>统一响应</h1><h2 id="统一包装响应"><a href="#统一包装响应" class="headerlink" title="统一包装响应"></a>统一包装响应</h2><p>再回头看一下 controller 层的返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(productInfoService.getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>(productInfo)));</span><br></pre></td></tr></table></figure>
<p>开发小哥肯定不乐意了，谁有空天天写 new ResultVo(data) 啊，我就想返回一个实体！怎么实现我不管！</p>
<p>好把，那就是 AOP 拦截所有 Controller，再 @After 的时候统一帮你封装一下咯。</p>
<p>怕是上一次脸打的不够疼，Springboot 能不知道这么个操作吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &#123;&quot;com.bugpool.leilema&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerResponseAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> &#123;</span><br><span class="line">        <span class="comment">// response是ResultVo类型，或者注释了NotControllerResponseAdvice都不进行包装</span></span><br><span class="line">        <span class="keyword">return</span> !methodParameter.getParameterType().isAssignableFrom(ResultVo.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object data, MethodParameter returnType, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// String类型不能直接包装</span></span><br><span class="line">        <span class="keyword">if</span> (returnType.getGenericParameterType().equals(String.class)) &#123;</span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将数据包装在ResultVo里后转换为json串进行返回</span></span><br><span class="line">                <span class="keyword">return</span> objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">ResultVo</span>(data));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">APIException</span>(ResultCode.RESPONSE_PACK_ERROR, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则直接包装成ResultVo返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>① @RestControllerAdvice(basePackages &#x3D; {“com.bugpool.leilema”}) 自动扫描了所有指定包下的 controller，在 Response 时进行统一处理。</p>
<p>② 重写 supports 方法，也就是说，当返回类型已经是 ResultVo 了，那就不需要封装了，当不等与 ResultVo 时才进行调用 beforeBodyWrite 方法，跟过滤器的效果是一样的。</p>
<p>③ 最后重写我们的封装方法 beforeBodyWrite，注意除了 String 的返回值有点特殊，无法直接封装成 json，我们需要进行特殊处理，其他的直接 new ResultVo(data); 就 ok 了。</p>
<p>打完收工，看看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/findByVo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ProductInfo <span class="title function_">findByVo</span><span class="params">(<span class="meta">@Validated</span> ProductInfoVo vo)</span> &#123;</span><br><span class="line">  <span class="type">ProductInfo</span> <span class="variable">productInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductInfo</span>();</span><br><span class="line">  BeanUtils.copyProperties(vo, productInfo);</span><br><span class="line">  <span class="keyword">return</span> productInfoService.getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>(productInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时就算我们返回的是 po，接收到的返回就是标准格式了，开发小哥露出了欣慰的笑容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 1000,</span><br><span class="line">  &quot;msg&quot;: &quot;请求成功&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;productId&quot;: 1,</span><br><span class="line">    &quot;productName&quot;: &quot;泡脚&quot;,</span><br><span class="line">    &quot;productPrice&quot;: 100.00,</span><br><span class="line">    &quot;productDescription&quot;: &quot;中药泡脚加按摩&quot;,</span><br><span class="line">    &quot;productStatus&quot;: 0,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NOT-统一响应"><a href="#NOT-统一响应" class="headerlink" title="NOT 统一响应"></a>NOT 统一响应</h1><p>不开启统一响应原因： 开发小哥是开心了，可是其他系统就不开心了。举个例子：我们项目中集成了一个健康检测的功能，也就是这货。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HealthController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/health&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公司部署了一套校验所有系统存活状态的工具，这工具就定时发送 get 请求给我们系统：</p>
<p>“兄弟，你死了吗？”<br>“我没死，滚”<br>“兄弟，你死了吗？”<br>“我没死，滚”</p>
<p>是的，web 项目的本质就是复读机。一旦发送的请求没响应，就会给负责人发信息（企业微信或者短信之类的），你的系统死啦！赶紧回来排查 bug 吧！</p>
<p>让大家感受一下。每次看到我都射射发抖，早上 6 点！我 tm！！！！！</p>
<p>好吧，没办法，人家是老大，人家要的返回不是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 1000,</span><br><span class="line">  &quot;msg&quot;: &quot;请求成功&quot;,</span><br><span class="line">  &quot;data&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>人家要的返回只要一个 success，人家定的标准不可能因为你一个系统改。俗话说的好，如果你改变不了环境，那你就只能我****</p>
<p>新增不进行封装注解: 因为99%的请求还是需要包装的，只有个别不需要，写在包装的过滤器吧？又不是很好维护，那就加个注解好了。所有不需要包装的就加上这个注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotControllerResponseAdvice &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在我们的增强过滤方法上过滤包含这个注解的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &#123;&quot;com.bugpool.leilema&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerResponseAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> &#123;</span><br><span class="line">        <span class="comment">// response是ResultVo类型，或者注释了NotControllerResponseAdvice都不进行包装</span></span><br><span class="line">        <span class="keyword">return</span> !(methodParameter.getParameterType().isAssignableFrom(ResultVo.class)</span><br><span class="line">                || methodParameter.hasMethodAnnotation(NotControllerResponseAdvice.class));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>最后就在不需要包装的方法上加上注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HealthController</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/health&quot;)</span></span><br><span class="line">    <span class="meta">@NotControllerResponseAdvice</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就不会自动封装了，而其他没加注解的则依旧自动包装：</p>
<p>统一异常<br>每个系统都会有自己的业务异常，比如库存不能小于 0 子类的，这种异常并非程序异常，而是业务操作引发的异常，我们也需要进行规范的编排业务异常状态码，并且写一个专门处理的异常类，最后通过刚刚学习过的异常拦截统一进行处理，以及打日志.</p>
<p>① 异常状态码枚举，既然是状态码，那就肯定要实现我们的标准接口 StatusCode。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">AppCode</span> <span class="keyword">implements</span> <span class="title class_">StatusCode</span> &#123;</span><br><span class="line"> </span><br><span class="line">    APP_ERROR(<span class="number">2000</span>, <span class="string">&quot;业务异常&quot;</span>),</span><br><span class="line">    PRICE_ERROR(<span class="number">2001</span>, <span class="string">&quot;价格异常&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"> </span><br><span class="line">    AppCode(<span class="type">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 异常类，这里需要强调一下，code 代表 AppCode 的异常状态码，也就是 2000；msg 代表业务异常，这只是一个大类，一般前端会放到弹窗 title 上；最后 super(message); 这才是抛出的详细信息，在前端显示在弹窗体中，在 ResultVo 则保存在 data 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APIException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 手动设置异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">APIException</span><span class="params">(StatusCode statusCode, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// message用于用户设置抛出错误详情，例如：当前价格-5，小于0</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="comment">// 状态码</span></span><br><span class="line">        <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">        <span class="comment">// 状态码配套的msg</span></span><br><span class="line">        <span class="built_in">this</span>.msg = statusCode.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 默认异常使用APP_ERROR状态码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">APIException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = AppCode.APP_ERROR.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = AppCode.APP_ERROR.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 最后进行统一异常的拦截，这样无论在 service 层还是 controller 层，开发人员只管抛出 API 异常，不需要关系怎么返回给前端，更不需要关心日志的打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerExceptionAdvice</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;BindException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultVo <span class="title function_">MethodArgumentNotValidExceptionHandler</span><span class="params">(BindException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 从异常对象中拿到ObjectError对象</span></span><br><span class="line">        <span class="type">ObjectError</span> <span class="variable">objectError</span> <span class="operator">=</span> e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(ResultCode.VALIDATE_ERROR, objectError.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ExceptionHandler(APIException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultVo <span class="title function_">APIExceptionHandler</span><span class="params">(APIException e)</span> &#123;</span><br><span class="line">        <span class="comment">// log.error(e.getMessage(), e); 由于还没集成日志框架，暂且放着，写上TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultVo</span>(e.getCode(), e.getMsg(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④ 最后使用，我们的代码只需要这么写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == orderMaster) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">APIException</span>(AppCode.ORDER_NOT_EXIST, <span class="string">&quot;订单号不存在：&quot;</span> + orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 2003,</span><br><span class="line">  &quot;msg&quot;: &quot;订单不存在&quot;,</span><br><span class="line">  &quot;data&quot;: &quot;订单号不存在：1998&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会自动抛出 AppCode.ORDER_NOT_EXIST 状态码的响应，并且带上异常详细信息订单号不存在：xxxx。</p>
]]></content>
      <categories>
        <category>实例</category>
        <category>springboot</category>
        <category>controller</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式简介</title>
    <url>/blog/2024/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<h1 id="什么是-GOF（四人帮，全拼-Gang-of-Four）？"><a href="#什么是-GOF（四人帮，全拼-Gang-of-Four）？" class="headerlink" title="什么是 GOF（四人帮，全拼 Gang of Four）？"></a>什么是 GOF（四人帮，全拼 Gang of Four）？</h1><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。</p>
<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
<h1 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h1><p>设计模式在软件开发中的两个主要用途。</p>
<h2 id="开发人员的共同平台"><a href="#开发人员的共同平台" class="headerlink" title="开发人员的共同平台"></a>开发人员的共同平台</h2><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p>
<h2 id="最佳的实践"><a href="#最佳的实践" class="headerlink" title="最佳的实践"></a>最佳的实践</h2><p>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p>
<h1 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h1><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。</p>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。</p>
<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
<h1 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h1><ul>
<li>提供了一种共享的设计词汇和概念，使开发人员能够更好地沟通和理解彼此的设计意图。</li>
<li>提供了经过验证的解决方案，可以提高软件的可维护性、可复用性和灵活性。</li>
<li>促进了代码的重用，避免了重复的设计和实现。</li>
<li>通过遵循设计模式，可以减少系统中的错误和问题，提高代码质量。</li>
</ul>
<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><p>1、开闭原则（Open Close Principle）</p>
<p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p>2、里氏代换原则（Liskov Substitution Principle）</p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>3、依赖倒转原则（Dependence Inversion Principle）</p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、接口隔离原则（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p>5、迪米特法则，又称最少知道原则（Demeter Principle）</p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、合成复用原则（Composite Reuse Principle）</p>
<p>合成复用原则是指：尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树遍历方式</title>
    <url>/blog/2023/04/20/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>二叉树遍历方式有：前序遍历，中序遍历，后续遍历。所有的遍历都是以根节点作为参照。比如前序遍历：根左右</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/blog/2023/06/01/%E8%AF%AD%E8%A8%80/java/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>数据精度损失<br><em>范围小的数据类型存储大的数据会有精度损失。原理: 大的数据会被截取，存储到小的数据类型中,<br>而计算机中存储的是数据的补码，补码会被转成原码</em></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始数据：00000000 00000000 0000000 10000000</span><br><span class="line">// 强转后：10000000</span><br><span class="line">// 强转后的数据减一，取反，加上符号位就是原码（-128）</span><br><span class="line">byte b = (byte)128 // -128</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ol>
<li>synchronized(this)和synchronized(class)的区别</li>
</ol>
<p>只要采用类锁，就会拦截所有线程，只能让一个线程访问。</p>
<p>对于对象锁（this），如果是同一个实例，就会按顺序访问，但是如果是不同实例，就可以同时访问。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/blog/2023/06/01/%E8%AF%AD%E8%A8%80/linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><ol>
<li>tar</li>
</ol>
<blockquote>
<blockquote>
<p>1.1压缩</p>
</blockquote>
</blockquote>
<ul>
<li>c: 创建压缩文件</li>
<li>z: 使用 gzip 的方式进行文件压缩</li>
<li>j: 使用 bzip2 的方式进行文件压缩</li>
<li>v: 压缩过程中显示压缩信息，可以省略不写</li>
<li>f: 指定压缩包的名字<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -czvf all.tar.gz *.c test.txt app monitor</span><br><span class="line">tar -cjvf all.tar.bz2 *.c test.txt app monitor</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>1.2解压</p>
</blockquote>
</blockquote>
</li>
<li>x: 释放压缩文件内容</li>
<li>z: 使用 gzip 的方式进行文件压缩，压缩包后缀为.tar.gz</li>
<li>j: 使用 bzip2 的方式进行文件压缩，压缩包后缀为.tar.bz2</li>
<li>v: 解压缩过程中显示解压缩信息</li>
<li>f: 指定压缩包的名字  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xzvf all.tar.gz</span><br><span class="line">tar -xjvf all.tar.bz2</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="查看安装目录"><a href="#查看安装目录" class="headerlink" title="查看安装目录"></a>查看安装目录</h1><p>whereis 安装程序名称</p>
<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p>less指令<br>功能：查看文件内容，less用法比more更具有弹性，可以使用 [pageup][pagedown]（前后按键）等按键的功能来往前往后翻看文件，而且less在查看之前不会加载整个文件。</p>
<p>选项：</p>
<ul>
<li>-e 当文件显示结束后，自动离开</li>
<li>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li>
<li>-g 只标志最后搜索的关键词</li>
<li>-i 忽略搜索时的大小写</li>
<li>-m 显示类似more命令的百分比</li>
<li>-N 显示每行的行号</li>
<li>-o &lt;文件名&gt;; 将less 输出的内容在指定文件中保存起来</li>
<li>-Q 不使用警告音</li>
<li>-s 显示连续空行为一行</li>
<li>-S 行过长时间将超出部分舍弃</li>
<li>-x &lt;数字&gt;; 将”tab”键显示为规定的数字空格</li>
<li>&#x2F;字符串：向下搜索”字符串”的功能</li>
<li>?字符串：向上搜索”字符串”的功能</li>
<li>n：重复前一个搜索（与 &#x2F; 或 ? 有关）</li>
<li>N：反向重复前一个搜索（与 &#x2F; 或 ? 有关）</li>
<li>b 向上翻一页</li>
<li>d 向后翻半页</li>
<li>h 显示帮助界面</li>
<li>Q 退出less 命令</li>
<li>u 向前滚动半页</li>
<li>y 向前滚动一行</li>
<li>空格键 滚动一页</li>
<li>回车键 滚动一行</li>
<li>[pagedown]： 向下翻动一页</li>
<li>[pageup]： 向上翻动一页</li>
</ul>
<h1 id="head"><a href="#head" class="headerlink" title="head"></a>head</h1><p>功能：显示文件内容的开头到标准输出，也就是屏幕上，head不加参数默认显示前10行</p>
<p>选项：</p>
<p>-n&lt;行数&gt;</p>
<h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>功能:用于显示指定文件末尾内容，我们一般查看日志时肯定是查看最新的内容，也就是从尾部开始查看，tail就能很好的帮助我们查看最近的内容</p>
<p>选项：</p>
<ul>
<li>-f ：循环读取</li>
<li>-n&lt;行号&gt; ：显示行数</li>
</ul>
<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>选项：-name :按照文件名查找</p>
<p>指定目录</p>
<p>语法：find [起始目录位置] [-name][filename]</p>
<h1 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h1><p>现在大多数Linux服务器都自带有lrzsz程序，方便文件上传下载，如果没有可以直接安装就好。</p>
<p>1、rz(本机文件上传服务器)</p>
<p>rz        # 选择本机上的文件上传给服务器</p>
<p>2、sz(服务器上文件拷贝给本机)</p>
<p>sz test.tar</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击简介及防范方法</title>
    <url>/blog/2024/01/17/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/XSS%E6%94%BB%E5%87%BB%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="XSS攻击简介"><a href="#XSS攻击简介" class="headerlink" title="XSS攻击简介"></a>XSS攻击简介</h1><p>人们经常将跨站脚本攻击（Cross Site Scripting）缩写为CSS，但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。跨站脚本攻击（XSS），是最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。攻击者可以使用户在浏览器中执行其预定义的恶意脚本，其导致的危害可想而知，如劫持用户会话，插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖XSS蠕虫，甚至破坏网站、修改路由器配置信息等。XSS漏洞可以追溯到上世纪90年代。大量的网站曾遭受XSS漏洞攻击或被发现此类漏洞，如Twitter、Facebook、MySpace、Orkut、新浪微博和百度贴吧。研究表明，最近几年XSS已经超过缓冲区溢出成为最流行的攻击方式，有68%的网站可能遭受此类攻击。根据开放网页应用安全计划（Open Web Application Security Project）公布的2010年统计数据，在Web安全威胁前10位中，XSS排名第2，仅次于代码注入（Injection）。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>HTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，<title>与</title>之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>（1）持久型跨站：最直接的危害类型，跨站代码存储在服务器（数据库）。</p>
<p>（2）非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。</p>
<p>（3）DOM跨站（DOM XSS）：DOM（document object model文档对象模型），客户端脚本处理逻辑导致的安全问题。</p>
<h1 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h1><p>常用的XSS攻击手段和目的有：</p>
<p>1、盗用cookie，获取敏感信息。</p>
<p>2、利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</p>
<p>3、利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</p>
<p>4、利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</p>
<p>5、在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</p>
<h1 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h1><p>（1）不信任用户提交的任何内容，对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、HTTP头、REFER、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。尽量采用POST而非GET提交表单；对“&lt;”，“&gt;”，“；”，“””等字符做过滤；任何内容输出到页面之前都必须加以en-code，避免不小心把htmltag显示出来。</p>
<p>（2）实现Session 标记（session tokens）、CAPTCHA（验证码）系统或者HTTP引用头检查，以防功能被第三方网站所执行，对于用户提交信息的中的img等link，检查是否有重定向回本站、不是真的图片等可疑操作。</p>
<p>（3）cookie 防盗。避免直接在cookie中泄露用户隐私，例如email、密码，等等；通过使cookie和系统IP绑定来降低cookie泄露后的危险。这样攻击者得到的cookie没有实际价值，很难拿来直接进行重放攻击。</p>
<p>（4）确认接收的内容被妥善地规范化，仅包含最小的、安全的Tag（没有JavaScript），去掉任何对远程内容的引用（尤其是样式表和JavaScript），使用HttpOnly 的cookie(HttpOnly是cookie的一个属性，在设置了 HttpOnly 属性的情况下，浏览器将禁止通过 JavaScript 访问和修改 Cookie，从而有效地防止一些常见的攻击，例如跨站脚本攻击（XSS）)。</p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title>markdown基本使用</title>
    <url>/blog/2023/06/01/%E8%AF%AD%E8%A8%80/markdown/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>1.标题</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>2.段落</p>
<p>空一行</p>
<p>3.分隔线</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>4.删除线<br><del>BAIDU.COM</del></p>
<p>5.下划线</p>
<p><u>带下划线文本</u></p>
<p>6.字体</p>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p>
<p>7.列表</p>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<p>8.代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>9.链接</p>
<p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p>
<p>或者</p>
<p>&lt;链接地址&gt;</p>
<p>10.图片</p>
<p><img src="/blog/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p>
<p><img src="/blog/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"></p>
<p>11.表格</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p>对齐方式</p>
<p>我们可以设置表格的对齐方式：</p>
<p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<p>12.区块<br>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Spring简介</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/1.Spring%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring 是为了解决企业级应用开发的复杂性而创建的。在 Spring 之前，有一个重量级的工具叫做 EJB，使用 Spring 可以让 Java Bean 之间进行有效的解耦，而这个操作之前只有 EJB 才能完成，EJB 过于臃肿，使用很少。Spring 不仅仅局限于服务端的开发，在测试性和松耦合方面都有很好的表现。</p>
<p>一般来说，初学者主要掌握 Spring 四个方面的功能：</p>
<ul>
<li>Ioc&#x2F;DI</li>
<li>AOP</li>
<li>事务</li>
<li>JdbcTemplate</li>
</ul>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>2.spring组件</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/2.spring%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="/blog/images/img/spring01.png" alt="spring02"></p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Spring服务端数据校验</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/10.Spring%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>B&#x2F;S 系统中对 http 请求数据的校验多数在客户端进行，这也是出于简单及用户体验性上考虑，但是在一些安全性要求高的系统中服务端校验是不可缺少的，实际上，几乎所有的系统，凡是涉及到数据校验，都需要在服务端进行二次校验。为什么要在服务端进行二次校验呢？这需要理解客户端校验和服务端校验各自的目的。 </p>
<ol>
<li>客户端校验，我们主要是为了提高用户体验，例如用户输入一个邮箱地址，要校验这个邮箱地址是否合法，没有必要发送到服务端进行校验，直接在前端用 js 进行校验即可。但是大家需要明白的是，前端校验无法代替后端校验，前端校验可以有效的提高用户体验，但是无法确保数据完整性，因为在 B&#x2F;S 架构中，用户可以方便的拿到请求地址，然后直接发送请求，传递非法参数。 </li>
<li>服务端校验，虽然用户体验不好，但是可以有效的保证数据安全与完整性。 </li>
<li>综上，实际项目中，两个一起用。</li>
</ol>
<p>Spring 支持 JSR-303 验证框架，JSR-303 是 JAVA EE 6  中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator（与Hibernate ORM 没有关系），JSR-303 用于对 Java Bean 中的字段的值进行验证。</p>
<h1 id="校验注解"><a href="#校验注解" class="headerlink" title="校验注解"></a>校验注解</h1><p> 校验注解，主要有如下几种： </p>
<ul>
<li>@Null 被注解的元素必须为 null </li>
<li>@NotNull 被注解的元素必须不为 null </li>
<li>@AssertTrue 被注解的元素必须为 true </li>
<li>@AssertFalse 被注解的元素必须为 false </li>
<li>@Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 </li>
<li>@Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值 </li>
<li>@DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 </li>
<li>@DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值 </li>
<li>@Size(max&#x3D;, min&#x3D;) 被注解的元素的大小必须在指定的范围内 </li>
<li>@Digits (integer, fraction) 被注解的元素必须是一个数字，其值必须在可接受的范围内 </li>
<li>@Past 被注解的元素必须是一个过去的日期 </li>
<li>@Future 被注解的元素必须是一个将来的日期 </li>
<li>@Pattern(regex&#x3D;,flag&#x3D;) 被注解的元素必须符合指定的正则表达式 </li>
<li>@NotBlank(message &#x3D;) 验证字符串非 null，且长度必须大于0 - @Email 被注解的元素必须是电子邮箱地址 </li>
<li>@Length(min&#x3D;,max&#x3D;) 被注解的字符串的大小必须在指定的范围内 </li>
<li>@NotEmpty 被注解的字符串的必须非空 </li>
<li>@Range(min&#x3D;,max&#x3D;,message&#x3D;) 被注解的元素必须在合适的范围内</li>
</ul>
<blockquote>
<p>更新2023年9月17日21点23分<br> 针对不同的请求需要不同的实体对象接受参数（比如新增和修改），需要新建不同的对象接受，代码冗余。Hibernate Validator提出了一种分组校验的方式。具有简易代码如下：</p>
</blockquote>
<ol>
<li>先定义一个分组类 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ValidateGroups &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">insert</span>&#123;&#125;;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">update</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>controller层增加校验组<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ResponResult</span> <span class="params">(<span class="meta">@ResponseBody</span> <span class="meta">@Validated(ValidateGroups.class)</span> UserDto userDto)</span> &#123;</span><br><span class="line">    userService.insert(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实体对象添加检验注解<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class UserDto &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message=&quot;新增用户名称不能为空&quot;,groups=&#123;ValidateGroups.insert.class&#125;)</span></span><br><span class="line">    <span class="meta">@NotEmpty(message=&quot;修改用户名称不能为空&quot;,groups=&#123;ValidateGroups.update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="非空校验注解-NotNull、-NotEmpty、-NotBlank的区别和运用"><a href="#非空校验注解-NotNull、-NotEmpty、-NotBlank的区别和运用" class="headerlink" title="非空校验注解 @NotNull、@NotEmpty、@NotBlank的区别和运用"></a>非空校验注解 @NotNull、@NotEmpty、@NotBlank的区别和运用</h1><h2 id="NotNull-常用在数据类型为Long，Integer的基础数据类型上，可以配合-Size、-Max、-Min对数值进行大小的控制"><a href="#NotNull-常用在数据类型为Long，Integer的基础数据类型上，可以配合-Size、-Max、-Min对数值进行大小的控制" class="headerlink" title="@NotNull 常用在数据类型为Long，Integer的基础数据类型上，可以配合@Size、@Max、@Min对数值进行大小的控制"></a>@NotNull 常用在数据类型为Long，Integer的基础数据类型上，可以配合@Size、@Max、@Min对数值进行大小的控制</h2><h2 id="NotEmpty-常用在集合类和数组类型上，也可以配合-Size进行大小的控制。"><a href="#NotEmpty-常用在集合类和数组类型上，也可以配合-Size进行大小的控制。" class="headerlink" title="@NotEmpty 常用在集合类和数组类型上，也可以配合@Size进行大小的控制。"></a>@NotEmpty 常用在集合类和数组类型上，也可以配合@Size进行大小的控制。</h2><h2 id="NotBlank-只用于String数据类型上，可以和-Len配合使用限制字符长度。"><a href="#NotBlank-只用于String数据类型上，可以和-Len配合使用限制字符长度。" class="headerlink" title="@NotBlank 只用于String数据类型上，可以和@Len配合使用限制字符长度。"></a>@NotBlank 只用于String数据类型上，可以和@Len配合使用限制字符长度。</h2>]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Spring属性注入</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/4.Spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="属性的注入"><a href="#属性的注入" class="headerlink" title="属性的注入"></a>属性的注入</h1><p>在 XML 配置中，属性的注入存在多种方式。</p>
<h1 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h1><p>通过 Bean 的构造方法给 Bean 的属性注入值。</p>
<ol>
<li>第一步首先给 Bean 添加对应的构造方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------book init----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(Integer id, String name, Double price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 xml 文件中注入 Bean<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;三国演义&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
这里需要注意的是，constructor-arg 中的 index 和 Book 中的构造方法参数一一对应。写的顺序可以颠倒，但是 index 的值和 value 要一一对应。</li>
</ol>
<p>另一种构造方法中的属性注入，则是通过直接指定参数名来注入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;红楼梦&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>如果有多个构造方法，则会根据给出参数个数以及参数类型，自动匹配到对应的构造方法上，进而初始化一个对象。</strong></p>
<h1 id="set-方法注入"><a href="#set-方法注入" class="headerlink" title="set 方法注入"></a>set 方法注入</h1><p>除了构造方法之外，我们也可以通过 set 方法注入值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;org.javaboy.Book&quot;</span> id=<span class="string">&quot;book3&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;3&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;水浒传&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;price&quot;</span> value=<span class="string">&quot;30&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>set 方法注入，有一个很重要的问题，就是属性名。很多人会有一种错觉，觉得属性名就是你定义的属性名，这个是不对的。在所有的框架中，凡是涉及到反射注入值的，属性名统统都不是 Bean 中定义的属性名，而是通过 Java 中的内省机制分析出来的属性名，简单说，就是根据 get&#x2F;set 方法分析出来的属性名。</p>
<h1 id="p-名称空间注入"><a href="#p-名称空间注入" class="headerlink" title="p 名称空间注入"></a>p 名称空间注入</h1><p>p 名称空间注入，使用的比较少，它本质上也是调用了 set 方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book4&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;4&quot;</span> <span class="attr">p:bookName</span>=<span class="string">&quot;西游记&quot;</span> <span class="attr">p:price</span>=<span class="string">&quot;33&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="外部-Bean-的注入"><a href="#外部-Bean-的注入" class="headerlink" title="外部 Bean 的注入"></a>外部 Bean 的注入</h1><p>有时候，我们使用一些外部 Bean，这些 Bean 可能没有构造方法，而是通过 Builder 来构造的，这个时候，就无法使用上面的方式来给它注入值了。</p>
<p>例如在 OkHttp 的网络请求中，原生的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .get()</span><br><span class="line">                .url(<span class="string">&quot;http://b.hiphotos.baidu.com/image/h%3D300/sign=ad628627aacc7cd9e52d32d909032104/32fa828ba61ea8d3fcd2e9ce9e0a304e241f5803.jpg&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\123.jpg&quot;</span>));</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="type">byte</span>[] buf = newbyte[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> response.body().byteStream();</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    out.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                out.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Bean 有一个特点，OkHttpClient 和 Request 两个实例都不是直接 new 出来的，在调用 Builder 方法的过程中，都会给它配置一些默认的参数。这种情况，我们可以使用 静态工厂注入或者实例工厂注入来给 OkHttpClient 提供一个实例。</p>
<ol>
<li>静态工厂注入<br>首先提供一个 OkHttpClient 的静态工厂：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtils</span> &#123;</span><br><span class="line">    privatestatic OkHttpClient OkHttpClient;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (OkHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">            OkHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OkHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 xml 文件中，配置该静态工厂：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.OkHttpUtils&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span> <span class="attr">id</span>=<span class="string">&quot;okHttpClient&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
这个配置表示 OkHttpUtils 类中的 getInstance 是我们需要的实例，实例的名字就叫 okHttpClient。然后，在 Java 代码中，获取到这个实例，就可以直接使用了。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;okHttpClient&quot;</span>, OkHttpClient.class);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .get()</span><br><span class="line">                .url(<span class="string">&quot;http://b.hiphotos.baidu.com/image/h%3D300/sign=ad628627aacc7cd9e52d32d909032104/32fa828ba61ea8d3fcd2e9ce9e0a304e241f5803.jpg&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\123.jpg&quot;</span>));</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="type">byte</span>[] buf = newbyte[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> response.body().byteStream();</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    out.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                out.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实例工厂注入<br>实例工厂就是工厂方法是一个实例方法，这样，工厂类必须实例化之后才可以调用工厂方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OkHttpClient OkHttpClient;</span><br><span class="line">    <span class="keyword">public</span> OkHttpClient <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (OkHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">            OkHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OkHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时，在 xml 文件中，需要首先提供工厂方法的实例，然后才可以调用工厂方法：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.OkHttpUtils&quot;</span> <span class="attr">id</span>=<span class="string">&quot;okHttpUtils&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;okhttp3.OkHttpClient&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;okHttpUtils&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span> <span class="attr">id</span>=<span class="string">&quot;okHttpClient&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
自己写的 Bean 一般不会使用这两种方式注入，但是，如果需要引入外部 jar，外部 jar 的类的初始化，有可能需要使用这两种方式。</li>
</ol>
<p>这次的工厂类如下：</p>
<h1 id="复杂属性的注入"><a href="#复杂属性的注入" class="headerlink" title="复杂属性的注入"></a>复杂属性的注入</h1><ol>
<li>对象注入<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Cat&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小白&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;白色&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
可以通过 xml 注入对象，通过 ref 来引用一个对象。</li>
<li>数组注入<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>乒乓球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Cat&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小白&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;白色&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
注意，array 节点，也可以被 list 节点代替。</li>
</ol>
<p>当然，array 或者 list 节点中也可以是对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>乒乓球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cats&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;cat2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Cat&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cat3&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小花&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;花色&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Cat&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小白&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;白色&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.Cat&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小黑&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;黑色&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，即可以通过 ref 使用外部定义好的 Bean，也可以直接在 list 或者 array 节点中定义 bean。<br>3. Map 注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;99&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;javaboy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Properties 注入<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;age&quot;</span>&gt;</span>99<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span>&gt;</span>javaboy<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
以上 Demo，定义的 User 如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> String[] favorites;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Cat&gt; cats;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, cat=&quot;</span> + cat +</span><br><span class="line">                <span class="string">&quot;, favorites=&quot;</span> + Arrays.toString(favorites) +</span><br><span class="line">                <span class="string">&quot;, cats=&quot;</span> + cats +</span><br><span class="line">                <span class="string">&quot;, map=&quot;</span> + map +</span><br><span class="line">                <span class="string">&quot;, info=&quot;</span> + info +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Properties <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(Properties info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Cat&gt; <span class="title function_">getCats</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCats</span><span class="params">(List&lt;Cat&gt; cats)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cats = cats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getFavorites() &#123;</span><br><span class="line">        <span class="keyword">return</span> favorites;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFavorites</span><span class="params">(String[] favorites)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.favorites = favorites;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String name, Integer age, Cat cat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">getCat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCat</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h1><p>在 Spring 中，想要将一个 Bean 注册到 Spring 容器中，整体上来说，有三种不同的方式。</p>
<p>XML 注入，如前文所说<br>Java 配置（通过 Java 代码将 Bean 注册到 Spring 容器中）<br>自动化扫描<br>这里我们来看 Java 配置。</p>
<p>Java 配置这种方式在 Spring Boot 出现之前，其实很少使用，自从有了 Spring Boot，Java 配置开发被广泛使用，因为在 Spring Boot 中，不使用一行 XML 配置。</p>
<p>例如我有如下一个 Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SayHello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 配置中，我们用一个 Java 配置类去代替之前的 applicationContext.xml 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SayHello <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在配置类上有一个 @Configuration 注解，这个注解表示这个类不是一个普通类，而是一个配置类，它的作用相当于 applicationContext.xml。然后，定义方法，方法返回对象，方法上添加 @Bean 注解，表示将这个方法的返回值注入的 Spring 容器中去。也就是说，@Bean 所对应的方法，就相当于 applicationContext.xml 中的 bean 节点。</p>
<p>既然是配置类，我们需要在项目启动时加载配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line">        <span class="type">SayHello</span> <span class="variable">hello</span> <span class="operator">=</span> ctx.getBean(SayHello.class);</span><br><span class="line">        System.out.println(hello.sayHello(<span class="string">&quot;javaboy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，配置的加载，是使用 AnnotationConfigApplicationContext 来实现。</p>
<p>关于 Java 配置，这里有一个需要注意的问题:Bean 的名字是什么？</p>
<p>Bean 的默认名称是方法名。以上面的案例为例，Bean 的名字是 sayHello。如果开发者想自定义方法名，也是可以的，直接在 @Bean 注解中进行过配置。如下配置表示修改 Bean 的名字为 javaboy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;javaboy&quot;)</span></span><br><span class="line">    SayHello <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p>在我们实际开发中，大量的使用自动配置。</p>
<p>自动化配置既可以通过 Java 配置来实现，也可以通过 xml 配置来实现。</p>
<blockquote>
<p>1.准备工作</p>
</blockquote>
<p>例如我有一个 UserService，我希望在自动化扫描时，这个类能够自动注册到 Spring 容器中去，那么可以给该类添加一个 @Service，作为一个标记。</p>
<p>和 @Service 注解功能类似的注解，一共有四个：</p>
<ul>
<li><p>@Component</p>
</li>
<li><p>@Repository</p>
</li>
<li><p>@Service</p>
</li>
<li><p>@Controller<br>这四个中，另外三个都是基于 @Component 做出来的，而且从目前的源码来看，功能也是一致的，那么为什么要搞三个呢？主要是为了在不同的类上面添加时方便。</p>
</li>
<li><p>在 Service 层上，添加注解时，使用 @Service</p>
</li>
<li><p>在 Dao 层，添加注解时，使用 @Repository</p>
</li>
<li><p>在 Controller 层，添加注解时，使用 @Controller</p>
</li>
<li><p>在其他组件上添加注解时，使用 @Component</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            users.add(<span class="string">&quot;javaboy:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完成后，自动化扫描有两种方式，一种就是通过 Java 代码配置自动化扫描，另一种则是通过 xml 文件来配置自动化扫描。</p>
</li>
</ul>
<blockquote>
<p>2.Java 代码配置自动扫描</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.javaboy.javaconfig.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在项目启动中加载配置类，在配置类中，通过 @ComponentScan 注解指定要扫描的包（如果不指定，默认情况下扫描的是配置类所在的包下载的 Bean 以及配置类所在的包下的子包下的类），然后就可以获取 UserService 的实例了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ctx.getBean(UserService.class);</span><br><span class="line">        System.out.println(userService.getAllUser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个问题需要注意：</p>
<ol>
<li>Bean 的名字叫什么？</li>
</ol>
<p>默认情况下，Bean 的名字是类名首字母小写。例如上面的 UserService，它的实例名，默认就是 userService。如果开发者想要自定义名字，就直接在 @Service 注解中添加即可。</p>
<ol start="2">
<li>有几种扫描方式？</li>
</ol>
<p>上面的配置，我们是按照包的位置来扫描的。也就是说，Bean 必须放在指定的扫描位置，否则，即使你有 @Service 注解，也扫描不到。</p>
<p>除了按照包的位置来扫描，还有另外一种方式，就是根据注解来扫描。例如如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.javaboy.javaconfig&quot;,useDefaultFilters = true,excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置表示扫描 org.javaboy.javaconfig 下的所有 Bean，但是除了 Controller。</p>
<blockquote>
<p>3.XML 配置自动化扫描</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.javaboy.javaconfig&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这行配置表示扫描 org.javaboy.javaconfig 下的所有 Bean。当然也可以按照类来扫描。</p>
<p>XML 配置完成后，在 Java 代码中加载 XML 配置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ctx.getBean(UserService.class);</span><br><span class="line">        List&lt;String&gt; list = userService.getAllUser();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在 XML 配置中按照注解的类型进行扫描：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.javaboy.javaconfig&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.对象注入<br>自动扫描时的对象注入有三种方式：</p>
</blockquote>
<ol>
<li>@Autowired</li>
<li>@Resources</li>
<li>@Injected</li>
</ol>
<p>@Autowired 是根据类型去查找，然后赋值，这就有一个要求，这个类型只可以有一个对象，否则就会报错。@Resources 是根据名称去查找，默认情况下，定义的变量名，就是查找的名称，当然开发者也可以在 @Resources 注解中手动指定。所以，如果一个类存在多个实例，那么就应该使用 @Resources 去注入，如果非要使用 @Autowired，也是可以的，此时需要配合另外一个注解，@Qualifier，在 @Qualifier 中可以指定变量名，两个一起用（@Qualifier 和 @Autowired）就可以实现通过变量名查找到变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            users.add(<span class="string">&quot;javaboy:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringEvent</title>
    <url>/blog/2024/02/10/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/11.SpringEvent/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="什么是springevent"><a href="#什么是springevent" class="headerlink" title="什么是springevent"></a>什么是springevent</h1><p>Spring Event 是 Spring 框架中的一个事件机制，用于实现应用程序内部的事件传递和处理。通常情况下，当应用程序需要响应某些特定事件时，可以使用 Spring Event 来实现。</p>
<h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>用户创建成功后给用户发送一个邮件。</p>
<p>通常会直接在创建用户的业务层里写发送邮件，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(UserDTO userDTO)</span> &#123;</span><br><span class="line">        userMapper.save(userDTO);</span><br><span class="line">        EmailUtil.sendEmail(userDTO.getEmail(),<span class="string">&quot;您的账户已创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种实现是有问题的。我们想一下，这个功能的核心是创建用户，而发送邮件是一个副作用（发送邮件不能影响用户的创建），如果把这两个操作放在一个事务中会有什么问题？其实很明显，如果创建用户时抛出异常，事务回滚，方法提前退出，那么也不会发送邮件，这是正常的。但是下面两个场景是不可接受的：</p>
<p>如果邮件发送失败，事务发生回滚，用户创建失败。</p>
<p>如果邮件发送成功后，事务提交失败，这下就尴尬了，用户收到了邮件，可是用户创建失败。</p>
<p>对上面的实现做个重构，直接将创建用户和发送邮件的业务代码拆开，使用Spring application event的方式解耦实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(UserDTO userDTO)</span> &#123;</span><br><span class="line">        userMapper.save(userDTO);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getById(userDTO.getId());</span><br><span class="line">        <span class="type">SendEmailEvent</span> <span class="variable">sendEmailEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendEmailEvent</span>();</span><br><span class="line">        sendEmailEvent.setEmail(user.getEmail());</span><br><span class="line">        sendEmailEvent.setContent(<span class="string">&quot;您的账户已创建&quot;</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(sendEmailEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自从Spring 4.2，我们不用继承ApplicationEvent而能发布任何对象，Spring会把它们包装成PayloadApplicationEvent。</p>
<p>我们需要一个Event Listener处理上面的事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendEmailEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSendEmailEvent</span><span class="params">(SendEmailEvent event)</span> &#123;</span><br><span class="line">        EmailUtil.sendEmail(event.getEmail(),event.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过上面的重构，我们将创建用户和发送邮件的业务代码拆开来了，但是有解决上面提到的问题吗？答案是没有，虽然我们用EventListener的方式解耦了业务代码，可是这在底层两个功能还是在<strong>同一个事务中执行</strong>（有人可能想问在Listener方法上加@Async让异步执行可以吗？当然不行，邮件必须在用户创建成功后发送，这里有业务依赖），意思就是，上面的两种情况依然会发生。那么问题来了，有没有解决方案呢?</p>
<p>当然有，就是用@TransactionalEventListener替换@EventListener，结果就是在创建用户并提交事务后发送邮件通知。</p>
<p>TransactionalEventListener</p>
<p>TransactionalEventListener是对EventListener的增强，被注解的方法可以在事务的不同阶段去触发执行，如果事件未在激活的事务中发布，除非显式设置了 fallbackExecution() 标志为true，否则该事件将被丢弃；如果事务正在运行，则根据其 TransactionPhase 处理该事件。</p>
<p>Notice：你可以通过注解@Order去排序所有的Listener，确保他们按自己的设定的预期顺序执行。</p>
<p>我们先看看TransactionPhase有哪些：</p>
<p>AFTER_COMMIT - 默认设置，在事务提交后执行<br>AFTER_ROLLBACK - 在事务回滚后执行<br>AFTER_COMPLETION - 在事务完成后执行（不管是否成功）<br>BEFORE_COMMIT - 在事务提交前执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendEmailEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSendEmailEvent</span><span class="params">(SendEmailEvent event)</span> &#123;</span><br><span class="line">        EmailUtil.sendEmail(event.getEmail(),event.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在我们做一个总结，如果你遇到这样的业务，操作B需要在操作A事务提交后去执行，那么TransactionalEventListener是一个很好地选择。这里需要特别注意的一个点就是：当B操作有数据改动并持久化时，并希望在A操作的AFTER_COMMIT阶段执行，那么你需要将B事务声明为PROPAGATION_REQUIRES_NEW。这是因为A操作的事务提交后，事务资源可能仍然处于激活状态，如果B操作使用默认的PROPAGATION_REQUIRED的话，会直接加入到操作A的事务中，但是这时候事务A是不会再提交，结果就是程序写了修改和保存逻辑，但是数据库数据却没有发生变化，解决方案就是要明确的将操作B的事务设为PROPAGATION_REQUIRES_NEW。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>3.spring IOC</title>
    <url>/blog/2023/06/02/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/3.springIOC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="IOC概念"><a href="#IOC概念" class="headerlink" title="IOC概念"></a>IOC概念</h1><p>Ioc （Inversion of Control），中文叫做控制反转。这是一个概念，也是一种思想。控制反转，实际上就是指对一个对象的控制权的反转。例如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicclass Book &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line"><span class="comment">//省略getter/setter</span></span><br><span class="line">&#125;</span><br><span class="line">publicclass User &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setId(<span class="number">1</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;故事新编&quot;</span>);</span><br><span class="line">        book.setPrice((<span class="type">double</span>) <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，Book 对象的控制权在 User 对象里边，这样，Book 和 User 高度耦合，如果在其他对象中需要使用 Book 对象，得重新创建，也就是说，对象的创建、初始化、销毁等操作，统统都要开发者自己来完成。如果能够将这些操作交给容器来管理，开发者就可以极大的从对象的创建中解脱出来。</p>
<p>使用 Spring 之后，我们可以将对象的创建、初始化、销毁等操作交给 Spring 容器来管理。就是说，在项目启动时，所有的 Bean 都将自己注册到 Spring 容器中去（如果有必要的话），然后如果其他 Bean 需要使用到这个 Bean ，则不需要自己去 new，而是直接去 Spring 容器去要。</p>
<p>通过一个简单的例子看下这个过程。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><ol>
<li>首先创建一个普通的 Maven 项目，然后引入 spring-context 依赖，如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>resources文件夹下创建applicationContext.xml文件，并输入如下内容<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zhangjie.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
class 属性表示需要注册的 bean 的全路径，id 则表示 bean 的唯一标记，也开可以 name 属性作为 bean 的标记，在超过 99% 的情况下，id 和 name 其实是一样的，特殊情况下不一样。</li>
<li>接下来，加载这个配置文件：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
执行 main 方法，配置文件就会被自动加载，进而在 Spring 中初始化一个 Book 实例。此时，我们显式的指定 Book 类的无参构造方法，并在无参构造方法中打印日志，可以看到无参构造方法执行了，进而证明对象已经在 Spring 容器中初始化了。最后，通过 getBean 方法，可以从容器中去获取对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> (Book) ctx.getBean(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>加载方式，除了ClassPathXmlApplicationContext 之外（去 classpath 下查找配置文件），另外也可以使用 FileSystemXmlApplicationContext ，FileSystemXmlApplicationContext 会从操作系统路径下去寻找配置文件。</p>
</blockquote>
</li>
</ol>
<h1 id="Bean-的获取"><a href="#Bean-的获取" class="headerlink" title="Bean 的获取"></a>Bean 的获取</h1><p>我们通过 ctx.getBean 方法来从 Spring 容器中获取 Bean，传入的参数是 Bean 的 name 或者 id 属性。除了这种方式之外，也可以直接通过 Class 去获取一个 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> ctx.getBean(Book.class);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式有一个很大的弊端，如果存在多个实例，这种方式就不可用，例如，xml 文件中存在两个 Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zhangjie.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zhangjie.Book&quot;</span> <span class="attr">id</span>=<span class="string">&quot;book2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，如果通过 Class 去查找 Bean，会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;com.zhangjie.pojo.Book&#x27; available: expected single matching bean but found 2: book,book2</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1144)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:411)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:344)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:337)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1123)</span><br><span class="line">	at com.zhangjie.App.main(App.java:12)</span><br></pre></td></tr></table></figure>
<p>所以，一般建议使用 name 或者 id 去获取 Bean 的实例。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>6.Spring Aware接口</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/6.SpringAware%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Aware 接口，从字面上理解就是感知捕获。单纯的一个 Bean 是没有知觉的。在实际开发中，我们可能会遇到一些类，需要获取到容器的详细信息，那就可以通过 Aware 接口来实现。</p>
<p>这些实现的接口，有一些公共特性：</p>
<ol>
<li>都是以 Aware 结尾</li>
<li>都继承自 Aware</li>
<li>接口内均定义了一个 set 方法</li>
</ol>
<p>每一个子接口均提供了一个 set 方法，方法的参数就是当前 Bean 需要感知的内容，因此我们需要在 Bean 中声明相关的成员变量来接受这个参数。接收到这个参数后，就可以通过这个参数获取到容器的详细信息了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SayHello</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//判断容器中是否存在某个 Bean</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">userDao</span> <span class="operator">=</span> applicationContext.containsBean(<span class="string">&quot;userDao333&quot;</span>);</span><br><span class="line">        System.out.println(userDao);</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>2023版Java面试</title>
    <url>/blog/2024/05/04/%E9%9D%A2%E8%AF%95/2023%E7%89%88Java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="Redis相关面试题"><a href="#Redis相关面试题" class="headerlink" title="Redis相关面试题"></a>Redis相关面试题</h1><blockquote>
<p><strong>面试官</strong>：什么是缓存穿透 ? 怎么解决 ?</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，我想一下</p>
<p>缓存穿透是指查询一个一定<strong>不存在</strong>的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。</p>
<p>解决方案的话，我们通常都会用布隆过滤器来解决它</p>
<p><strong>面试官</strong>：好的，你能介绍一下布隆过滤器吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样~</p>
<p>布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是redisson实现的布隆过滤器。</p>
<p>它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是0，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。</p>
<p>当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p>
<p><strong>面试官</strong>：什么是缓存击穿 ? 怎么解决 ?</p>
<p><strong>候选人</strong>：</p>
<p>嗯！！</p>
<p>缓存击穿的意思是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。</p>
<p>解决方案有两种方式：</p>
<p>第一可以使用互斥锁：当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法</p>
<p>第二种方案可以设置当前key逻辑过期，大概是思路如下：</p>
<p>①：在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间</p>
<p>②：当查询的时候，从redis取出数据后判断时间是否过期</p>
<p>③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</p>
<p>当然两种方案各有利弊：</p>
<p>如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题</p>
<p>如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</p>
<p><strong>面试官</strong>：什么是缓存雪崩 ? 怎么解决 ?</p>
<p><strong>候选人</strong>：</p>
<p>嗯！！</p>
<p>缓存雪崩意思是设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。</p>
<p>解决方案主要是可以将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p><strong>面试官</strong>：redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</p>
<p><strong>候选人</strong>：嗯！就说我最近做的这个项目，里面有xxxx（<strong>根据自己的简历上写</strong>）的功能，需要让数据库与redis高度保持一致，因为要求时效性比较高，我们当时采用的读写锁保证的强一致性。</p>
<p>我们采用的是redisson实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。</p>
<p><strong>面试官</strong>：那这个排他锁是如何保证读写、读读互斥的呢？</p>
<p><strong>候选人</strong>：其实排他锁底层使用也是setnx，保证了同时只能有一个线程操作锁住的方法</p>
<p><strong>面试官</strong>：你听说过延时双删吗？为什么不用它呢？</p>
<p><strong>候选人</strong>：延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。</p>
<p><strong>面试官</strong>：redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</p>
<p><strong>候选人</strong>：嗯！就说我最近做的这个项目，里面有xxxx（<strong>根据自己的简历上写</strong>）的功能，数据同步可以有一定的延时（符合大部分业务）</p>
<p>我们当时采用的阿里的canal组件实现数据同步：不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。</p>
<p><strong>面试官</strong>：redis做为缓存，数据的持久化是怎么做的？</p>
<p><strong>候选人</strong>：在Redis中提供了两种数据持久化的方式：1、RDB  2、AOF</p>
<p><strong>面试官</strong>：这两种持久化方式有什么区别呢？</p>
<p><strong>候选人</strong>：RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。</p>
<p>AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据</p>
<p><strong>面试官</strong>：这两种方式，哪种恢复的比较快呢？</p>
<p><strong>候选人</strong>：RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令</p>
<p><strong>面试官</strong>：Redis的数据过期策略有哪些 ? </p>
<p><strong>候选人</strong>：</p>
<p>嗯~，在redis中提供了两种数据过期删除策略</p>
<p>第一种是惰性删除，在设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p>
<p>第二种是 定期删除，就是说每隔一段时间，我们就对一些key进行检查，删除里面过期的key</p>
<p>定期清理的两种模式：</p>
<ul>
<li>SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的 <strong>hz</strong> 选项来调整这个次数</li>
<li>FAST模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ul>
<p>Redis的过期删除策略：<strong>惰性删除 + 定期删除</strong>两种策略进行配合使用。</p>
<p><strong>面试官</strong>：Redis的数据淘汰策略有哪些 ? </p>
<p><strong>候选人</strong>：</p>
<p>嗯，这个在redis中提供了很多种，默认是noeviction，不删除任何数据，内部不足直接报错</p>
<p>是可以在redis的配置文件中进行设置的，里面有两个非常重要的概念，一个是LRU，另外一个是LFU</p>
<p>LRU的意思就是最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p>
<p>LFU的意思是最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</p>
<p>我们在项目设置的allkeys-lru，挑选最近最少使用的数据淘汰，把一些经常访问的key留在redis中</p>
<p><strong>面试官</strong>：数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?</p>
<p><strong>候选人</strong>：</p>
<p>嗯，我想一下~~</p>
<p>可以使用 allkeys-lru （挑选最近最少使用的数据淘汰）淘汰策略，那留下来的都是经常访问的热点数据</p>
<p><strong>面试官</strong>：Redis的内存用完了会发生什么？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~，这个要看redis的数据淘汰策略是什么，如果是默认的配置，redis内存用完以后则直接报错。我们当时设置的 allkeys-lru 策略。把最近最常访问的数据留在缓存中。</p>
<p><strong>面试官</strong>：Redis分布式锁如何实现 ? </p>
<p><strong>候选人</strong>：嗯，在redis中提供了一个命令setnx(SET if not exists)</p>
<p>由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的</p>
<p><strong>面试官</strong>：好的，那你如何控制Redis实现分布式锁有效时长呢？</p>
<p><strong>候选人</strong>：嗯，的确，redis的setnx指令不好控制这个问题，我们当时采用的redis的一个框架redisson实现的。</p>
<p>在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在redisson中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了</p>
<p>还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。</p>
<p><strong>面试官</strong>：好的，redisson实现的分布式锁是可重入的吗？</p>
<p><strong>候选人</strong>：嗯，是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数</p>
<p><strong>面试官</strong>：redisson实现的分布式锁能解决主从一致性的问题吗</p>
<p><strong>候选人</strong>：这个是不能的，比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。</p>
<p>我们可以利用redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，并且要求在大多数redis节点上都成功创建锁，红锁中要求是redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。</p>
<p>但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁</p>
<p><strong>面试官</strong>：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？</p>
<p><strong>候选人：</strong>嗯~，redis本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用zookeeper实现的分布式锁，它是可以保证强一致性的。</p>
<p><strong>面试官</strong>：Redis集群有哪些方案, 知道嘛 ? </p>
<p><strong>候选人</strong>：嗯~~，在Redis中提供的集群方案总共有三种：主从复制、哨兵模式、Redis分片集群</p>
<p><strong>面试官</strong>：那你来介绍一下主从同步</p>
<p><strong>候选人</strong>：嗯，是这样的，单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中</p>
<p><strong>面试官</strong>：能说一下，主从同步数据的流程</p>
<p><strong>候选人</strong>：嗯~~，好！主从同步分为了两个阶段，一个是全量同步，一个是增量同步</p>
<p>全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：</p>
<p>第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id和offset偏移量。</p>
<p>第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。</p>
<p>第三：在同时主节点会执行bgsave，生成rdb文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这样就保持了一致</p>
<p>当然，如果在rdb生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步</p>
<p>增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</p>
<p><strong>面试官</strong>：怎么保证Redis的高并发高可用</p>
<p><strong>候选人</strong>：首先可以搭建主从集群，再加上使用redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证redis的高并发高可用</p>
<p><strong>面试官</strong>：你们使用redis是单点还是集群，哪种集群</p>
<p><strong>候选人</strong>：嗯！，我们当时使用的是主从（1主1从）加哨兵。一般单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用lua脚本和事务</p>
<p><strong>面试官</strong>：redis集群脑裂，该怎么解决呢？</p>
<p><strong>候选人</strong>：嗯！ 这个在项目很少见，不过脑裂的问题是这样的，我们现在用的是redis的哨兵模式集群的</p>
<p>有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old master降为salve，这时再从新master同步数据，这会导致old master中的大量数据丢失。</p>
<p>关于解决的话，我记得在redis的配置中可以设置：第一可以设置最少的salve节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p>
<p><strong>面试官</strong>：redis的分片集群有什么作用</p>
<p><strong>候选人</strong>：分片集群主要解决的是，海量数据存储的问题，集群中有多个master，每个master保存不同数据，并且还可以给每个master设置多个slave节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
<p><strong>面试官</strong>：Redis分片集群中数据是怎么存储和读取的？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~，在redis集群中是这样的</p>
<p>Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。</p>
<p>取值的逻辑是一样的</p>
<p><strong>面试官</strong>：Redis是单线程的，但是为什么还那么快？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，这个有几个原因吧~~~</p>
<p>1、完全基于内存的，C语言编写</p>
<p>2、采用单线程，避免不必要的上下文切换可竞争条件</p>
<p>3、使用多路I&#x2F;O复用模型，非阻塞IO</p>
<p>例如：bgsave 和 bgrewriteaof  都是在<strong>后台</strong>执行操作，不影响主线程的正常使用，不会产生阻塞</p>
<p><strong>面试官</strong>：能解释一下I&#x2F;O多路复用模型？</p>
<p><strong>候选人</strong>：嗯~~，I&#x2F;O多路复用是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I&#x2F;O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。</p>
<p>其中Redis的网络模型就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；</p>
<p>在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>
</blockquote>
<h3 id="MySQL面试题-文稿"><a href="#MySQL面试题-文稿" class="headerlink" title="MySQL面试题-文稿"></a>MySQL面试题-文稿</h3><blockquote>
<p><strong>面试官：</strong>MySQL中，如何定位慢查询?</p>
<p><strong>候选人：</strong></p>
<p>嗯~，我们当时做压测的时候有的接口非常的慢，接口的响应时间超过了2秒以上，因为我们当时的系统部署了运维的监控系统Skywalking ，在展示的报表中可以看到是哪一个接口比较慢，并且可以分析这个接口哪部分比较慢，这里可以看到SQL的具体的执行时间，所以可以定位是哪个sql出了问题</p>
<p>如果，项目中没有这种运维的监控系统，其实在MySQL中也提供了慢日志查询的功能，可以在MySQL的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文件中，我记得上一个项目配置的是2秒，只要SQL执行的时间超过了2秒就会记录到日志文件中，我们就可以在日志文件找到执行比较慢的SQL了。</p>
<p><strong>面试官：</strong>那这个SQL语句执行很慢, 如何分析呢？</p>
<p><strong>候选人：</strong>如果一条sql执行很慢的话，我们通常会使用mysql自动的执行计划explain来去查看这条sql的执行情况，比如在这里面可以通过key和key_len检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况，第二个，可以通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，第三个可以通过extra建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</p>
<p><strong>面试官：</strong>了解过索引吗？（什么是索引）</p>
<p><strong>候选人：</strong>嗯，索引在项目中还是比较常见的，它是帮助MySQL高效获取数据的数据结构，主要是用来提高数据检索的效率，降低数据库的IO成本，同时通过索引列对数据进行排序，降低数据排序的成本，也能降低了CPU的消耗</p>
<p><strong>面试官：</strong>索引的底层数据结构了解过嘛 ? </p>
<p><strong>候选人：</strong>MySQL的默认的存储引擎InnoDB采用的B+树的数据结构来存储索引，选择B+树的主要的原因是：第一阶数更多，路径更短，第二个磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据，第三是B+树便于扫库和区间查询，叶子节点是一个双向链表</p>
<p><strong>面试官：</strong>B树和B+树的区别是什么呢？</p>
<p><strong>候选人</strong>：第一：在B树中，非叶子节点和叶子节点都会存放数据，而B+树的所有的数据都会出现在叶子节点，在查询的时候，B+树查找效率更加稳定</p>
<p>第二：在进行范围查询的时候，B+树效率更高，因为B+树都在叶子节点存储，并且叶子节点是一个双向链表</p>
<p><strong>面试官：</strong>什么是聚簇索引什么是非聚簇索引 ?</p>
<p><strong>候选人：</strong></p>
<p>好的~，聚簇索引主要是指数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个，一般情况下主键在作为聚簇索引的</p>
<p>非聚簇索引值的是数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个，一般我们自己定义的索引都是非聚簇索引</p>
<p><strong>面试官：</strong>知道什么是回表查询嘛 ?</p>
<p><strong>候选人：</strong>嗯，其实跟刚才介绍的聚簇索引和非聚簇索引是有关系的，回表的意思就是通过二级索引找到对应的主键值，然后再通过主键值找到聚集索引中所对应的整行数据，这个过程就是回表</p>
<p>【<strong>备注</strong>：如果面试官直接问回表，则需要先介绍聚簇索引和非聚簇索引】</p>
<p><strong>面试官：</strong>知道什么叫覆盖索引嘛 ? </p>
<p><strong>候选人：</strong>嗯~，清楚的</p>
<p>覆盖索引是指select查询语句使用了索引，在返回的列，必须在索引中全部能够找到，如果我们使用id查询，它会直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p>
<p>如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *，尽量在返回的列中都包含添加索引的字段</p>
<p><strong>面试官：</strong>MYSQL超大分页怎么处理 ?</p>
<p><strong>候选人：</strong>嗯，超大分页一般都是在数据量比较大时，我们使用了limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决</p>
<p>先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了</p>
<p>因为查询id的时候，走的覆盖索引，所以效率可以提升很多</p>
<p><strong>面试官：</strong>索引创建原则有哪些？</p>
<p><strong>候选人：</strong>嗯，这个情况有很多，不过都有一个大前提，就是表中的数据要超过10万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。</p>
<p>还有就是，我们通常创建索引的时候都是使用复合索引来创建，一条sql的返回值，尽量使用覆盖索引，如果字段的区分度不高的话，我们也会把它放在组合索引后面的字段。</p>
<p>如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢。</p>
<p><strong>面试官：</strong>什么情况下索引会失效 ?</p>
<p><strong>候选人：</strong>嗯，这个情况比较多，我说一些自己的经验，以前遇到过的</p>
<p>比如，索引在使用的时候没有遵循最左匹配法则，第二个是，模糊查询，如果%号在前面也会导致索引失效。如果在添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效。</p>
<p>我们之前还遇到过一个就是，如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效</p>
<p>所以，通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用explain执行计划来分析</p>
<p><strong>面试官：</strong>sql的优化的经验</p>
<p><strong>候选人：</strong>嗯，这个在项目还是挺常见的，当然如果直说sql优化的话，我们会从这几方面考虑，比如</p>
<p>建表的时候、使用索引、sql语句的编写、主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表</p>
<p><strong>面试官：</strong>创建表的时候，你们是如何优化的呢？</p>
<p><strong>候选人：</strong>这个我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int 、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型</p>
<p><strong>面试官：</strong>那在使用索引的时候，是如何优化呢？</p>
<p><strong>候选人：</strong>【参考索引创建原则    进行描述】</p>
<p><strong>面试官：</strong>你平时对sql语句做了哪些优化呢？</p>
<p><strong>候选人：</strong>嗯，这个也有很多，比如SELECT语句务必指明字段名称，不要直接使用select * ，还有就是要注意SQL语句避免造成索引失效的写法；如果是聚合查询，尽量用union all代替union ，union会多一次过滤，效率比较低；如果是表关联的话，尽量使用innerjoin ，不要使用用left join right join，如必须使用 一定要以小表为驱动</p>
<p><strong>面试官：</strong>事务的特性是什么？可以详细说一下吗？</p>
<p><strong>候选人：</strong>嗯，这个比较清楚，ACID，分别指的是：原子性、一致性、隔离性、持久性；我举个例子：</p>
<p>A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在要么都成功，要么都失败</p>
<p>在转账的过程中，数据要一致，A扣除了500，B必须增加500</p>
<p>在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰</p>
<p>在转账的过程中，持久性体现在事务提交后，要把数据持久化（可以说是落盘操作）</p>
<p><strong>面试官</strong>：并发事务带来哪些问题？</p>
<p><strong>候选人</strong>：</p>
<p>我们在项目开发中，多个事务并发进行是经常发生的，并发也是必然的，有可能导致一些问题</p>
<p>第一是脏读， 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
<p>第二是不可重复读：比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p>第三是幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p><strong>面试官</strong>：怎么解决这些问题呢？MySQL的默认隔离级别是？</p>
<p><strong>候选人</strong>：解决方案是对事务进行隔离</p>
<p>MySQL支持四种隔离级别，分别有：</p>
<p>第一个是，未提交读（read uncommitted）它解决不了刚才提出的所有问题，一般项目中也不用这个。第二个是读已提交（read committed）它能解决脏读的问题的，但是解决不了不可重复读和幻读。第三个是可重复读（repeatable read）它能解决脏读和不可重复读，但是解决不了幻读，这个也是mysql默认的隔离级别。第四个是串行化（serializable）它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。所以，我们一般使用的都是mysql默认的隔离级别:可重复读</p>
<p><strong>面试官</strong>：undo log和redo log的区别</p>
<p><strong>候选人</strong>：好的，其中redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据，而undo log 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作；</p>
<p>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</p>
<p><strong>面试官</strong>：事务中的隔离性是如何保证的呢？(你解释一下MVCC)</p>
<p><strong>候选人</strong>：事务的隔离性是由锁和mvcc实现的。</p>
<p>其中mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undo log日志，第三个是readView读视图</p>
<p>隐藏字段是指：在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的；另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</p>
<p>undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</p>
<p>readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
<p><strong>面试官</strong>：MySQL主从同步原理 </p>
<p><strong>候选人</strong>：MySQL主从复制的核心就是二进制日志(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：</p>
<p>第一：主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p>
<p>第二：从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p>
<p>第三：从库重做中继日志中的事件，将改变反映它自己的数据</p>
<p><strong>面试官</strong>：你们项目用过MySQL的分库分表吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，因为我们都是微服务开发，每个微服务对应了一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。</p>
<p><strong>面试官</strong>：那你之前使用过水平分库吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，这个是使用过的，我们当时的业务是(xxx)，一开始，我们也是单库，后来这个业务逐渐发展，业务量上来的很迅速，其中(xx)表已经存放了超过1000万的数据，我们做了很多优化也不好使，性能依然很慢，所以当时就使用了水平分库。</p>
<p>我们一开始先做了3台服务器对应了3个数据库，由于库多了，需要分片，我们当时采用的mycat来作为数据库的中间件。数据都是按照id（自增）取模的方式来存取的。</p>
<p>当然一开始的时候，那些旧数据，我们做了一些清洗的工作，我们也是按照id取模规则分别存储到了各个数据库中，好处就是可以让各个数据库分摊存储和读取的压力，解决了我们当时性能的问题</p>
</blockquote>
<h2 id="框架篇面试题-参考回答"><a href="#框架篇面试题-参考回答" class="headerlink" title="框架篇面试题-参考回答"></a>框架篇面试题-参考回答</h2><blockquote>
<h5 id="面试官：Spring框架中的单例bean是线程安全的吗？"><a href="#面试官：Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="面试官：Spring框架中的单例bean是线程安全的吗？"></a><strong>面试官</strong>：Spring框架中的单例bean是线程安全的吗？</h5><p><strong>候选人</strong>：</p>
<p>嗯！</p>
<p>不是线程安全的，是这样的</p>
<p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑（成员方法），如果该处理逻辑中有对该单列状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。</p>
<p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。</p>
<p>比如：我们通常在项目中使用的Spring bean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。</p>
<p>如果你的bean有多种状态的话（比如 View Model对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“<strong>singleton</strong>”变更为“<strong>prototype</strong>”。</p>
<p><strong>面试官</strong>：什么是AOP</p>
<p><strong>候选人</strong>：</p>
<p>aop是面向切面编程，在spring中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为公共日志保存，事务处理等</p>
<p><strong>面试官</strong>：你们项目中有没有使用到AOP</p>
<p><strong>候选人</strong>：</p>
<p>我们当时在后台管理系统中，就是使用aop来记录了系统的操作日志</p>
<p>主要思路是这样的，使用aop中的环绕通知+切点表达式，这个表达式就是要找到要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，比如类信息、方法信息、注解、请求方式等，获取到这些参数以后，保存到数据库</p>
<p><strong>面试官</strong>：Spring中的事务是如何实现的</p>
<p><strong>候选人</strong>：</p>
<p>spring实现的事务本质就是aop完成，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<p><strong>面试官</strong>：Spring中事务失效的场景有哪些</p>
<p><strong>候选人</strong>：</p>
<p>嗯！这个在项目中之前遇到过，我想想啊</p>
<p>第一个，如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了跑出去就行了</p>
<p>第二个，如果方法抛出检查异常，如果报错也会导致事务失效，最后在spring事务的注解上，就是@Transactional上配置rollbackFor属性为Exception，这样别管是什么异常，都会回滚事务</p>
<p>第三，我之前还遇到过一个，如果方法上不是public修饰的，也会导致事务失效</p>
<p>嗯，就能想起来那么多</p>
<p><strong>面试官</strong>：Spring的bean的生命周期</p>
<p><strong>候选人</strong>：</p>
<p>嗯！，这个步骤还是挺多的，我之前看过一些源码，它大概流程是这样的</p>
<p>首先会通过一个非常重要的类，叫做BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等这些信息</p>
<p>在创建bean的时候，第一步是调用构造函数实例化bean</p>
<p>第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成</p>
<p>第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行</p>
<p>第四步是bean的后置处理器BeanPostProcessor，这个是前置处理器</p>
<p>第五步是初始化方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct</p>
<p>第六步是执行了bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象</p>
<p>最后一步是销毁bean</p>
<p><strong>面试官</strong>：Spring中的循环引用</p>
<p><strong>候选人</strong>：</p>
<p>嗯，好的，我来解释一下</p>
<p>循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A</p>
<p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p>
<p>①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</p>
<p>②二级缓存：缓存早期的bean对象（生命周期还没走完）</p>
<p>③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p>
<p><strong>面试官</strong>：那具体解决流程清楚吗？</p>
<p><strong>候选人</strong>：</p>
<p>第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories  </p>
<p>第二，A在初始化的时候需要B对象，这个走B的创建的逻辑</p>
<p>第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories  </p>
<p>第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键</p>
<p>第五，B通过从通过二级缓存earlySingletonObjects  获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects  </p>
<p>第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一次缓存singletonObjects </p>
<p>第七，二级缓存中的临时对象A清除 </p>
<p><strong>面试官</strong>：构造方法出现了循环依赖怎么解决？</p>
<p><strong>候选人</strong>：</p>
<p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入，可以使用@Lazy懒加载，什么时候需要对象再进行bean对象的创建</p>
<p><strong>面试官</strong>：SpringMVC的执行流程知道嘛</p>
<p><strong>候选人</strong>：</p>
<p>嗯，这个知道的，它分了好多步骤</p>
<p>1、用户发送出请求到前端控制器DispatcherServlet，这是一个调度中心</p>
<p>2、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。</p>
<p>3、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p>
<p>4、DispatcherServlet调用HandlerAdapter（处理器适配器）。</p>
<p>5、HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）。</p>
<p>6、Controller执行完成返回ModelAndView对象。</p>
<p>7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</p>
<p>8、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。</p>
<p>9、ViewReslover解析后返回具体View（视图）。</p>
<p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p>
<p>11、DispatcherServlet响应用户。</p>
<p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接结果返回</p>
<p><strong>面试官</strong>：Springboot自动配置原理</p>
<p><strong>候选人</strong>：</p>
<p>嗯，好的，它是这样的。</p>
<p>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p>
<ul>
<li><p>@SpringBootConfiguration</p>
</li>
<li><p>@EnableAutoConfiguration</p>
</li>
<li><p>@ComponentScan</p>
</li>
</ul>
<p>其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。 </p>
<p>该注解通过<code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的Jar包的的classpath路径下<strong>META-INF&#x2F;spring.factories</strong>文件中的所配置的类的全类名。 </p>
<p>在这些配置类中所定义的Bean会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到Spring容器中。</p>
<p>一般条件判断会有像<code>@ConditionalOnClass</code>这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p>
<p><strong>面试官</strong>：Spring 的常见注解有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，这个就很多了</p>
<p>第一类是：声明bean，有@Component、@Service、@Repository、@Controller</p>
<p>第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse</p>
<p>第三类是：设置作用域 @Scope</p>
<p>第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和 @Bean </p>
<p>第五类是：跟aop相关做增强的注解  @Aspect，@Before，@After，@Around，@Pointcut</p>
<p><strong>面试官</strong>：SpringMVC常见的注解有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，这个也很多的</p>
<p>有@RequestMapping：用于映射请求路径；</p>
<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象；</p>
<p>@RequestParam：指定请求参数的名称；</p>
<p>@PathViriable：从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数；@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户端。@RequestHeader：获取指定的请求头数据，还有像@PostMapping、@GetMapping这些。</p>
<p><strong>面试官</strong>：Springboot常见注解有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~</p>
<p>Spring Boot的核心注解是@SpringBootApplication , 他由几个注解组成 : </p>
<ul>
<li>@SpringBootConfiguration： 组合了- @Configuration注解，实现配置文件的功能；</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</li>
<li>@ComponentScan：Spring组件扫描</li>
</ul>
<p><strong>面试官</strong>：MyBatis执行流程</p>
<p><strong>候选人</strong>：</p>
<p>好，这个知道的，不过步骤也很多</p>
<p>①读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</p>
<p>②构造会话工厂SqlSessionFactory，一个项目只需要一个，单例的，一般由spring进行管理</p>
<p>③会话工厂创建SqlSession对象，这里面就含了执行SQL语句的所有方法</p>
<p>④操作数据库的接口，Executor执行器，同时负责查询缓存的维护</p>
<p>⑤Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</p>
<p>⑥输入参数映射</p>
<p>⑦输出结果映射</p>
<p><strong>面试官</strong>：Mybatis是否支持延迟加载？</p>
<p><strong>候选人</strong>：</p>
<p>是支持的~</p>
<p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p>
<p>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</p>
<p>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认是关闭的</p>
<p><strong>面试官</strong>：延迟加载的底层原理知道吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，我想想啊</p>
<p>延迟加载在底层主要使用的CGLIB动态代理完成的</p>
<p>第一是，使用CGLIB创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的mapper</p>
<p>第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，再执行sql查询</p>
<p>第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p>
<p><strong>面试官</strong>：Mybatis的一级、二级缓存用过吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，用过的~</p>
<p>mybatis的一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p>
<p>关于二级缓存需要单独开启</p>
<p>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储。</p>
<p>如果想要开启二级缓存需要在全局配置文件和映射文件中开启配置才行。</p>
<p><strong>面试官</strong>：Mybatis的二级缓存什么时候会清理缓存中的数据</p>
<p><strong>候选人</strong>：</p>
<p>嗯！！</p>
<p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
</blockquote>
<h2 id="微服务面试题"><a href="#微服务面试题" class="headerlink" title="微服务面试题"></a>微服务面试题</h2><blockquote>
<p><strong>面试官：</strong>Spring Cloud 5大组件有哪些？</p>
<p><strong>候选人：</strong></p>
<p>早期我们一般认为的Spring Cloud五大组件是 </p>
<ul>
<li>Eureka   : 注册中心</li>
<li>Ribbon  : 负载均衡</li>
<li>Feign     : 远程调用</li>
<li>Hystrix :  服务熔断</li>
<li>Zuul&#x2F;Gateway  : 网关</li>
</ul>
<p>随着SpringCloudAlibba在国内兴起 , 我们项目中使用了一些阿里巴巴的组件 </p>
<ul>
<li><p>注册中心&#x2F;配置中心 Nacos</p>
</li>
<li><p>负载均衡 Ribbon</p>
</li>
<li><p>服务调用 Feign</p>
</li>
<li><p>服务保护 sentinel</p>
</li>
<li><p>服务网关 Gateway</p>
</li>
</ul>
<p><strong>面试官：</strong>服务注册和发现是什么意思？Spring Cloud 如何实现服务注册发现？</p>
<p><strong>候选人：</strong></p>
<p>我理解的是主要三块大功能，分别是服务注册 、服务发现、服务状态监控</p>
<p>我们当时项目采用的eureka作为注册中心，这个也是spring cloud体系中的一个核心组件</p>
<p><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等</p>
<p><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</p>
<p><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除</p>
<p><strong>面试官：</strong>我看你之前也用过nacos、你能说下nacos与eureka的区别？</p>
<p><strong>候选人：</strong></p>
<p>我们当时xx项目就是采用的nacos作为注册中心，选择nacos还要一个重要原因就是它支持配置中心，不过nacos作为注册中心，也比eureka要方便好用一些，主要相同不同点在于几点：</p>
<ul>
<li>共同点</li>
</ul>
<p>Nacos与eureka都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测</p>
<ul>
<li>Nacos与Eureka的区别</li>
</ul>
<p>①Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</p>
<p>②临时实例心跳不正常会被剔除，非临时实例则不会被剔除</p>
<p>③Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</p>
<p>④Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</p>
<p><strong>面试官：</strong>你们项目负载均衡如何实现的 ? </p>
<p><strong>候选人：</strong></p>
<p>是这样~~</p>
<p>在服务调用过程中的负载均衡一般使用SpringCloud的Ribbon 组件实现  , Feign的底层已经自动集成了Ribbon  , 使用起来非常简单</p>
<p>当发起远程调用时，ribbon先从注册中心拉取服务地址列表，然后按照一定的路由策略选择一个发起远程调用，一般的调用策略是轮询</p>
<p><strong>面试官：</strong>Ribbon负载均衡策略有哪些 ? </p>
<p><strong>候选人：</strong></p>
<p>我想想啊，有很多种，我记得几个：</p>
<ul>
<li><p>RoundRobinRule：简单轮询服务列表来选择服务器</p>
</li>
<li><p>WeightedResponseTimeRule：按照权重来选择服务器，响应时间越长，权重越小</p>
</li>
<li><p>RandomRule：随机选择一个可用的服务器</p>
</li>
<li><p>ZoneAvoidanceRule：区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询(默认)</p>
</li>
</ul>
<p><strong>面试官：</strong>如果想自定义负载均衡策略如何实现 ? </p>
<p><strong>候选人：</strong></p>
<p>提供了两种方式：</p>
<p>1，创建类实现IRule接口，可以指定负载均衡策略，这个是全局的，对所有的远程调用都起作用</p>
<p>2，在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略，只是对配置的这个服务生效远程调用</p>
<p><strong>面试官：</strong>什么是服务雪崩，怎么解决这个问题？</p>
<p><strong>候选人：</strong></p>
<p>服务雪崩是指一个服务失败，导致整条链路的服务都失败的情形，一般我们在项目解决的话就是两种方案，第一个是服务降级，第二个是服务熔断，如果流量太大的话，可以考虑限流</p>
<p>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑</p>
<p>服务熔断：默认关闭，需要手动打开，如果检测到 10 秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>
<p><strong>面试官：</strong>你们的微服务是怎么监控的？</p>
<p><strong>候选人：</strong></p>
<p>我们项目中采用的skywalking进行监控的</p>
<p>1，skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</p>
<p>2，我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</p>
<p><strong>面试官：</strong>你们项目中有没有做过限流 ? 怎么做的 ?</p>
<p><strong>候选人：</strong></p>
<p>我当时做的xx项目，采用就是微服务的架构，因为xx因为，应该会有突发流量，最大QPS可以达到2000，但是服务支撑不住，我们项目都通过压测最多可以支撑1200QPS。因为我们平时的QPS也就不到100，为了解决这些突发流量，所以采用了限流。</p>
<p>【版本1】</p>
<p>我们当时采用的nginx限流操作，nginx使用的漏桶算法来实现过滤，让请求以固定的速率处理请求，可以应对突发流量，我们控制的速率是按照ip进行限流，限制的流量是每秒20</p>
<p>【版本2】</p>
<p>我们当时采用的是spring cloud gateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法，可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</p>
<p><strong>面试官：</strong>限流常见的算法有哪些呢？</p>
<p><strong>候选人：</strong></p>
<p>比较常见的限流算法有漏桶算法和令牌桶算法</p>
<p>漏桶算法是把请求存入到桶中，以固定速率从桶中流出，可以让我们的服务做到绝对的平均，起到很好的限流效果</p>
<p>令牌桶算法在桶中存储的是令牌，按照一定的速率生成令牌，每个请求都要先申请令牌，申请到令牌以后才能正常请求，也可以起到很好的限流作用</p>
<p>它们的区别是，漏桶和令牌桶都可以处理突发流量，其中漏桶可以做到绝对的平滑，令牌桶有可能会产生突发大量请求的情况，一般nginx限流采用的漏桶，spring cloud gateway中可以支持令牌桶算法</p>
<p><strong>面试官</strong>：什么是CAP理论？</p>
<p><strong>候选人</strong>：</p>
<p>CAP主要是在分布式项目下的一个理论。包含了三项，一致性、可用性、分区容错性</p>
<ul>
<li><p>一致性(Consistency)是指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致(强一致性)，不能存在中间状态。</p>
</li>
<li><p>可用性(Availability) 是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
</li>
<li><p>分区容错性(Partition tolerance) 是指分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
</li>
</ul>
<p><strong>面试官</strong>：为什么分布式系统中无法同时保证一致性和可用性？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的~~</p>
<p>首先一个前提，对于分布式系统而言，分区容错性是一个最基本的要求，因此基本上我们在设计分布式系统的时候只能从一致性（C）和可用性（A）之间进行取舍。</p>
<p>如果保证了一致性（C）：对于节点N1和N2，当往N1里写数据时，N2上的操作必须被暂停，只有当N1同步数据到N2时才能对N2进行读写请求，在N2被暂停操作期间客户端提交的请求会收到失败或超时。显然，这与可用性是相悖的。</p>
<p>如果保证了可用性（A）：那就不能暂停N2的读写操作，但同时N1在写数据的话，这就违背了一致性的要求。</p>
<p><strong>面试官</strong>：什么是BASE理论？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，这个也是CAP分布式系统设计理论</p>
<p>BASE是CAP理论中AP方案的延伸，核心思想是即使无法做到强一致性（StrongConsistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。它的思想包含三方面：</p>
<p>1、Basically Available（基本可用）：基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。</p>
<p>2、Soft state（软状态）：即是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<p>3、Eventually consistent（最终一致性）：强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p><strong>面试官：</strong>你们采用哪种分布式事务解决方案？</p>
<p><strong>候选人：</strong></p>
<p>我们当时是xx项目，主要使用到的seata的at模式解决的分布式事务</p>
<p>seata的AT模型分为两个阶段：</p>
<p>1、阶段一RM的工作：① 注册分支事务  ② 记录undo-log（数据快照）③ 执行业务sql并提交 ④报告事务状态</p>
<p>2、阶段二提交时RM的工作：删除undo-log即可</p>
<p>3、阶段二回滚时RM的工作：根据undo-log恢复数据到更新前</p>
<p>at模式牺牲了一致性，保证了可用性，不过，它保证的是最终一致性</p>
<p><strong>面试官：</strong>分布式服务的接口幂等性如何设计？</p>
<p><strong>候选人：</strong></p>
<p>嗯，我们当时有一个xx项目的下单操作，采用的token+redis实现的，流程是这样的</p>
<p>第一次请求，也就是用户打开了商品详情页面，我们会发起一个请求，在后台生成一个唯一token存入redis，key就是用户的id，value就是这个token，同时把这个token返回前端</p>
<p>第二次请求，当用户点击了下单操作会后，会携带之前的token，后台先到redis进行验证，如果存在token，可以执行业务，同时删除token；如果不存在，则直接返回，不处理业务，就保证了同一个token只处理一次业务，就保证了幂等性</p>
<p><strong>面试官：</strong>xxl-job路由策略有哪些？</p>
<p><strong>候选人：</strong></p>
<p>xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…</p>
<p><strong>面试官：</strong>xxl-job任务执行失败怎么解决？</p>
<p><strong>候选人：</strong></p>
<p>有这么几个操作</p>
<p>第一：路由策略选择故障转移，优先使用健康的实例来执行任务</p>
<p>第二，如果还有失败的，我们在创建任务时，可以设置重试次数</p>
<p>第三，如果还有失败的，就可以查看日志或者配置邮件告警来通知相关负责人解决</p>
<p><strong>面试官：</strong>如果有大数据量的任务同时都需要执行，怎么解决？</p>
<p><strong>候选人：</strong></p>
<p>我们会让部署多个实例，共同去执行这些批量的任务，其中任务的路由策略是分片广播</p>
<p>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行就可以了</p>
</blockquote>
<h1 id="Java集合相关面试题"><a href="#Java集合相关面试题" class="headerlink" title="Java集合相关面试题"></a>Java集合相关面试题</h1><h2 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h2><p>这次课程主要涉及到的是List和Map相关的面试题，比较高频就是</p>
<ul>
<li><p>ArrayList</p>
</li>
<li><p>LinkedList</p>
</li>
<li><p>HashMap</p>
</li>
<li><p>ConcurrentHashMap</p>
</li>
</ul>
<img src="images/img/image-20230427162524322.png" alt="image-20230427162524322" style="zoom:50%;" />

<ul>
<li>ArrayList底层实现是数组</li>
<li>LinkedList底层实现是双向链表</li>
<li>HashMap的底层实现使用了众多数据结构，包含了数组、链表、散列表、红黑树等</li>
</ul>
<p>在讲解这些集合之后，我们会讲解数据结构，知道了数据结构的特点之后，熟悉集合就更加简单了。在讲解数据结构之前，我们也会简单普及一下算法复杂度分析，让大家能够评判代码的好坏，也能更加深入去理解数据结构和集合。</p>
<h2 id="1-算法复杂度分析"><a href="#1-算法复杂度分析" class="headerlink" title="1 算法复杂度分析"></a>1 算法复杂度分析</h2><h3 id="1-1-为什么要进行复杂度分析？"><a href="#1-1-为什么要进行复杂度分析？" class="headerlink" title="1.1 为什么要进行复杂度分析？"></a>1.1 为什么要进行复杂度分析？</h3><p>我们先来看下面这个代码，你能评判这个代码的好坏吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** *求**1~n**的累加和</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@param</span>* *n</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     sum = sum + i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实学习算法复杂度的好处就是：</p>
<ul>
<li><p>指导你编写出性能更优的代码</p>
</li>
<li><p>评判别人写的代码的好坏</p>
</li>
</ul>
<blockquote>
<p>相信你学完了算法复杂度分析，就有能力评判上面代码的好坏了</p>
</blockquote>
<p>关于算法复杂度分析，包含了两个内容，一个是时间复杂度，一个是空间复杂度，通常情况下说复杂度，都是指时间复杂度，我们也会重点讲解时间复杂度</p>
<h3 id="1-2-时间复杂度"><a href="#1-2-时间复杂度" class="headerlink" title="1.2 时间复杂度"></a>1.2 时间复杂度</h3><h4 id="1-2-1-案例"><a href="#1-2-1-案例" class="headerlink" title="1.2.1 案例"></a>1.2.1 案例</h4><p>时间复杂度分析：简单来说就是评估代码的执行耗时的，大家还是看刚才的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ** *求**1~n**的累加和</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@param</span>* *n</span></span><br><span class="line"><span class="comment"> ** <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     sum = sum + i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这个代码的时间复杂度，分析过程如下：</p>
<p>1.假如每行代码的执行耗时一样：1ms</p>
<p>2.分析这段代码总执行多少行？3n+3</p>
<p>3.代码耗时总时间： T(n) &#x3D; (3n + 3) * 1ms</p>
<blockquote>
<p>T(n):就是代码总耗时</p>
</blockquote>
<p>我们现在有了总耗时，需要借助大O表示法来计算这个代码的时间复杂度</p>
<h4 id="1-2-2-大O表示法"><a href="#1-2-2-大O表示法" class="headerlink" title="1.2.2 大O表示法"></a>1.2.2 大O表示法</h4><p><strong>大O表示法</strong>：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>。</p>
<p>刚才的代码示例总耗时公式为：T(n) &#x3D; (3n + 3) * 1ms</p>
<blockquote>
<p>其中 (3n + 3) 是代码的总行数，每行执行的时间都一样，所以得出结论：</p>
<p><strong>T(n)与代码的执行次数成正比(代码行数越多，执行时间越长)</strong></p>
</blockquote>
<p>不过，大O表示法只需要代码执行时间与数据规模的增长趋势，公式可以简化如下：</p>
<p>T(n) &#x3D;O(3n + 3)————&gt; T(n) &#x3D; O(n)</p>
<blockquote>
<p>当n很大时，公式中的低阶，常量，系数三部分并不左右其增长趋势，因此可以忽略，我们只需要记录一个最大的量级就可以了</p>
</blockquote>
<p>下图也能表明数据的趋势</p>
<p><img src="/blog/images/img/image-20230427173120668.png" alt="image-20230427173120668"></p>
<h4 id="1-2-3-常见复杂度表示形式"><a href="#1-2-3-常见复杂度表示形式" class="headerlink" title="1.2.3 常见复杂度表示形式"></a>1.2.3 常见复杂度表示形式</h4><p><img src="/blog/images/img/image-20230427173742389.png" alt="image-20230427173742389"></p>
<p>速记口诀：<strong>常对幂指阶</strong></p>
<p>越在上面的性能就越高，越往下性能就越低</p>
<p>下图是一些比较常见时间复杂度的时间与数据规模的趋势：</p>
<p><img src="/blog/images/img/image-20230427173937663.png" alt="image-20230427173937663"></p>
<h4 id="1-2-4-时间复杂度O-1"><a href="#1-2-4-时间复杂度O-1" class="headerlink" title="1.2.4 时间复杂度O(1)"></a>1.2.4 时间复杂度O(1)</h4><p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test01</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码只有三行，它的复杂度也是O(1)，而不是O(3)</p>
<p>再看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个代码中因为循环次数是固定的就是100次，这样的代码复杂度我们认为也是O(1)</p>
<p>一句话总结：<strong>只要代码的执行时间不随着n的增大而增大，这样的代码复杂度都是O(1)</strong></p>
<h4 id="1-2-5-时间复杂度O-n"><a href="#1-2-5-时间复杂度O-n" class="headerlink" title="1.2.5 时间复杂度O(n)"></a>1.2.5 时间复杂度O(n)</h4><p>实例代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求1~n的累加和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一层for循序时间复杂度就是O(n)</p>
<p>实例代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            sum = sum + i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码的执行行数为：O( 3n^2  + 3n + 3 )，不过，依据大O表示的规则：<strong>常量、系数、低阶，可以忽略</strong></p>
<p>所以这个代码最终的时间复杂度为：O(n^2)</p>
<h4 id="1-2-6-时间复杂度O-logn"><a href="#1-2-6-时间复杂度O-logn" class="headerlink" title="1.2.6 时间复杂度O(logn)"></a>1.2.6 时间复杂度O(logn)</h4><p>对数复杂度非常的常见，但相对比较难以分析，实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这个代码的复杂度，我们必须要再强调一个前提：<strong>复杂度分析就是要弄清楚代码的执行次数和数据规模n之间的关系</strong></p>
<p>以上代码最关键的一行是：<code>i = i * 2</code>，这行代码可以决定这个while循环执行代码的行数，<code>i</code>的值是可以无限接近<code>n</code>的值的。如果<code>i</code> 一旦大于等于了<code>n</code>则循环条件就不满足了。也就说达到了最大的行数。我们可以分析一下<code>i</code>这个值变化的过程</p>
<p>分析过程如下：</p>
<p><img src="/blog/images/img/image-20230427174832858.png" alt="image-20230427174832858"></p>
<p>由此可知，代码的时间复杂度表示为O(log n)</p>
<h4 id="1-2-7-时间复杂度O-n-log-n"><a href="#1-2-7-时间复杂度O-n-log-n" class="headerlink" title="1.2.7 时间复杂度O(n * log n)"></a>1.2.7 时间复杂度O(n * log n)</h4><p>分析完O( log n )，那O( n * log n )就很容易理解了，比如下列代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        test04(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-空间复杂度"><a href="#1-3-空间复杂度" class="headerlink" title="1.3 空间复杂度"></a>1.3 空间复杂度</h3><p>空间复杂度全称是渐进空间复杂度，表示算法占用的额外<strong>存储空间</strong>与<strong>数据规模</strong>之间的增长关系</p>
<p>看下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行并不需要占用额外的存储空间，只需要常量级的内存空间大小，因此空间复杂度是O(1)</p>
<p>再来看一个其他例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">        a[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        System.out.println(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入一个变量n，决定申请多少的int数组空间内存，此段代码的空间复杂度为O(n)</p>
<p>我们常见的空间复杂度就是O(1),O(n),O(n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。</p>
<h2 id="2-List相关面试题"><a href="#2-List相关面试题" class="headerlink" title="2 List相关面试题"></a>2 List相关面试题</h2><h3 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h3><h4 id="2-1-1-数组概述"><a href="#2-1-1-数组概述" class="headerlink" title="2.1.1 数组概述"></a>2.1.1 数组概述</h4><p>数组（Array）是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数据的线性数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">88</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20230427175545402.png" alt="image-20230427175545402"></p>
<p>我们定义了这么一个数组之后，在内存的表示是这样的：</p>
<p><img src="/blog/images/img/image-20230427175633253.png" alt="image-20230427175633253"></p>
<p>现在假如，我们通过<code>arrar[1]</code>，想要获得下标为1这个元素，但是现在栈内存中指向的堆内存数组的首地址，它是如何获取下标为1这个数据的？</p>
<p><img src="/blog/images/img/image-20230427175849493.png" alt="image-20230427175849493"></p>
<h4 id="2-1-2-寻址公式"><a href="#2-1-2-寻址公式" class="headerlink" title="2.1.2 寻址公式"></a>2.1.2 寻址公式</h4><p>为了方便大家理解，我们把数组的内存地址稍微改了一下，都改成了数字，如下图</p>
<p><img src="/blog/images/img/image-20230427180056509.png" alt="image-20230427180056509"></p>
<p>在数组在内存中查找元素的时候，是有一个寻址公式的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] = baseAddress + i * dataTypeSize</span><br></pre></td></tr></table></figure>

<blockquote>
<p>baseAddress：数组的首地址，目前是10</p>
<p>dataTypeSize：代表数组中元素类型的大小，目前数组重存储的是int型的数据，dataTypeSize&#x3D;4个字节</p>
<p>arr：指的是数组</p>
<p>i：指的是数组的下标</p>
</blockquote>
<p>有了寻址公式以后，我们再来获取一下下标为1的元素，这个是原来的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">88</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>套入公式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array[<span class="number">1</span>] =<span class="number">10</span> + i * <span class="number">4</span> = <span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>获取到14这个地址，就能获取到下标为1的这个元素了。</p>
<h4 id="2-1-3-操作数组的时间复杂度"><a href="#2-1-3-操作数组的时间复杂度" class="headerlink" title="2.1.3 操作数组的时间复杂度"></a>2.1.3 操作数组的时间复杂度</h4><p><strong>1.随机查询(根据索引查询)</strong></p>
<p>数组元素的访问是通过下标来访问的，计算机通过数组的<strong>首地址</strong>和<strong>寻址公式</strong>能够很快速的找到想要访问的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test01</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a[i];</span><br><span class="line">   <span class="comment">// a[i] = baseAddress + i \* dataSize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的执行次数并不会随着数组的数据规模大小变化而变化，是常数级的，所以查询数据操作的时间复杂度是O(1)</p>
<p><strong>2. 未知索引查询O(n)或O(log2n)</strong></p>
<p>情况一：查找数组内的元素，查找55号数据，遍历数组时间复杂度为O(n)</p>
<p><img src="/blog/images/img/image-20221007101831281.png" alt="image-20221007101831281"></p>
<p>情况二：查找排序后数组内的元素，通过二分查找算法查找55号数据时间复杂度为O(logn)</p>
<p><img src="/blog/images/img/image-20221007101811885.png" alt="image-20221007101811885"></p>
<p><strong>3.插入O(n)</strong></p>
<p>数组是一段连续的内存空间，因此为了保证数组的连续性会使得数组的插入和删除的效率变的很低。</p>
<p>假设数组的长度为 n，现在如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。如下图所示：</p>
<p><img src="/blog/images/img/image-20220820104903422.png" alt="image-20220820104903422"></p>
<p>新增之后的数据变化，如下</p>
<p><img src="/blog/images/img/image-20220820104950846.png" alt="image-20220820104950846"></p>
<p>所以：</p>
<p>插入操作，最好情况下是O(1)的，最坏情况下是O(n)的，**平均情况下的时间复杂度是O(n)**。</p>
<p><strong>4.删除O(n)</strong></p>
<p>同理可得：如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了，时间复杂度仍然是O(n)。</p>
<h3 id="2-2-ArrayList源码分析"><a href="#2-2-ArrayList源码分析" class="headerlink" title="2.2 ArrayList源码分析"></a>2.2 ArrayList源码分析</h3><p>分析ArrayList源码主要从三个方面去翻阅：成员变量，构造函数，关键方法</p>
<blockquote>
<p>以下源码都来源于jdk1.8</p>
</blockquote>
<h4 id="2-2-1-成员变量"><a href="#2-2-1-成员变量" class="headerlink" title="2.2.1 成员变量"></a>2.2.1 成员变量</h4><p><img src="/blog/images/img/image-20230427192118259.png" alt="image-20230427192118259"></p>
<blockquote>
<p><em>DEFAULT_CAPACITY</em> &#x3D; 10;  默认初始的容量**(CAPACITY)</p>
<p><em>EMPTY_ELEMENTDATA</em> &#x3D; {}; 用于空实例的共享空数组实例</p>
<p><em>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</em> &#x3D; {};用于默认大小的空实例的共享空数组实例</p>
<p>Object[] elementData;  存储元素的数组缓冲区</p>
<p>int size;     ArrayList的大小（它包含的元素数量）</p>
</blockquote>
<h4 id="2-2-2-构造方法"><a href="#2-2-2-构造方法" class="headerlink" title="2.2.2 构造方法"></a>2.2.2 构造方法</h4><p><img src="/blog/images/img/image-20230427192154014.png" alt="image-20230427192154014"></p>
<blockquote>
<ul>
<li><p>第一个构造是带初始化容量的构造函数，可以按照指定的容量初始化数组</p>
</li>
<li><p>第二个是无参构造函数，默认创建一个空集合</p>
</li>
</ul>
</blockquote>
<p><img src="/blog/images/img/image-20230427192200918.png" alt="image-20230427192200918"></p>
<blockquote>
<p>将collection对象转换成数组，然后将数组的地址的赋给elementData</p>
</blockquote>
<h4 id="2-2-3-ArrayList源码分析"><a href="#2-2-3-ArrayList源码分析" class="headerlink" title="2.2.3 ArrayList源码分析"></a>2.2.3 ArrayList源码分析</h4><p>添加数据的流程</p>
<p><img src="/blog/images/img/image-20230427192644244.png" alt="image-20230427192644244"></p>
<p><strong>结论：</strong></p>
<ul>
<li>底层数据结构</li>
</ul>
<p>ArrayList底层是用动态的数组实现的</p>
<ul>
<li>初始容量</li>
</ul>
<p>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</p>
<ul>
<li>扩容逻辑</li>
</ul>
<p>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p>
<ul>
<li><p>添加逻辑</p>
<ul>
<li><p>确保数组已使用长度（size）加1之后足够存下下一个数据 </p>
</li>
<li><p>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p>
</li>
<li><p>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</p>
</li>
<li><p>返回添加成功布尔值。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-4-面试题-ArrayList-list-x3D-new-ArrayList-10-中的list扩容几次"><a href="#2-2-4-面试题-ArrayList-list-x3D-new-ArrayList-10-中的list扩容几次" class="headerlink" title="2.2.4 面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a>2.2.4 面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h4><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p><img src="/blog/images/img/image-20230428185505677.png" alt="image-20230428185505677"></p>
<p>参考回答：</p>
<p> 该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容 </p>
<h4 id="2-2-4-面试题-如何实现数组和List之间的转换"><a href="#2-2-4-面试题-如何实现数组和List之间的转换" class="headerlink" title="2.2.4 面试题-如何实现数组和List之间的转换"></a>2.2.4 面试题-如何实现数组和List之间的转换</h4><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>如下代码：</p>
<p><img src="/blog/images/img/image-20230428185600918.png" alt="image-20230428185600918"></p>
<p>参考回答：</p>
<ul>
<li><p>数组转List ，使用JDK中java.util.Arrays工具类的asList方法</p>
</li>
<li><p>List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</p>
</li>
</ul>
<p>面试官再问：</p>
<p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p>
<p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p>
<p><img src="/blog/images/img/image-20230428185657791.png" alt="image-20230428185657791"></p>
<blockquote>
<p>数组转List受影响</p>
<p>List转数组不受影响</p>
</blockquote>
<p>再答：</p>
<p>1，用Arrays.asList转List后，如果修改了数组内容，list受影响吗</p>
<p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p>
<p>2，List用toArray转数组后，如果修改了List内容，数组受影响吗</p>
<p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p>
<h3 id="2-3-链表"><a href="#2-3-链表" class="headerlink" title="2.3 链表"></a>2.3 链表</h3><h4 id="2-3-1-单向链表"><a href="#2-3-1-单向链表" class="headerlink" title="2.3.1 单向链表"></a>2.3.1 单向链表</h4><ul>
<li><p>链表中的每一个元素称之为结点（Node）</p>
</li>
<li><p>物理存储单元上，非连续、非顺序的存储结构</p>
</li>
<li><p>单向链表：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230428185922776.png" alt="image-20230428185922776"></p>
<p>代码实现参考：</p>
<p><img src="/blog/images/img/image-20230428185945929.png" alt="image-20230428185945929"></p>
<p>链表中的某个节点为B，B的下一个节点为C         表示： B.next&#x3D;&#x3D;C</p>
<h4 id="2-3-2-单向链表时间复杂度分析"><a href="#2-3-2-单向链表时间复杂度分析" class="headerlink" title="2.3.2 单向链表时间复杂度分析"></a>2.3.2 单向链表时间复杂度分析</h4><p>（1）查询操作</p>
<p><img src="/blog/images/img/image-20230428190130901.png" alt="image-20230428190130901"></p>
<ul>
<li><p>只有在查询头节点的时候不需要遍历链表，时间复杂度是O(1)</p>
</li>
<li><p>查询其他结点需要遍历链表，时间复杂度是O(n)</p>
</li>
</ul>
<p>（2）插入和删除操作</p>
<p><img src="/blog/images/img/image-20230428190210915.png" alt="image-20230428190210915"></p>
<ul>
<li>只有在添加和删除头节点的时候不需要遍历链表，时间复杂度是O(1)</li>
<li>添加或删除其他结点需要遍历链表找到对应节点后，才能完成新增或删除节点，时间复杂度是O(n)</li>
</ul>
<h4 id="2-3-3-双向链表"><a href="#2-3-3-双向链表" class="headerlink" title="2.3.3 双向链表"></a>2.3.3 双向链表</h4><p>而双向链表，顾名思义，它支持两个方向</p>
<ul>
<li><p>每个结点不止有一个后继指针 next 指向后面的结点</p>
</li>
<li><p>有一个前驱指针 prev 指向前面的结点</p>
</li>
</ul>
<p>参考代码</p>
<p><img src="/blog/images/img/image-20230428190324752.png" alt="image-20230428190324752"></p>
<p><img src="/blog/images/img/image-20230428190353286.png" alt="image-20230428190353286"></p>
<p>对比单链表：</p>
<ul>
<li><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</p>
</li>
<li><p>支持双向遍历，这样也带来了双向链表操作的灵活性</p>
</li>
</ul>
<h4 id="2-3-4-双向链表时间复杂度分析"><a href="#2-3-4-双向链表时间复杂度分析" class="headerlink" title="2.3.4 双向链表时间复杂度分析"></a>2.3.4 双向链表时间复杂度分析</h4><p><img src="/blog/images/img/image-20230428190450517.png" alt="image-20230428190450517"></p>
<p>（1）查询操作</p>
<ul>
<li><p>查询头尾结点的时间复杂度是O(1)</p>
</li>
<li><p>平均的查询时间复杂度是O(n)</p>
</li>
<li><p>给定节点找前驱节点的时间复杂度为O(1)</p>
</li>
</ul>
<p>（2）增删操作</p>
<ul>
<li><p>头尾结点增删的时间复杂度为O(1)</p>
</li>
<li><p>其他部分结点增删的时间复杂度是 O(n)</p>
</li>
<li><p>给定节点增删的时间复杂度为O(1)</p>
</li>
</ul>
<h4 id="2-3-5-面试题-ArrayList和LinkedList的区别是什么？"><a href="#2-3-5-面试题-ArrayList和LinkedList的区别是什么？" class="headerlink" title="2.3.5 面试题-ArrayList和LinkedList的区别是什么？"></a>2.3.5 面试题-ArrayList和LinkedList的区别是什么？</h4><ul>
<li><p>底层数据结构</p>
<ul>
<li><p>ArrayList 是动态数组的数据结构实现</p>
</li>
<li><p>LinkedList 是双向链表的数据结构实现</p>
</li>
</ul>
</li>
<li><p>操作数据效率</p>
<ul>
<li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li>
<li>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</li>
<li>新增和删除<ul>
<li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p>内存空间占用</p>
<ul>
<li><p>ArrayList底层是数组，内存连续，节省内存</p>
</li>
<li><p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p>
</li>
</ul>
</li>
<li><p>线程安全</p>
<ul>
<li>ArrayList和LinkedList都不是线程安全的</li>
<li>如果需要保证线程安全，有两种方案：<ul>
<li>在方法内使用，局部变量则是线程安全的</li>
<li>使用线程安全的ArrayList和LinkedList</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-HashMap相关面试题"><a href="#3-HashMap相关面试题" class="headerlink" title="3 HashMap相关面试题"></a>3 HashMap相关面试题</h2><p><img src="/blog/images/img/image-20230428194715016.png" alt="image-20230428194715016"></p>
<h3 id="3-1-二叉树"><a href="#3-1-二叉树" class="headerlink" title="3.1 二叉树"></a>3.1 二叉树</h3><h4 id="3-1-1-二叉树概述"><a href="#3-1-1-二叉树概述" class="headerlink" title="3.1.1 二叉树概述"></a>3.1.1 二叉树概述</h4><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>
<p>二叉树每个节点的左子树和右子树也分别满足二叉树的定义。</p>
<p><img src="/blog/images/img/image-20230428194831426.png" alt="image-20230428194831426"></p>
<p>Java中有两个方式实现二叉树：数组存储，链式存储。</p>
<p>基于链式存储的树的节点可定义如下：</p>
<p><img src="/blog/images/img/image-20230428194904383.png" alt="image-20230428194904383"></p>
<p><img src="/blog/images/img/image-20230428194931132.png" alt="image-20230428194931132"></p>
<h4 id="3-1-2-二叉搜索树"><a href="#3-1-2-二叉搜索树" class="headerlink" title="3.1.2 二叉搜索树"></a>3.1.2 二叉搜索树</h4><p>在二叉树中，比较常见的二叉树有：</p>
<ul>
<li><p>满二叉树</p>
</li>
<li><p>完全二叉树</p>
</li>
<li><p><strong>二叉搜索树</strong></p>
</li>
<li><p><strong>红黑树</strong></p>
</li>
</ul>
<p>我们重点讲解二叉搜索树和红黑树</p>
<p>（1）二叉搜索树概述</p>
<p>二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型</p>
<p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p>
<p><img src="/blog/images/img/image-20230428195206422.png" alt="image-20230428195206422"></p>
<p>（2）二叉搜索树-时间复杂度分析</p>
<p>实际上由于二叉查找树的形态各异，时间复杂度也不尽相同，我画了几棵树我们来看一下插入，查找，删除的时间复杂度</p>
<p><img src="/blog/images/img/image-20230428195341917.png" alt="image-20230428195341917"></p>
<p>插入，查找，删除的时间复杂度<strong>O(logn)</strong></p>
<p>极端情况下二叉搜索的时间复杂度</p>
<p><img src="/blog/images/img/image-20230428195449799.png" alt="image-20230428195449799"></p>
<p>对于图中这种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，此时查找的时间复杂度肯定是O(n)。</p>
<h4 id="3-1-3-红黑树"><a href="#3-1-3-红黑树" class="headerlink" title="3.1.3 红黑树"></a>3.1.3 红黑树</h4><p>（1）概述</p>
<p><strong>红黑树（Red Black Tree）</strong>：也是一种自平衡的二叉搜索树(BST)，之前叫做平衡二叉B树（Symmetric Binary B-Tree）</p>
<p><img src="/blog/images/img/image-20230428195832724.png" alt="image-20230428195832724"></p>
<p>（2）红黑树的特质</p>
<p>性质1：节点要么是<strong>红色</strong>,要么是<strong>黑色</strong></p>
<p>性质2：根节点是<strong>黑色</strong></p>
<p>性质3：叶子节点都是黑色的空节点</p>
<p>性质4：红黑树中红色节点的子节点都是黑色</p>
<p>性质5：从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</p>
<p><strong>在添加或删除节点的时候，如果不符合这些性质会发生旋转，以达到所有的性质，保证红黑树的平衡</strong></p>
<p>（3）红黑树的复杂度</p>
<ul>
<li><p>查找：</p>
<ul>
<li>红黑树也是一棵BST（二叉搜索树）树，查找操作的时间复杂度为：O(log n)</li>
</ul>
</li>
<li><p>添加：</p>
<ul>
<li>添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)</li>
<li>添加完成后涉及到复杂度为O(1)的旋转调整操作</li>
<li>故整体复杂度为：O(log n)</li>
</ul>
</li>
<li><p>删除：</p>
<ul>
<li>首先从根节点开始找到被删除元素的位置，时间复杂度O(log n)</li>
<li>删除完成后涉及到复杂度为O(1)的旋转调整操作</li>
<li>故整体复杂度为：O(log n)</li>
</ul>
</li>
</ul>
<h3 id="3-2-散列表"><a href="#3-2-散列表" class="headerlink" title="3.2 散列表"></a>3.2 散列表</h3><p>在HashMap中的最重要的一个数据结构就是散列表，在散列表中又使用到了红黑树和链表</p>
<h4 id="3-2-1-散列表（Hash-Table）概述"><a href="#3-2-1-散列表（Hash-Table）概述" class="headerlink" title="3.2.1 散列表（Hash Table）概述"></a>3.2.1 散列表（Hash Table）概述</h4><p>散列表(Hash Table)又名哈希表&#x2F;Hash表，是根据键（Key）直接访问在内存存储位置值（Value）的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性</p>
<p>举个例子：</p>
<p><img src="/blog/images/img/image-20230428200919454.png" alt="image-20230428200919454"></p>
<p>假设有100个人参加马拉松，编号是1-100，如果要编程实现根据选手的编号迅速找到选手信息？</p>
<p>可以把选手信息存入数组中，选手编号就是数组的下标，数组的元素就是选手的信息。</p>
<p>当我们查询选手信息的时候，只需要根据选手的编号到数组中查询对应的元素就可以快速找到选手的信息，如下图：</p>
<p><img src="/blog/images/img/image-20230428201000814.png" alt="image-20230428201000814"></p>
<p>现在需求升级了：</p>
<p>假设有100个人参加马拉松，不采用1-100的自然数对选手进行编号，编号有一定的规则比如：2023ZHBJ001，其中2023代表年份，ZH代表中国，BJ代表北京，001代表原来的编号，那此时的编号2023ZHBJ001不能直接作为数组的下标，此时应该如何实现呢？</p>
<p><img src="/blog/images/img/image-20230428201321607.png" alt="image-20230428201321607"></p>
<p>我们目前是把选手的信息存入到数组中，不过选手的编号不能直接作为数组的下标，不过，可以把选手的选号进行转换，转换为数值就可以继续作为数组的下标了？</p>
<p>转换可以使用散列函数进行转换</p>
<h4 id="3-2-2-散列函数和散列冲突"><a href="#3-2-2-散列函数和散列冲突" class="headerlink" title="3.2.2 散列函数和散列冲突"></a>3.2.2 散列函数和散列冲突</h4><p>将键(key)映射为数组下标的函数叫做散列函数。可以表示为：hashValue &#x3D; hash(key)</p>
<p>散列函数的基本要求：</p>
<ul>
<li><p>散列函数计算得到的散列值必须是大于等于0的正整数，因为hashValue需要作为数组的下标。</p>
</li>
<li><p>如果key1&#x3D;&#x3D;key2，那么经过hash后得到的哈希值也必相同即：hash(key1) &#x3D;&#x3D; hash(key2）</p>
</li>
<li><p><strong>如果key1 !&#x3D; key2，那么经过hash后得到的哈希值也必不相同即：hash(key1) !&#x3D; hash(key2)</strong></p>
</li>
</ul>
<p>实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值都不同几乎是不可能的，即便像著名的MD5,SHA等哈希算法也无法避免这一情况，这就是散列冲突(或者哈希冲突，哈希碰撞，<strong>就是指多个key映射到同一个数组下标位置</strong>)</p>
<p><img src="/blog/images/img/image-20230428203219225.png" alt="image-20230428203219225"></p>
<h4 id="3-2-3-散列冲突-链表法（拉链）"><a href="#3-2-3-散列冲突-链表法（拉链）" class="headerlink" title="3.2.3 散列冲突-链表法（拉链）"></a>3.2.3 散列冲突-链表法（拉链）</h4><p>在散列表中，数组的每个下标位置我们可以称之为桶（bucket）或者槽（slot），每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p><img src="/blog/images/img/image-20230428203437910.png" alt="image-20230428203437910"></p>
<p>简单就是，如果有多个key最终的hash值是一样的，就会存入数组的同一个下标中，下标中挂一个链表存入多个数据</p>
<h4 id="3-2-4-时间复杂度-散列表"><a href="#3-2-4-时间复杂度-散列表" class="headerlink" title="3.2.4 时间复杂度-散列表"></a>3.2.4 时间复杂度-散列表</h4><p>1，插入操作，通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，插入的时间复杂度是 O(1)</p>
<p><img src="/blog/images/img/image-20230428203711269.png" alt="image-20230428203711269"></p>
<blockquote>
<p>通过计算就可以找到元素</p>
</blockquote>
<p>2，当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除</p>
<ul>
<li><p>平均情况下基于链表法解决冲突时查询的时间复杂度是O(1)</p>
</li>
<li><p>散列表可能会退化为链表,查询的时间复杂度就从 O(1) 退化为 O(n)</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230428203858903.png" alt="image-20230428203858903"></p>
<ul>
<li>将链表法中的链表改造为其他高效的动态数据结构，比如红黑树，查询的时间复杂度是 O(logn)</li>
</ul>
<p><img src="/blog/images/img/image-20230428203924816.png" alt="image-20230428203924816"></p>
<p>将链表法中的链表改造红黑树还有一个非常重要的原因，可以防止DDos攻击</p>
<blockquote>
<p>DDos 攻击:</p>
<p>分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS）</p>
<p>指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个</p>
</blockquote>
<h3 id="3-3-面试题-说一下HashMap的实现原理？"><a href="#3-3-面试题-说一下HashMap的实现原理？" class="headerlink" title="3.3 面试题-说一下HashMap的实现原理？"></a>3.3 面试题-说一下HashMap的实现原理？</h3><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p>
<ol>
<li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 </p>
</li>
<li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
</li>
</ol>
<p>  a. 如果key相同，则覆盖原始值；</p>
<p>  b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中 </p>
<ol start="3">
<li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li>
</ol>
<p><img src="/blog/images/img/image-20230428204902016.png" alt="image-20230428204902016"></p>
<p>面试官追问：HashMap的jdk1.7和jdk1.8有什么区别</p>
<ul>
<li><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
</li>
<li><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</p>
</li>
</ul>
<h3 id="3-4-面试题-HashMap的put方法的具体流程"><a href="#3-4-面试题-HashMap的put方法的具体流程" class="headerlink" title="3.4 面试题-HashMap的put方法的具体流程"></a>3.4 面试题-HashMap的put方法的具体流程</h3><h4 id="3-4-1-hashMap常见属性"><a href="#3-4-1-hashMap常见属性" class="headerlink" title="3.4.1 hashMap常见属性"></a>3.4.1 hashMap常见属性</h4><p><img src="/blog/images/img/image-20230428210404117.png" alt="image-20230428210404117"></p>
<h4 id="3-4-2-源码分析"><a href="#3-4-2-源码分析" class="headerlink" title="3.4.2 源码分析"></a>3.4.2 源码分析</h4><p><img src="/blog/images/img/image-20230428210450744.png" alt="image-20230428210450744"></p>
<ul>
<li><p>HashMap是懒惰加载，在创建对象时并没有初始化数组</p>
</li>
<li><p>在无参的构造函数中，设置了默认的加载因子是0.75</p>
</li>
</ul>
<p>添加数据流程图</p>
<p><img src="/blog/images/img/image-20230428210624847.png" alt="image-20230428210624847"></p>
<p>具体的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果未初始化，调用resize方法 进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//该数组下标有数据的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是红黑树的话，进行红黑树的操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//新数据和当前数组既不相同，也不是红黑树节点，证明是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//因为新插入了一条数据，所以判断链表长度是不是大于等于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为修改操作</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出老值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//当前数组中的数据数量如果大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//添加操作时 返回空值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p>
</li>
<li><p>根据键值key计算hash值得到数组索引</p>
</li>
<li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p>
</li>
<li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p>
<p>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p>
<p>4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p>
<p>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p>
</li>
<li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</p>
</li>
</ol>
<h3 id="3-5-面试题-讲一讲HashMap的扩容机制"><a href="#3-5-面试题-讲一讲HashMap的扩容机制" class="headerlink" title="3.5 面试题-讲一讲HashMap的扩容机制"></a>3.5 面试题-讲一讲HashMap的扩容机制</h3><p><img src="/blog/images/img/image-20230428210844694.png" alt="image-20230428210844694"></p>
<p>扩容的流程：</p>
<p><img src="/blog/images/img/image-20230428211031968.png" alt="image-20230428211031968"></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    	<span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       			如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    	<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    	Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    	<span class="comment">//赋值</span></span><br><span class="line">    	table = newTab;</span><br><span class="line">    	<span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   	<span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头		   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               	hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p>
</li>
<li><p>每次扩容的时候，都是扩容之前容量的2倍； </p>
</li>
<li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p>
<ul>
<li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li>
<li>如果是红黑树，走红黑树的添加</li>
<li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
</li>
</ul>
<h3 id="3-6-面试题-hashMap的寻址算法"><a href="#3-6-面试题-hashMap的寻址算法" class="headerlink" title="3.6 面试题-hashMap的寻址算法"></a>3.6 面试题-hashMap的寻址算法</h3><p><img src="/blog/images/img/image-20230428212501408.png" alt="image-20230428212501408"></p>
<p>在putVal方法中，有一个hash(key)方法，这个方法就是来去计算key的hash值的，看下面的代码</p>
<p><img src="/blog/images/img/image-20230428212601977.png" alt="image-20230428212601977"></p>
<p>首先获取key的hashCode值，然后右移16位 异或运算 原来的hashCode值，主要作用就是使原来的hash值更加均匀，减少hash冲突</p>
<p>有了hash值之后，就很方便的去计算当前key的在数组中存储的下标，看下面的代码：</p>
<p><img src="/blog/images/img/image-20230428212729580.png" alt="image-20230428212729580"></p>
<p>(n-1)&amp;hash : 得到数组中的索引，代替取模，性能更好，数组长度必须是2的n次幂</p>
<p><strong>关于hash值的其他面试题：为何HashMap的数组长度一定是2的次幂？</strong></p>
<ol>
<li><p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p>
</li>
<li><p>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</p>
</li>
</ol>
<h3 id="3-7-面试题-hashmap在1-7情况下的多线程死循环问题"><a href="#3-7-面试题-hashmap在1-7情况下的多线程死循环问题" class="headerlink" title="3.7 面试题-hashmap在1.7情况下的多线程死循环问题"></a>3.7 面试题-hashmap在1.7情况下的多线程死循环问题</h3><p>jdk7的的数据结构是：数组+链表</p>
<p>在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p>
<p><img src="/blog/images/img/image-20230428213115071.png" alt="image-20230428213115071"></p>
<ul>
<li><p>变量e指向的是需要迁移的对象</p>
</li>
<li><p>变量next指向的是下一个需要迁移的对象</p>
</li>
<li><p>Jdk1.7中的链表采用的头插法</p>
</li>
<li><p>在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用</p>
</li>
</ul>
<p>产生死循环的过程：</p>
<p>线程1和线程2的变量e和next都引用了这个两个节点</p>
<p><img src="/blog/images/img/image-20230428213533483.png" alt="image-20230428213533483"></p>
<p>线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点</p>
<p><img src="/blog/images/img/image-20230428214732877.png" alt="image-20230428214732877"></p>
<p>第一次循环</p>
<p>由于线程2迁移的时候，已经把B的next执行了A</p>
<p><img src="/blog/images/img/image-20230428214806072.png" alt="image-20230428214806072"></p>
<p>第二次循环</p>
<p><img src="/blog/images/img/image-20230428214908652.png" alt="image-20230428214908652"></p>
<p>第三次循环</p>
<p><img src="/blog/images/img/image-20230428214937231.png" alt="image-20230428214937231"></p>
<p>参考回答：</p>
<p>在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p>
<p>比如说，现在有两个线程</p>
<p>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p>
<p>线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p>
<p>线程一：继续执行的时候就会出现死循环的问题。</p>
<p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，</p>
<p>所以B-&gt;A-&gt;B,形成循环。</p>
<p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p>
<h3 id="3-8-面试题-HashSet与HashMap的区别"><a href="#3-8-面试题-HashSet与HashMap的区别" class="headerlink" title="3.8 面试题-HashSet与HashMap的区别"></a>3.8 面试题-HashSet与HashMap的区别</h3><p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p>
<p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p>
<p><img src="/blog/images/img/image-20221007110404375.png" alt="image-20221007110404375"></p>
<h3 id="3-9-面试题-HashTable与HashMap的区别"><a href="#3-9-面试题-HashTable与HashMap的区别" class="headerlink" title="3.9 面试题-HashTable与HashMap的区别"></a>3.9 面试题-HashTable与HashMap的区别</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>主要区别：</p>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>HashTable</strong></th>
<th><strong>HashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>数组+链表</td>
<td>数组+链表+红黑树</td>
</tr>
<tr>
<td>是否可以为null</td>
<td>Key和value都不能为null</td>
<td>可以为null</td>
</tr>
<tr>
<td>hash算法</td>
<td>key的hashCode()</td>
<td>二次hash</td>
</tr>
<tr>
<td>扩容方式</td>
<td>当前容量翻倍 +1</td>
<td>当前容量翻倍</td>
</tr>
<tr>
<td>线程安全</td>
<td>同步(synchronized)的，线程安全</td>
<td>非线程安全</td>
</tr>
</tbody></table>
<p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p>
<h2 id="3-真实面试还原"><a href="#3-真实面试还原" class="headerlink" title="3 真实面试还原"></a>3 真实面试还原</h2><h3 id="3-1-Java常见的集合类"><a href="#3-1-Java常见的集合类" class="headerlink" title="3.1 Java常见的集合类"></a>3.1 Java常见的集合类</h3><blockquote>
<p><strong>面试官</strong>：说一说Java提供的常见集合？（画一下集合结构图）</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，好的。</p>
<p>在java中提供了量大类的集合框架，主要分为两类：</p>
<p>第一个是Collection  属于单列集合，第二个是Map  属于双列集合</p>
<ul>
<li>在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。  在Set接口中有实现类HashSet和TreeSet。</li>
<li>在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap</li>
</ul>
</blockquote>
<h3 id="3-2-List"><a href="#3-2-List" class="headerlink" title="3.2 List"></a>3.2 List</h3><blockquote>
<p><strong>面试官</strong>：ArrayList底层是如何实现的？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~，我阅读过arraylist的源码，我主要说一下add方法吧</p>
<p>第一：确保数组已使用长度（size）加1之后足够存下下一个数据 </p>
<p>第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</p>
<p>第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。 </p>
<p>第四：返回添加成功布尔值。 </p>
<p><strong>面试官</strong>：ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</p>
<p><strong>候选人</strong>：</p>
<p>​	是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)</p>
<p><strong>面试官</strong>：是的</p>
<p><strong>候选人</strong>：</p>
<p>​    好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。</p>
<hr>
<p><strong>面试官</strong>：如何实现数组和List之间的转换</p>
<p><strong>候选人</strong>：</p>
<p>​	嗯，这个在我们平时开发很常见</p>
<p>​    数组转list，可以使用jdk自动的一个工具类Arrars，里面有一个asList方法可以转换为数组</p>
<p>​    List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。</p>
<p><strong>面试官</strong>：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗</p>
<p><strong>候选人</strong>：</p>
<p>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p>
<p>list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p>
<hr>
<p><strong>面试官</strong>：ArrayList 和 LinkedList 的区别是什么？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。</p>
<p>1，从操作数据效率来说</p>
<p>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</p>
<p>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</p>
<p>新增和删除</p>
<ul>
<li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
<p>2，从内存空间占用来说</p>
<p>ArrayList底层是数组，内存连续，节省内存</p>
<p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p>
<p>3，从线程安全来说，ArrayList和LinkedList都不是线程安全的</p>
<p><strong>面试官</strong>：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的，主要有两种解决方案：</p>
<p>第一：我们使用这个集合，优先在方法内使用，定义为局部变量，这样的话，就不会出现线程安全问题。</p>
<p>第二：如果非要在成员变量中使用的话，可以使用线程安全的集合来替代</p>
<p>ArrayList可以通过Collections 的 synchronizedList 方法将 ArrayList 转换成线程安全的容器后再使用。</p>
<p>LinkedList 换成ConcurrentLinkedQueue来使用</p>
</blockquote>
<h3 id="3-4-HashMap"><a href="#3-4-HashMap" class="headerlink" title="3.4 HashMap"></a>3.4 HashMap</h3><blockquote>
<p><strong>面试官</strong>：说一下HashMap的实现原理？</p>
<p><strong>候选人</strong>：</p>
<p>​	嗯。它主要分为了一下几个部分：</p>
<p>1，底层使用hash表数据结构，即数组+（链表 | 红黑树）</p>
<p>2，添加数据时，计算key的值确定元素在数组中的下标</p>
<p>​	key相同则替换</p>
<p>​	不同则存入链表或红黑树中</p>
<p>3，获取数据通过key的hash计算数组下标获取元素</p>
<p><strong>面试官</strong>：HashMap的jdk1.7和jdk1.8有什么区别</p>
<p><strong>候选人</strong>：</p>
<ul>
<li><p>JDK1.8之前采用的拉链法，数组+链表</p>
</li>
<li><p>JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树</p>
</li>
</ul>
<p><strong>面试官</strong>：好的，你能说下HashMap的put方法的具体流程吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯好的。</p>
<ol>
<li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p>
</li>
<li><p>根据键值key计算hash值得到数组索引</p>
</li>
<li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p>
</li>
<li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p>
</li>
</ol>
<p>  4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p>
<p>  4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p>
<p>  4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p>
<ol start="5">
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</li>
</ol>
<p><strong>面试官</strong>：好的，刚才你多次介绍了hsahmap的扩容，能讲一讲HashMap的扩容机制吗？</p>
<p><strong>候选人</strong>：</p>
<p>好的</p>
<ul>
<li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p>
</li>
<li><p>每次扩容的时候，都是扩容之前容量的2倍； </p>
</li>
<li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p>
</li>
<li><p>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</p>
</li>
<li><p>如果是红黑树，走红黑树的添加</p>
</li>
<li><p>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>
</li>
</ul>
<p><strong>面试官</strong>：好的，刚才你说的通过hash计算后找到数组的下标，是如何找到的呢，你了解hashMap的寻址算法吗？</p>
<p><strong>候选人</strong>：</p>
<p>这个哈希方法首先计算出key的hashCode值，然后通过这个hash值右移16位后的二进制进行按位<strong>异或运算</strong>得到最后的hash值。</p>
<p>在putValue的方法中，计算数组下标的时候使用hash值与数组长度取模得到存储数据下标的位置，hashmap为了性能更好，并没有直接采用取模的方式，而是使用了数组长度-1 得到一个值，用这个值按位与运算hash值，最终得到数组的位置。</p>
<p><strong>面试官</strong>：为何HashMap的数组长度一定是2的次幂？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，好的。hashmap这么设计主要有两个原因：</p>
<p>第一：</p>
<p>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</p>
<p>第二：</p>
<p>扩容时重新计算索引效率更高：在进行扩容是会进行判断 hash值按位与运算旧数组长租是否 &#x3D;&#x3D; 0 </p>
<p>如果等于0，则把元素留在原来位置 ，否则新位置是等于旧位置的下标+旧数组长度</p>
<p><strong>面试官</strong>：好的，我看你对hashmap了解的挺深入的，你知道hashmap在1.7情况下的多线程死循环问题吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道的。是这样</p>
<p>jdk7的的数据结构是：数组+链表</p>
<p>在数组进行扩容的时候，因为链表是<strong>头插法</strong>，在进行数据迁移的过程中，有可能导致死循环</p>
<p>比如说，现在有两个线程</p>
<p>线程一：<strong>读取</strong>到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p>
<p>线程二也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。</p>
<p>当线程一再继续执行的时候就会出现死循环的问题。</p>
<p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B-&gt;A-&gt;B,形成循环。</p>
<p>当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），<strong>尾插法</strong>，就避免了jdk7中死循环的问题。</p>
<p><strong>面试官</strong>：好的，hashmap是线程安全的吗？</p>
<p><strong>候选人</strong>：不是线程安全的</p>
<p><strong>面试官</strong>：那我们想要使用线程安全的map该怎么做呢？</p>
<p><strong>候选人</strong>：我们可以采用ConcurrentHashMap进行使用，它是一个线程安全的HashMap</p>
<p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p>
<p><strong>候选人</strong>：好的，请参考《多线程相关面试题》中的ConcurrentHashMap部分的讲解</p>
<hr>
<p><strong>面试官</strong>：HashSet与HashMap的区别？</p>
<p><strong>候选人</strong>：嗯，是这样。</p>
<p>HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p>
<p><strong>面试官</strong>：HashTable与HashMap的区别</p>
<p><strong>候选人</strong>：</p>
<p>嗯，他们的主要区别是有几个吧</p>
<p>第一，数据结构不一样，hashtable是数组+链表，hashmap在1.8之后改为了数组+链表+红黑树</p>
<p>第二，hashtable存储数据的时候都不能为null，而hashmap是可以的</p>
<p>第三，hash算法不同，hashtable是用本地修饰的hashcode值，而hashmap经常了二次hash</p>
<p>第四，扩容方式不同，hashtable是当前容量翻倍+1，hashmap是当前容量翻倍</p>
<p>第五，hashtable是线程安全的，操作数据的时候加了锁synchronized，hashmap不是线程安全的，效率更高一些</p>
<p>在实际开中不建议使用HashTable，在多线程环境下可以使用ConcurrentHashMap类</p>
</blockquote>
<p><code>文档说明</code></p>
<blockquote>
<p>在文档中对所有的面试题都进行了<strong>难易程度</strong>和<strong>出现频率</strong>的等级说明</p>
<p>星数越多代表权重越大，最多五颗星（☆☆☆☆☆） 最少一颗星（☆）</p>
</blockquote>
<h1 id="Java多线程相关面试题"><a href="#Java多线程相关面试题" class="headerlink" title="Java多线程相关面试题"></a>Java多线程相关面试题</h1><h2 id="1-线程的基础知识"><a href="#1-线程的基础知识" class="headerlink" title="1.线程的基础知识"></a>1.线程的基础知识</h2><h3 id="1-1-线程和进程的区别？"><a href="#1-1-线程和进程的区别？" class="headerlink" title="1.1 线程和进程的区别？"></a>1.1 线程和进程的区别？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</p>
<p><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</strong></p>
<p><img src="/blog/images/img/image-20221026105350827.png" alt="image-20221026105350827"></p>
<p>一个进程之内可以分为一到多个线程。</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p>
<p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器</p>
<p><img src="/blog/images/img/image-20221026105442158.png" alt="image-20221026105442158"></p>
<p><strong>二者对比</strong></p>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
<h3 id="1-2-并行和并发有什么区别？"><a href="#1-2-并行和并发有什么区别？" class="headerlink" title="1.2 并行和并发有什么区别？"></a>1.2 并行和并发有什么区别？</h3><blockquote>
<p>难易程度：☆</p>
<p>出现频率：☆</p>
</blockquote>
<p>单核CPU</p>
<ul>
<li><p>单核CPU下线程实际还是串行执行的</p>
</li>
<li><p>操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。</p>
</li>
<li><p>总结为一句话就是： 微观串行，宏观并行</p>
</li>
</ul>
<p>一般会将这种线程轮流使用CPU的做法称为并发（concurrent）</p>
<p><img src="/blog/images/img/image-20230503203246348.png" alt="image-20230503203246348"></p>
<p><img src="/blog/images/img/image-20221026105607248.png" alt="image-20221026105607248"></p>
<p>多核CPU</p>
<p>每个核（core）都可以调度运行线程，这时候线程可以是并行的。</p>
<p><img src="/blog/images/img/image-20230503203330700.png" alt="image-20230503203330700"></p>
<p><strong>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</strong></p>
<p><strong>并行（parallel）是同一时间动手做（doing）多件事情的能力</strong></p>
<blockquote>
<p>举例：</p>
<ul>
<li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p>
</li>
<li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</p>
</li>
<li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p>
</li>
</ul>
</blockquote>
<h3 id="1-3-创建线程的四种方式"><a href="#1-3-创建线程的四种方式" class="headerlink" title="1.3 创建线程的四种方式"></a>1.3 创建线程的四种方式</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程</p>
<p>详细创建方式参考下面代码：</p>
<p>① <strong>继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② <strong>实现runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyRunnable对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ <strong>实现Callable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyCallable...call...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyCallable对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建F</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(mc) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用ft的get方法获取执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④ <strong>线程池创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecutors</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyExecutors</span>()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-runnable-和-callable-有什么区别"><a href="#1-4-runnable-和-callable-有什么区别" class="headerlink" title="1.4 runnable 和 callable 有什么区别"></a>1.4 runnable 和 callable 有什么区别</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<ol>
<li>Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ol>
<h3 id="1-5-线程的-run-和-start-有什么区别？"><a href="#1-5-线程的-run-和-start-有什么区别？" class="headerlink" title="1.5 线程的 run()和 start()有什么区别？"></a>1.5 线程的 run()和 start()有什么区别？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</p>
<p>run(): 封装了要被线程执行的代码，可以被调用多次。</p>
<h3 id="1-6-线程包括哪些状态，状态之间是如何变化的"><a href="#1-6-线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="1.6 线程包括哪些状态，状态之间是如何变化的"></a>1.6 线程包括哪些状态，状态之间是如何变化的</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程的状态可以参考JDK中的Thread类中的枚举State</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尚未启动的线程的线程状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自		 * 操作系统的其他资源，例如处理器。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法或在调          * 用Object.wait后重新进入同步块/方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：</span></span><br><span class="line"><span class="comment">		* Object.wait没有超时</span></span><br><span class="line"><span class="comment">         * 没有超时的Thread.join</span></span><br><span class="line"><span class="comment">         * LockSupport.park</span></span><br><span class="line"><span class="comment">         * 处于等待状态的线程正在等待另一个线程执行特定操作。</span></span><br><span class="line"><span class="comment">         * 例如，一个对对象调用Object.wait()的线程正在等待另一个线程对该对象调用Object.notify()			* 或Object.notifyAll() 。已调用Thread.join()的线程正在等待指定线程终止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定          * 时等待状态：</span></span><br><span class="line"><span class="comment">		* Thread.sleep</span></span><br><span class="line"><span class="comment">		* Object.wait超时</span></span><br><span class="line"><span class="comment">		* Thread.join超时</span></span><br><span class="line"><span class="comment">		* LockSupport.parkNanos</span></span><br><span class="line"><span class="comment">		* LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 已终止线程的线程状态。线程已完成执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>状态之间是如何变化的</p>
<p><img src="/blog/images/img/image-20230503203629212.png" alt="image-20230503203629212"></p>
<p>分别是</p>
<ul>
<li>新建<ul>
<li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li>
<li>此时未与操作系统底层线程关联</li>
</ul>
</li>
<li>可运行<ul>
<li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li>
<li>此时与底层线程关联，由操作系统调度执行</li>
</ul>
</li>
<li>终结<ul>
<li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li>
<li>此时会取消与底层线程关联</li>
</ul>
</li>
<li>阻塞<ul>
<li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li>
<li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li>
</ul>
</li>
<li>等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
<li>有时限等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
</ul>
<h3 id="1-7-新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#1-7-新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>代码举例：</p>
<p>为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();                          <span class="comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();                              <span class="comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-8-notify-和-notifyAll-有什么区别？"><a href="#1-8-notify-和-notifyAll-有什么区别？" class="headerlink" title="1.8 notify()和 notifyAll()有什么区别？"></a>1.8 notify()和 notifyAll()有什么区别？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>notifyAll：唤醒所有wait的线程</p>
<p>notify：只随机唤醒一个 wait 线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hold lock&quot;</span>);</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-在-java-中-wait-和-sleep-方法的不同？"><a href="#1-9-在-java-中-wait-和-sleep-方法的不同？" class="headerlink" title="1.9 在 java 中 wait 和 sleep 方法的不同？"></a>1.9 在 java 中 wait 和 sleep 方法的不同？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>共同点</p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
</ul>
<p>不同点</p>
<ul>
<li><p>方法归属不同</p>
<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p>锁特性不同（重点）</p>
<ul>
<li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li>
<li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li>
<li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitSleepCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sleeping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">illegalWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        LOCK.wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">waiting</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">                    LOCK.wait(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;sleeping...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-10-如何停止一个正在运行的线程？"><a href="#1-10-如何停止一个正在运行的线程？" class="headerlink" title="1.10 如何停止一个正在运行的线程？"></a>1.10 如何停止一个正在运行的线程？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>有三种方式可以停止线程</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止（不推荐，方法已作废）</li>
<li>使用interrupt方法中断线程</li>
</ul>
<p>代码参考如下：</p>
<p>① <strong>使用退出标志，使线程正常退出</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt1</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠6秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改标记为true</span></span><br><span class="line">        t1.flag = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② <strong>使用stop方法强行终止</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt2</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠2秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用stop方法</span></span><br><span class="line">        t1.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ <strong>使用interrupt方法中断线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.打断阻塞的线程</span></span><br><span class="line">        <span class="comment">/*Thread t1 = new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;t1 正在运行...&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t1&quot;);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        Thread.sleep(500);</span></span><br><span class="line"><span class="comment">        t1.interrupt();</span></span><br><span class="line"><span class="comment">        System.out.println(t1.isInterrupted());*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打断正常的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">                <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打断状态：&quot;</span>+interrupted);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//        t2.interrupt();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-线程中并发锁"><a href="#2-线程中并发锁" class="headerlink" title="2.线程中并发锁"></a>2.线程中并发锁</h2><h3 id="2-1-讲一下synchronized关键字的底层原理？"><a href="#2-1-讲一下synchronized关键字的底层原理？" class="headerlink" title="2.1 讲一下synchronized关键字的底层原理？"></a>2.1 讲一下synchronized关键字的底层原理？</h3><blockquote>
<p>难易程度：☆☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="2-1-1-基本使用"><a href="#2-1-1-基本使用" class="headerlink" title="2.1.1 基本使用"></a>2.1.1 基本使用</h4><p>如下抢票的代码，如果不加锁，就会出现超卖或者一张票卖给多个人</p>
<p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到一张票,剩余:&quot;</span> + ticketNum);</span><br><span class="line">            <span class="comment">// 非原子性操作</span></span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketDemo</span> <span class="variable">ticketDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                ticketDemo.getTicket();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-Monitor"><a href="#2-1-2-Monitor" class="headerlink" title="2.1.2 Monitor"></a>2.1.2 Monitor</h4><p>Monitor 被翻译为监视器，是由jvm提供，c++语言实现</p>
<p>在代码中想要体现monitor需要借助javap命令查看clsss的字节码，比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到这个类的class文件，在class文件目录下执行<code>javap -v SyncTest.class</code>，反编译效果如下：</p>
<p><img src="/blog/images/img/image-20230504165342501.png" alt="image-20230504165342501"></p>
<blockquote>
<ul>
<li>monitorenter    上锁开始的地方</li>
<li>monitorexit        解锁的地方</li>
<li>其中被monitorenter和monitorexit包围住的指令就是上锁的代码</li>
<li>有两个monitorexit的原因，第二个monitorexit是为了防止锁住的代码抛异常后不能及时释放锁</li>
</ul>
</blockquote>
<p>在使用了synchornized代码块时需要指定一个对象，所以synchornized也被称为对象锁</p>
<p>monitor主要就是跟这个对象产生关联，如下图</p>
<p><img src="/blog/images/img/image-20230504165833809.png" alt="image-20230504165833809"></p>
<p>Monitor内部具体的存储结构：</p>
<ul>
<li><p>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</p>
</li>
<li><p>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</p>
</li>
<li><p>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</p>
</li>
</ul>
<p>具体的流程：</p>
<ul>
<li>代码进入synchorized代码块，先让lock（对象锁）关联的monitor，然后判断Owner是否有线程持有</li>
<li>如果没有线程持有，则让当前线程持有，表示该线程获取锁成功</li>
<li>如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去竞争锁的持有权（非公平）</li>
<li>如果代码块中调用了wait()方法，则会进去WaitSet中进行等待</li>
</ul>
<p>参考回答：</p>
<ul>
<li><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</p>
</li>
<li><p>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</p>
</li>
<li><p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p>
</li>
<li><p>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</p>
</li>
</ul>
<h3 id="2-2-synchronized关键字的底层原理-进阶"><a href="#2-2-synchronized关键字的底层原理-进阶" class="headerlink" title="2.2 synchronized关键字的底层原理-进阶"></a>2.2 synchronized关键字的底层原理-进阶</h3><p>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</p>
<ul>
<li><p>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
</li>
<li><p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p>
</li>
</ul>
<h4 id="2-2-1-对象的内存结构"><a href="#2-2-1-对象的内存结构" class="headerlink" title="2.2.1 对象的内存结构"></a>2.2.1 对象的内存结构</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充</p>
<p><img src="/blog/images/img/image-20230504172253826.png" alt="image-20230504172253826"></p>
<p>我们需要重点分析MarkWord对象头</p>
<h4 id="2-2-2-MarkWord"><a href="#2-2-2-MarkWord" class="headerlink" title="2.2.2 MarkWord"></a>2.2.2 MarkWord</h4><p><img src="/blog/images/img/image-20230504172541922.png" alt="image-20230504172541922"></p>
<blockquote>
<ul>
<li><p>hashcode：25位的对象标识Hash码</p>
</li>
<li><p>age：对象分代年龄占4位</p>
</li>
<li><p>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</p>
</li>
<li><p>thread：持有偏向锁的线程ID，占23位</p>
</li>
<li><p>epoch：偏向时间戳，占2位</p>
</li>
<li><p>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</p>
</li>
<li><p>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</p>
</li>
</ul>
</blockquote>
<p>我们可以通过lock的标识，来判断是哪一种锁的等级</p>
<ul>
<li>后三位是001表示无锁</li>
<li>后三位是101表示偏向锁</li>
<li>后两位是00表示轻量级锁</li>
<li>后两位是10表示重量级锁</li>
</ul>
<h4 id="2-2-3-再说Monitor重量级锁"><a href="#2-2-3-再说Monitor重量级锁" class="headerlink" title="2.2.3 再说Monitor重量级锁"></a>2.2.3 再说Monitor重量级锁</h4><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，<strong>该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</strong></p>
<p><img src="/blog/images/img/image-20230504172957271.png" alt="image-20230504172957271"></p>
<p>简单说就是：每个对象的对象头都可以设置monoitor的指针，让对象与monitor产生关联</p>
<h4 id="2-2-4-轻量级锁"><a href="#2-2-4-轻量级锁" class="headerlink" title="2.2.4 轻量级锁"></a>2.2.4 轻量级锁</h4><p>在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁的流程</strong></p>
<p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p>
<p><img src="/blog/images/img/image-20230504173520412.png" alt="image-20230504173520412"></p>
<p>2.通过CAS指令将Lock Record的地址存储在对象头的mark word中（数据进行交换），如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p>
<p><img src="/blog/images/img/image-20230504173611219.png" alt="image-20230504173611219"></p>
<p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。</p>
<p><img src="/blog/images/img/image-20230504173922343.png" alt="image-20230504173922343"></p>
<p>4.如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p>
<p><strong>解锁过程</strong></p>
<p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p>
<p>2.如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p>
<p><img src="/blog/images/img/image-20230504173955680.png" alt="image-20230504173955680"></p>
<p>3.如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</p>
<p><img src="/blog/images/img/image-20230504174045458.png" alt="image-20230504174045458"></p>
<h4 id="2-2-5-偏向锁"><a href="#2-2-5-偏向锁" class="headerlink" title="2.2.5 偏向锁"></a>2.2.5 偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现</p>
<p>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁的流程</strong></p>
<p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p>
<p><img src="/blog/images/img/image-20230504174525256.png" alt="image-20230504174525256"></p>
<p>2.通过CAS指令将Lock Record的<strong>线程id</strong>存储在对象头的mark word中，同时也设置偏向锁的标识为101，如果对象处于无锁状态则修改成功，代表该线程获得了偏向锁。</p>
<p><img src="/blog/images/img/image-20230504174505031.png" alt="image-20230504174505031"></p>
<p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。与轻量级锁不同的时，这里不会再次进行cas操作，只是判断对象头中的线程id是否是自己，因为缺少了cas操作，性能相对轻量级锁更好一些</p>
<p><img src="/blog/images/img/image-20230504174736226.png" alt="image-20230504174736226"></p>
<p>解锁流程参考轻量级锁</p>
<h4 id="2-2-6-参考回答"><a href="#2-2-6-参考回答" class="headerlink" title="2.2.6 参考回答"></a>2.2.6 参考回答</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
<p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p>
<h3 id="2-3你谈谈-JMM（Java-内存模型）"><a href="#2-3你谈谈-JMM（Java-内存模型）" class="headerlink" title="2.3你谈谈 JMM（Java 内存模型）"></a>2.3你谈谈 JMM（Java 内存模型）</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。</p>
<p>Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p>
<p><img src="/blog/images/img/image-20230504181638237.png" alt="image-20230504181638237"></p>
<p>特点：</p>
<ol>
<li><p>所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
</li>
<li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>
</li>
<li><p>线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。</p>
</li>
</ol>
<h3 id="2-4-CAS-你知道吗？"><a href="#2-4-CAS-你知道吗？" class="headerlink" title="2.4 CAS 你知道吗？"></a>2.4 CAS 你知道吗？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<h4 id="2-4-1-概述及基本工作流程"><a href="#2-4-1-概述及基本工作流程" class="headerlink" title="2.4.1 概述及基本工作流程"></a>2.4.1 概述及基本工作流程</h4><p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</p>
<p>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p>
<ul>
<li><p>AbstractQueuedSynchronizer（AQS框架）</p>
</li>
<li><p>AtomicXXX类</p>
</li>
</ul>
<p>例子：</p>
<p>我们还是基于刚才学习过的JMM内存模型进行说明</p>
<ul>
<li>线程1与线程2都从主内存中获取变量int a &#x3D; 100,同时放到各个线程的工作内存中</li>
</ul>
<p><img src="/blog/images/img/image-20230504181947319.png" alt="image-20230504181947319"></p>
<blockquote>
<p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</p>
</blockquote>
<ul>
<li>线程1操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 101 (a++)<ul>
<li>线程1拿A的值与主内存V的值进行比较，判断是否相等</li>
<li>如果相等，则把B的值101更新到主内存中</li>
</ul>
</li>
</ul>
<p><img src="/blog/images/img/image-20230504182129820.png" alt="image-20230504182129820"></p>
<ul>
<li>线程2操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 99(a–)<ul>
<li>线程2拿A的值与主内存V的值进行比较，判断是否相等(目前不相等，因为线程1已更新V的值99)</li>
<li>不相等，则线程2更新失败</li>
</ul>
</li>
</ul>
<p><img src="/blog/images/img/image-20230504181827330.png" alt="image-20230504181827330"></p>
<ul>
<li><p>自旋锁操作</p>
<ul>
<li><p>因为没有加锁，所以线程不会陷入阻塞，效率较高</p>
</li>
<li><p>如果竞争激烈，重试频繁发生，效率会受影响</p>
</li>
</ul>
</li>
</ul>
<p><img src="/blog/images/img/image-20230504182447552.png" alt="image-20230504182447552"></p>
<p>需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功</p>
<h4 id="2-4-2-CAS-底层实现"><a href="#2-4-2-CAS-底层实现" class="headerlink" title="2.4.2 CAS 底层实现"></a>2.4.2 CAS 底层实现</h4><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p>
<p><img src="/blog/images/img/image-20230504182737931.png" alt="image-20230504182737931"></p>
<p>都是native修饰的方法，由系统提供的接口执行，并非java代码实现，一般的思路也都是自旋锁实现</p>
<p><img src="/blog/images/img/image-20230504182838426.png" alt="image-20230504182838426"></p>
<p>在java中比较常见使用有很多，比如ReentrantLock和Atomic开头的线程安全类，都调用了Unsafe中的方法</p>
<ul>
<li>ReentrantLock中的一段CAS代码</li>
</ul>
<p><img src="/blog/images/img/image-20230504182958703.png" alt="image-20230504182958703"></p>
<h4 id="2-4-3-乐观锁和悲观锁"><a href="#2-4-3-乐观锁和悲观锁" class="headerlink" title="2.4.3 乐观锁和悲观锁"></a>2.4.3 乐观锁和悲观锁</h4><ul>
<li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p>
</li>
<li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
</li>
</ul>
<h3 id="2-5-请谈谈你对-volatile-的理解"><a href="#2-5-请谈谈你对-volatile-的理解" class="headerlink" title="2.5 请谈谈你对 volatile 的理解"></a>2.5 请谈谈你对 volatile 的理解</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<h4 id="2-5-1-保证线程间的可见性"><a href="#2-5-1-保证线程间的可见性" class="headerlink" title="2.5.1 保证线程间的可见性"></a>2.5.1 保证线程间的可见性</h4><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
<p>一个典型的例子：永不停止的循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可见性例子</span></span><br><span class="line"><span class="comment">// -Xint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeverLoop</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;modify stop to true...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;stopped... c:&quot;</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行上述代码的时候，发现foo()方法中的循环是结束不了的，也就说读取不到共享变量的值结束循环。</p>
<p>主要是因为在JVM虚拟机中有一个JIT（即时编辑器）给代码做了优化。</p>
<blockquote>
<p>上述代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>在很短的时间内，这个代码执行的次数太多了，当达到了一个阈值，JIT就会优化此代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>当把代码优化成这样子以后，及时<code>stop</code>变量改变为了<code>false</code>也依然停止不了循环</p>
</blockquote>
<p>解决方案：</p>
<p>第一：</p>
<p>在程序运行的时候加入vm参数<code>-Xint</code>表示禁用即时编辑器，不推荐，得不偿失（其他程序还要使用）</p>
<p>第二：</p>
<p>在修饰<code>stop</code>变量的时候加上<code>volatile</code>,表示当前代码禁用了即时编辑器，问题就可以解决，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-禁止进行指令重排序"><a href="#2-5-2-禁止进行指令重排序" class="headerlink" title="2.5.2 禁止进行指令重排序"></a>2.5.2 禁止进行指令重排序</h4><p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
<p><img src="/blog/images/img/image-20230505082441116.png" alt="image-20230505082441116"></p>
<p>在去获取上面的结果的时候，有可能会出现4种情况</p>
<p>情况一：先执行actor2获取结果—&gt;0,0(正常)</p>
<p>情况二：先执行actor1中的第一行代码，然后执行actor2获取结果—&gt;0,1(正常)</p>
<p>情况三：先执行actor1中所有代码，然后执行actor2获取结果—&gt;1,1(正常)</p>
<p>情况四：先执行actor1中第二行代码，然后执行actor2获取结果—&gt;1,0(发生了指令重排序，影响结果)</p>
<p><strong>解决方案</strong></p>
<p>在变量上添加volatile，禁止指令重排序，则可以解决问题</p>
<p><img src="/blog/images/img/image-20230505082835588.png" alt="image-20230505082835588"></p>
<p>屏障添加的示意图</p>
<p><img src="/blog/images/img/image-20230505082923729.png" alt="image-20230505082923729"></p>
<ul>
<li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li>
<li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li>
</ul>
<p><strong>其他补充</strong></p>
<p>我们上面的解决方案是把volatile加在了int y这个变量上，我们能不能把它加在int x这个变量上呢？</p>
<p>下面代码使用volatile修饰了x变量</p>
<p><img src="/blog/images/img/image-20230505083124159.png" alt="image-20230505083124159"></p>
<p>屏障添加的示意图</p>
<p><img src="/blog/images/img/image-20230505083217904.png" alt="image-20230505083217904"></p>
<p>这样显然是不行的，主要是因为下面两个原则：</p>
<ul>
<li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li>
<li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li>
</ul>
<p>所以，现在我们就可以总结一个volatile使用的小妙招：</p>
<ul>
<li>写变量让volatile修饰的变量的在代码最后位置</li>
<li>读变量让volatile修饰的变量的在代码最开始位置</li>
</ul>
<h3 id="2-6-什么是AQS？"><a href="#2-6-什么是AQS？" class="headerlink" title="2.6 什么是AQS？"></a>2.6 什么是AQS？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1 概述"></a>2.6.1 概述</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p>
<p>AQS与Synchronized的区别</p>
<table>
<thead>
<tr>
<th><strong>synchronized</strong></th>
<th><strong>AQS</strong></th>
</tr>
</thead>
<tbody><tr>
<td>关键字，c++ 语言实现</td>
<td>java  语言实现</td>
</tr>
<tr>
<td>悲观锁，自动释放锁</td>
<td>悲观锁，手动开启和关闭</td>
</tr>
<tr>
<td>锁竞争激烈都是重量级锁，性能差</td>
<td>锁竞争激烈的情况下，提供了多种解决方案</td>
</tr>
</tbody></table>
<p>AQS常见的实现类</p>
<ul>
<li><p>ReentrantLock      阻塞式锁</p>
</li>
<li><p>Semaphore        信号量</p>
</li>
<li><p>CountDownLatch   倒计时锁</p>
</li>
</ul>
<h4 id="2-6-2-工作机制"><a href="#2-6-2-工作机制" class="headerlink" title="2.6.2 工作机制"></a>2.6.2 工作机制</h4><ul>
<li>在AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p><img src="/blog/images/img/image-20230505083840046.png" alt="image-20230505083840046"></p>
<blockquote>
<ul>
<li>线程0来了以后，去尝试修改state属性，如果发现state属性是0，就修改state状态为1，表示线程0抢锁成功</li>
<li>线程1和线程2也会先尝试修改state属性，发现state的值已经是1了，有其他线程持有锁，它们都会到FIFO队列中进行等待，</li>
<li>FIFO是一个双向队列，head属性表示头结点，tail表示尾结点</li>
</ul>
</blockquote>
<p><strong>如果多个线程共同去抢这个资源是如何保证原子性的呢？</strong></p>
<p><img src="/blog/images/img/image-20230505084451193.png" alt="image-20230505084451193"></p>
<p>在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待</p>
<p><strong>AQS是公平锁吗，还是非公平锁？</strong></p>
<ul>
<li><p>新的线程与队列中的线程共同来抢资源，是非公平锁</p>
</li>
<li><p>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</p>
</li>
</ul>
<blockquote>
<p>比较典型的AQS实现类ReentrantLock，它默认就是非公平锁，新的线程与队列中的线程共同来抢资源</p>
</blockquote>
<h3 id="2-5-ReentrantLock的实现原理"><a href="#2-5-ReentrantLock的实现原理" class="headerlink" title="2.5 ReentrantLock的实现原理"></a>2.5 ReentrantLock的实现原理</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li><p>可中断</p>
</li>
<li><p>可以设置超时时间</p>
</li>
<li><p>可以设置公平锁</p>
</li>
<li><p>支持多个条件变量</p>
</li>
<li><p>与synchronized一样，都支持重入</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230505091736569.png" alt="image-20230505091736569"></p>
<h4 id="2-5-2-实现原理"><a href="#2-5-2-实现原理" class="headerlink" title="2.5.2 实现原理"></a>2.5.2 实现原理</h4><p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p>
<p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
<p>查看ReentrantLock源码中的构造方法：</p>
<p><img src="/blog/images/img/image-20230505091827720.png" alt="image-20230505091827720"></p>
<p>提供了两个构造方法，不带参数的默认为非公平</p>
<p>如果使用带参数的构造函数，并且传的值为true，则是公平锁</p>
<p>其中NonfairSync和FairSync这两个类父类都是Sync</p>
<p><img src="/blog/images/img/image-20230505092151244.png" alt="image-20230505092151244"></p>
<p>而Sync的父类是AQS，所以可以得出ReentrantLock底层主要实现就是基于AQS来实现的</p>
<p><img src="/blog/images/img/image-20230505091833629.png" alt="image-20230505091833629"></p>
<p><strong>工作流程</strong></p>
<p><img src="/blog/images/img/image-20230505092340431.png" alt="image-20230505092340431"></p>
<ul>
<li><p>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</p>
</li>
<li><p>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</p>
</li>
<li><p>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</p>
</li>
<li><p>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</p>
</li>
</ul>
<h3 id="2-6-synchronized和Lock有什么区别"><a href="#2-6-synchronized和Lock有什么区别" class="headerlink" title="2.6 synchronized和Lock有什么区别 ?"></a>2.6 synchronized和Lock有什么区别 ?</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>参考回答</p>
<ul>
<li>语法层面<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li>
<li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li>
</ul>
</li>
<li>功能层面<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<h3 id="2-7-死锁产生的条件是什么？"><a href="#2-7-死锁产生的条件是什么？" class="headerlink" title="2.7 死锁产生的条件是什么？"></a>2.7 死锁产生的条件是什么？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<blockquote>
<p>例如：</p>
<p>t1 线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deadlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出结果</p>
<p><img src="/blog/images/img/image-20220902171032898.png" alt="image-20220902171032898"></p>
<p>此时程序并没有结束，这种现象就是死锁现象…线程t1持有A的锁等待获取B锁，线程t2持有B的锁等待获取A的锁。</p>
<h3 id="2-8-如何进行死锁诊断？"><a href="#2-8-如何进行死锁诊断？" class="headerlink" title="2.8 如何进行死锁诊断？"></a>2.8 如何进行死锁诊断？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p>
<p>步骤如下：</p>
<p>第一：查看运行的线程</p>
<p><img src="/blog/images/img/image-20220902171426738.png" alt="image-20220902171426738"></p>
<p>第二：使用jstack查看线程运行的情况，下图是截图的关键信息</p>
<p>运行命令：<code>jstack -l 46032</code></p>
<p><img src="/blog/images/img/image-20220902172229567.png" alt="image-20220902172229567"></p>
<p><strong>其他解决工具，可视化工具</strong></p>
<ul>
<li>jconsole</li>
</ul>
<p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p>
<ul>
<li>VisualVM：故障处理工具</li>
</ul>
<p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>
<h3 id="2-10-ConcurrentHashMap"><a href="#2-10-ConcurrentHashMap" class="headerlink" title="2.10  ConcurrentHashMap"></a>2.10  ConcurrentHashMap</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>ConcurrentHashMap 是一种线程安全的高效Map集合</p>
<p>底层数据结构：</p>
<ul>
<li><p>JDK1.7底层采用分段的数组+链表实现</p>
</li>
<li><p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</p>
</li>
</ul>
<h4 id="（1）-JDK1-7中concurrentHashMap"><a href="#（1）-JDK1-7中concurrentHashMap" class="headerlink" title="（1） JDK1.7中concurrentHashMap"></a>（1） JDK1.7中concurrentHashMap</h4><p>数据结构</p>
<p><img src="/blog/images/img/image-20230505092654811.png" alt="image-20230505092654811"></p>
<blockquote>
<ul>
<li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是16，一旦初始化之后中间不可扩容</li>
<li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li>
<li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li>
</ul>
</blockquote>
<p>存储流程</p>
<p><img src="/blog/images/img/image-20230505093055382.png" alt="image-20230505093055382"></p>
<ul>
<li>先去计算key的hash值，然后确定segment数组下标</li>
<li>再通过hash值确定hashEntry数组中的下标存储数据</li>
<li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li>
</ul>
<h4 id="（2）-JDK1-8中concurrentHashMap"><a href="#（2）-JDK1-8中concurrentHashMap" class="headerlink" title="（2） JDK1.8中concurrentHashMap"></a>（2） JDK1.8中concurrentHashMap</h4><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表</p>
<p>采用 CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li><p>CAS控制数组节点的添加</p>
</li>
<li><p>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230505093507265.png" alt="image-20230505093507265"></p>
<h3 id="2-11-导致并发程序出现问题的根本原因是什么"><a href="#2-11-导致并发程序出现问题的根本原因是什么" class="headerlink" title="2.11 导致并发程序出现问题的根本原因是什么"></a>2.11 导致并发程序出现问题的根本原因是什么</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>Java并发编程三大特性</p>
<ul>
<li><p>原子性</p>
</li>
<li><p>可见性</p>
</li>
<li><p>有序性</p>
</li>
</ul>
<h4 id="（1）原子性"><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h4><p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p>
<p>比如，如下代码能保证原子性吗？</p>
<p><img src="/blog/images/img/image-20230505205200628.png" alt="image-20230505205200628"></p>
<p>以上代码会出现超卖或者是一张票卖给同一个人，执行并不是原子性的</p>
<p>解决方案：</p>
<p>1.synchronized：同步加锁</p>
<p>2.JUC里面的lock：加锁</p>
<p><img src="/blog/images/img/image-20230505210853493.png" alt="image-20230505210853493"></p>
<h4 id="（3）内存可见性"><a href="#（3）内存可见性" class="headerlink" title="（3）内存可见性"></a>（3）内存可见性</h4><p>内存可见性：让一个线程对共享变量的修改对另一个线程可见</p>
<p>比如，以下代码不能保证内存可见性</p>
<p><img src="/blog/images/img/image-20230505211002252.png" alt="image-20230505211002252"></p>
<p>解决方案：</p>
<ul>
<li><p>synchronized</p>
</li>
<li><p>volatile（推荐）</p>
</li>
<li><p>LOCK</p>
</li>
</ul>
<h4 id="（3）有序性"><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h4><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<p>还是之前的例子，如下代码：</p>
<p><img src="/blog/images/img/image-20230505211209336.png" alt="image-20230505211209336"></p>
<p>解决方案：</p>
<ul>
<li>volatile</li>
</ul>
<h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h2><h3 id="3-1-说一下线程池的核心参数（线程池的执行原理知道嘛）"><a href="#3-1-说一下线程池的核心参数（线程池的执行原理知道嘛）" class="headerlink" title="3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）"></a>3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数</p>
<p><img src="/blog/images/img/image-20230505220514872.png" alt="image-20230505220514872"></p>
<ul>
<li><p>corePoolSize 核心线程数目</p>
</li>
<li><p>maximumPoolSize 最大线程数目 &#x3D; (核心线程+救急线程的最大数目)</p>
</li>
<li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p>
</li>
<li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p>
</li>
<li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
</li>
<li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p>
</li>
<li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p>
</li>
</ul>
<p><strong>工作流程</strong></p>
<p><img src="/blog/images/img/image-20230505220701835.png" alt="image-20230505220701835"></p>
<blockquote>
<p>1，任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行</p>
<p>2，如果核心线程数满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列</p>
<p>3，如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务</p>
<p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p>
<p>4，如果所有线程都在忙着（核心线程+临时线程），则走拒绝策略</p>
</blockquote>
<p>拒绝策略：</p>
<p>1.AbortPolicy：直接抛出异常，默认策略；</p>
<p>2.CallerRunsPolicy：用调用者所在的线程来执行任务；</p>
<p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p>
<p>4.DiscardPolicy：直接丢弃任务；</p>
<p>参考代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> duration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>(name, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name, <span class="type">long</span> duration)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.duration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LoggerUtils.get(<span class="string">&quot;myThread&quot;</span>).debug(<span class="string">&quot;running...&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MyTask(&quot;</span> + name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                queue,</span><br><span class="line">                r -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;myThread&quot;</span> + c.getAndIncrement()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;1&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;2&quot;</span>, <span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;4&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;5&quot;</span>,<span class="number">3600000</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="string">&quot;6&quot;</span>));</span><br><span class="line">        showState(queue, threadPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showState</span><span class="params">(ArrayBlockingQueue&lt;Runnable&gt; queue, ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Object&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Runnable runnable : queue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">callable</span> <span class="operator">=</span> FutureTask.class.getDeclaredField(<span class="string">&quot;callable&quot;</span>);</span><br><span class="line">                callable.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">adapter</span> <span class="operator">=</span> callable.get(runnable);</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.util.concurrent.Executors$RunnableAdapter&quot;</span>);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">task</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">                task.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> task.get(adapter);</span><br><span class="line">                tasks.add(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LoggerUtils.main.debug(<span class="string">&quot;pool size: &#123;&#125;, queue: &#123;&#125;&quot;</span>, threadPool.getPoolSize(), tasks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-线程池中有哪些常见的阻塞队列"><a href="#3-2-线程池中有哪些常见的阻塞队列" class="headerlink" title="3.2 线程池中有哪些常见的阻塞队列"></a>3.2 线程池中有哪些常见的阻塞队列</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p>
<p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p>
<p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p>
<p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p>
<p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p>
<p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p>
<table>
<thead>
<tr>
<th><strong>LinkedBlockingQueue</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>默认无界，支持有界</td>
<td>强制有界</td>
</tr>
<tr>
<td>底层是链表</td>
<td>底层是数组</td>
</tr>
<tr>
<td>是懒惰的，创建节点的时候添加数据</td>
<td>提前初始化 Node  数组</td>
</tr>
<tr>
<td>入队会生成新 Node</td>
<td>Node需要是提前创建好的</td>
</tr>
<tr>
<td>两把锁（头尾）</td>
<td>一把锁</td>
</tr>
</tbody></table>
<p>左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方式</p>
<ul>
<li>LinkedBlockingQueue读和写各有一把锁，性能相对较好</li>
<li>ArrayBlockingQueue只有一把锁，读和写公用，性能相对于LinkedBlockingQueue差一些</li>
</ul>
<p><img src="/blog/images/img/image-20230505221424359.png" alt="image-20230505221424359"></p>
<h3 id="3-3-如何确定核心线程数"><a href="#3-3-如何确定核心线程数" class="headerlink" title="3.3 如何确定核心线程数"></a>3.3 如何确定核心线程数</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p>
<ul>
<li>IO密集型任务</li>
</ul>
<p>一般来说：文件读写、DB读写、网络请求等</p>
<p>推荐：核心线程数大小设置为2N+1    （N为计算机的CPU核数）</p>
<ul>
<li>CPU密集型任务</li>
</ul>
<p>一般来说：计算型代码、Bitmap转换、Gson转换等</p>
<p>推荐：核心线程数大小设置为N+1    （N为计算机的CPU核数）</p>
<p>java代码查看CPU核数</p>
<p><img src="/blog/images/img/image-20230505221837189.png" alt="image-20230505221837189"></p>
<p><strong>参考回答：</strong></p>
<p>① 高并发、任务执行时间短 –&gt;（ CPU核数+1 ），减少线程上下文的切换</p>
<p>② 并发不高、任务执行时间长</p>
<ul>
<li><p>IO密集型的任务 –&gt; (CPU核数 * 2 + 1)</p>
</li>
<li><p>计算密集型任务 –&gt; （ CPU核数+1 ）</p>
</li>
</ul>
<p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）</p>
<h3 id="3-4-线程池的种类有哪些"><a href="#3-4-线程池的种类有哪些" class="headerlink" title="3.4 线程池的种类有哪些"></a>3.4 线程池的种类有哪些</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p>
<ol>
<li><p>创建使用固定线程数的线程池</p>
<p><img src="/blog/images/img/image-20230505221959259.png" alt="image-20230505221959259"></p>
<ul>
<li><p>核心线程数与最大线程数一样，没有救急线程</p>
</li>
<li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p>
</li>
<li><p>适用场景：适用于任务量已知，相对耗时的任务</p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FixedThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个固定大小的线程池，核心线程数和最大线程数都是3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">FixedThreadDemo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p>
<p><img src="/blog/images/img/image-20230505222050294.png" alt="image-20230505222050294"></p>
<ul>
<li><p>核心线程数和最大线程数都是1</p>
</li>
<li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p>
</li>
<li><p>适用场景：适用于按照顺序执行的任务</p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSingleThreadCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//单个线程池，核心线程数和最大线程数都是1</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可缓存线程池</p>
<p><img src="/blog/images/img/image-20230505222126391.png" alt="image-20230505222126391"></p>
<ul>
<li><p>核心线程数为0</p>
</li>
<li><p>最大线程数是Integer.MAX_VALUE</p>
</li>
<li><p>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p>
</li>
<li><p>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//修改睡眠时间，模拟线程执行需要花费的时间</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;执行完了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个缓存的线程，没有核心线程数，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p>
<p><img src="/blog/images/img/image-20230505222203615.png" alt="image-20230505222203615"></p>
<ul>
<li><p>适用场景：有定时和延迟执行的任务</p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 结束：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//按照周期执行的线程池，核心线程数为2，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * schedule 提交任务到线程池中</span></span><br><span class="line"><span class="comment">         * 第一个参数：提交的任务</span></span><br><span class="line"><span class="comment">         * 第二个参数：任务执行的延迟时间</span></span><br><span class="line"><span class="comment">         * 第三个参数：时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="3-5-为什么不建议用Executors创建线程池"><a href="#3-5-为什么不建议用Executors创建线程池" class="headerlink" title="3.5 为什么不建议用Executors创建线程池"></a>3.5 为什么不建议用Executors创建线程池</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考阿里开发手册《Java开发手册-嵩山版》</p>
<p><img src="/blog/images/img/image-20220821003816845.png" alt="image-20220821003816845"></p>
<h2 id="4-线程使用场景问题"><a href="#4-线程使用场景问题" class="headerlink" title="4.线程使用场景问题"></a>4.线程使用场景问题</h2><h3 id="4-1-线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"><a href="#4-1-线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）" class="headerlink" title="4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"></a>4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="4-1-1-CountDownLatch"><a href="#4-1-1-CountDownLatch" class="headerlink" title="4.1.1 CountDownLatch"></a>4.1.1 CountDownLatch</h4><p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p>
<ul>
<li><p>其中构造参数用来初始化等待计数值</p>
</li>
<li><p>await() 用来等待计数归零</p>
</li>
<li><p>countDown() 用来让计数减一</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230505223014946.png" alt="image-20230505223014946"></p>
<p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//初始化了一个倒计时锁 参数为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count--</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-end...&quot;</span> +latch.getCount());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-waiting...&quot;</span>);</span><br><span class="line">        <span class="comment">//等待其他线程完成</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-wait end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-案例一（es数据批量导入）"><a href="#4-1-2-案例一（es数据批量导入）" class="headerlink" title="4.1.2 案例一（es数据批量导入）"></a>4.1.2 案例一（es数据批量导入）</h4><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p>
<p>整体流程就是通过CountDownLatch+线程池配合去执行</p>
<p><img src="/blog/images/img/image-20230505223219951.png" alt="image-20230505223219951"></p>
<p>详细实现流程：</p>
<p><img src="/blog/images/img/image-20230505223246059.png" alt="image-20230505223246059"></p>
<blockquote>
<p>详细实现代码，请查看当天代码</p>
</blockquote>
<h4 id="4-1-3-案例二（数据汇总）"><a href="#4-1-3-案例二（数据汇总）" class="headerlink" title="4.1.3 案例二（数据汇总）"></a>4.1.3 案例二（数据汇总）</h4><p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p>
<p><img src="/blog/images/img/image-20230505223442924.png" alt="image-20230505223442924"></p>
<blockquote>
<p>详细实现代码，请查看当天代码</p>
</blockquote>
<ul>
<li><p>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</p>
</li>
<li><p>报表汇总</p>
<p><img src="/blog/images/img/image-20230505223536657.png" alt="image-20230505223536657"></p>
</li>
</ul>
<h4 id="4-1-4-案例二（异步调用）"><a href="#4-1-4-案例二（异步调用）" class="headerlink" title="4.1.4 案例二（异步调用）"></a>4.1.4 案例二（异步调用）</h4><p><img src="/blog/images/img/image-20230505223640038.png" alt="image-20230505223640038"></p>
<p>在进行搜索的时候，需要保存用户的搜索记录，而搜索记录不能影响用户的正常搜索，我们通常会开启一个线程去执行历史记录的保存，在新开启的线程在执行的过程中，可以利用线程提交任务</p>
<h3 id="4-1-如何控制某个方法允许并发访问线程的数量？"><a href="#4-1-如何控制某个方法允许并发访问线程的数量？" class="headerlink" title="4.1 如何控制某个方法允许并发访问线程的数量？"></a>4.1 如何控制某个方法允许并发访问线程的数量？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，我们可以通过其限制执行的线程数量，达到限流的效果</p>
<p>当一个线程执行时先通过其方法进行获取许可操作，获取到许可的线程继续执行业务逻辑，当线程执行完成后进行释放许可操作，未获取达到许可的线程进行等待或者直接结束。</p>
<p>Semaphore两个重要的方法</p>
<p>lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p>
<p>lsemaphore.release()：释放一个信号量，此时信号量个数+1</p>
<p>线程任务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><h3 id="5-1-谈谈你对ThreadLocal的理解"><a href="#5-1-谈谈你对ThreadLocal的理解" class="headerlink" title="5.1 谈谈你对ThreadLocal的理解"></a>5.1 谈谈你对ThreadLocal的理解</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p>
<p><img src="/blog/images/img/image-20230505224057228.png" alt="image-20230505224057228"></p>
<h4 id="5-1-2-ThreadLocal基本使用"><a href="#5-1-2-ThreadLocal基本使用" class="headerlink" title="5.1.2 ThreadLocal基本使用"></a>5.1.2 ThreadLocal基本使用</h4><p>三个主要方法：</p>
<ul>
<li><p>set(value) 设置值</p>
</li>
<li><p>get() 获取值</p>
</li>
<li><p>remove() 清除值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + threadLocal.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-ThreadLocal的实现原理-amp-源码解析"><a href="#5-1-3-ThreadLocal的实现原理-amp-源码解析" class="headerlink" title="5.1.3 ThreadLocal的实现原理&amp;源码解析"></a>5.1.3 ThreadLocal的实现原理&amp;源码解析</h4><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</p>
<p><img src="/blog/images/img/image-20230505224341410.png" alt="image-20230505224341410"></p>
<p>在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap</p>
<p>ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置</p>
<p><strong>set方法</strong></p>
<p><img src="/blog/images/img/image-20230505224626253.png" alt="image-20230505224626253"></p>
<p><strong>get方法&#x2F;remove方法</strong></p>
<p><img src="/blog/images/img/image-20230505224715087.png" alt="image-20230505224715087"></p>
<h4 id="5-1-4-ThreadLocal-内存泄露问题"><a href="#5-1-4-ThreadLocal-内存泄露问题" class="headerlink" title="5.1.4 ThreadLocal-内存泄露问题"></a>5.1.4 ThreadLocal-内存泄露问题</h4><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p>
<ul>
<li>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</li>
</ul>
<p><img src="/blog/images/img/image-20230505224755797.png" alt="image-20230505224755797"></p>
<ul>
<li>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</li>
</ul>
<p><img src="/blog/images/img/image-20230505224812015.png" alt="image-20230505224812015"></p>
<p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p>
<p><img src="/blog/images/img/image-20230505224857538.png" alt="image-20230505224857538"></p>
<p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p>
<h2 id="6-真实面试还原"><a href="#6-真实面试还原" class="headerlink" title="6 真实面试还原"></a>6 真实面试还原</h2><h3 id="6-1-线程的基础知识"><a href="#6-1-线程的基础知识" class="headerlink" title="6.1 线程的基础知识"></a>6.1 线程的基础知识</h3><blockquote>
<p><strong>面试官</strong>：聊一下并行和并发有什么区别？</p>
<p><strong>候选人：</strong></p>
<p>是这样的~~</p>
<p>现在都是多核CPU，在多核CPU下</p>
<p>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</p>
<p>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</p>
<hr>
<p><strong>面试官</strong>：说一下线程和进程的区别？</p>
<p><strong>候选人：</strong></p>
<p>嗯，好~</p>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
<hr>
<p><strong>面试官</strong>：如果在java中创建线程有哪些方式？</p>
<p><strong>候选人：</strong></p>
<p>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。</p>
<p><strong>面试官</strong>：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</p>
<p><strong>候选人：</strong></p>
<p>是这样的~</p>
<p>最主要的两个线程一个是有返回值，一个是没有返回值的。</p>
<p>Runnable 接口run方法无返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>
<p>还有一个就是，他们异常处理也不一样。Runnable接口run方法只能抛出运行时异常，也无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息</p>
<p>在实际开发中，如果需要拿到执行的结果，需要使用Callalbe接口创建线程，调用FutureTask.get()得到可以得到返回值，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>
<hr>
<p><strong>面试官</strong>：线程包括哪些状态，状态之间是如何变化的？</p>
<p><strong>候选人：</strong></p>
<p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p>
<p>关于线程的状态切换情况比较多。我分别介绍一下</p>
<p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p>
<p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p>
<p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p>
<p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p>
<p><strong>面试官</strong>：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？</p>
<p><strong>候选人：</strong></p>
<p>它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</p>
<p>不同点主要有三个方面：</p>
<p>第一：方法归属不同</p>
<p>sleep(long) 是 Thread 的静态方法。而 wait()，是 Object 的成员方法，每个对象都有</p>
<p>第二：线程醒来时机不同</p>
<p>线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去</p>
<p>第三：锁特性不同</p>
<p>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</p>
<p>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（相当于我放弃 cpu，但你们还可以用）</p>
<p>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（相当于我放弃 cpu，你们也用不了）</p>
<p><strong>面试官</strong>：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</p>
<p><strong>候选人：</strong></p>
<p>嗯~~，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）</p>
<p>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>比如说：</p>
<p>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成</p>
<p><strong>面试官</strong>：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</p>
<p><strong>候选人：</strong></p>
<p>start方法用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。run方法封装了要被线程执行的代码，可以被调用多次。</p>
<p><strong>面试官</strong>：那如何停止一个正在运行的线程呢？</p>
<p><strong>候选人</strong>：</p>
<p>有三种方式可以停止线程</p>
<p>第一：可以使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记</p>
<p>第二：可以使用线程的stop方法强行终止，不过一般不推荐，这个方法已作废</p>
<p>第三：可以使用线程的interrupt方法中断线程，内部其实也是使用中断标志来中断线程</p>
<p>我们项目中使用的话，建议使用第一种或第三种方式中断线程</p>
</blockquote>
<h3 id="6-2-线程中并发锁"><a href="#6-2-线程中并发锁" class="headerlink" title="6.2 线程中并发锁"></a>6.2 线程中并发锁</h3><blockquote>
<p><strong>面试官</strong>：讲一下synchronized关键字的底层原理？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~好的，</p>
<p>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。</p>
<p>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。</p>
<p><strong>面试官</strong>：好的，你能具体说下Monitor 吗？</p>
<p><strong>候选人</strong>：</p>
<p>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因</p>
<p>monitor内部维护了三个变量</p>
<ul>
<li><p>WaitSet：保存处于Waiting状态的线程</p>
</li>
<li><p>EntryList：保存处于Blocked状态的线程</p>
</li>
<li><p>Owner：持有锁的线程</p>
</li>
</ul>
<p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner</p>
<p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p>
<p><strong>面试官</strong>：好的，那关于synchronized 的锁升级的情况了解吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道一些（要谦虚）</p>
<p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<p>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
<p>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</p>
<p>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</p>
<p>一旦锁发生了竞争，都会升级为重量级锁</p>
<p><strong>面试官</strong>：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，其实，在高并发下，我们可以采用ReentrantLock来加锁。</p>
<p><strong>面试官</strong>：嗯，那你说下ReentrantLock的使用方式和底层原理？</p>
<p><strong>候选人</strong>：</p>
<p>好的，</p>
<p>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p>
<p>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p>
<p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</p>
<p>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</p>
<p><strong>面试官</strong>：好的，刚才你说了CAS和AQS，你能介绍一下吗？</p>
<p><strong>候选人</strong>：</p>
<p>好的。</p>
<p>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p>
<ul>
<li><p>CAS使用到的地方很多：AQS框架、AtomicXXX类</p>
</li>
<li><p>在操作共享变量的时候使用的自旋锁，效率上更高一些</p>
</li>
<li><p>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</p>
</li>
</ul>
<p>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p>
<p>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态</p>
<p>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中</p>
<ul>
<li><p>tail 指向队列最后一个元素</p>
</li>
<li><p>head  指向队列中最久的一个元素</p>
</li>
</ul>
<p>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。</p>
<p><strong>面试官</strong>：synchronized和Lock有什么区别 ? 	</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，好的，主要有三个方面不太一样</p>
<p>第一，语法层面</p>
<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li>
</ul>
<p>第二，功能层面</p>
<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
<p>第三，性能层面</p>
<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
<p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p>
<hr>
<p><strong>面试官</strong>：死锁产生的条件是什么？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：</p>
<p>t1 线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p>
<p>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁</p>
<p><strong>面试官</strong>：那如果产出了这样的，如何进行死锁诊断？</p>
<p><strong>候选人</strong>：</p>
<p>这个也很容易，我们只需要通过jdk自动的工具就能搞定</p>
<p>我们可以先通过jps来查看当前java程序运行的进程id</p>
<p>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p>
<hr>
<p><strong>面试官</strong>：请谈谈你对 volatile 的理解</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~</p>
<p>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能</p>
<p>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
<p>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化</p>
<hr>
<p><strong>本文作者</strong>：接《集合相关面试题》</p>
<p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯好的，</p>
<p>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p>
<ul>
<li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li>
<li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</li>
</ul>
<p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。</p>
<p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p>
<p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升</p>
</blockquote>
<h3 id="6-3-线程池"><a href="#6-3-线程池" class="headerlink" title="6.3 线程池"></a>6.3 线程池</h3><blockquote>
<p><strong>面试官</strong>：线程池的种类有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>嗯！是这样</p>
<p>在jdk中默认提供了4中方式创建线程池</p>
<p>第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。 </p>
<p>第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。 </p>
<p>第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 </p>
<p>第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><strong>面试官</strong>：线程池的核心参数有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>在线程池中一共有7个核心参数：</p>
<ol>
<li><p>corePoolSize 核心线程数目 - 池中会保留的最多线程数</p>
</li>
<li><p>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</p>
</li>
<li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p>
</li>
<li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p>
</li>
<li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
</li>
<li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p>
</li>
<li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p>
</li>
</ol>
<p>  在拒绝策略中又有4中拒绝策略</p>
<p>  当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。</p>
<p><strong>面试官</strong>：如何确定核心线程池呢？</p>
<p><strong>候选人</strong>：</p>
<p>是这样的，我们公司当时有一些规范，为了减少线程上下文的切换，要根据当时部署的服务器的CPU核数来决定，我们规则是：CPU核数+1就是最终的核心线程数。</p>
<p><strong>面试官</strong>：线程池的执行原理知道吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~，它是这样的</p>
<p>首先判断线程池里的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队 列里。如果工作队列满了，则判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任 务。如果已经满了，则交给拒绝策略来处理这个任务。</p>
<p><strong>面试官</strong>：为什么不建议使用Executors创建线程池呢？</p>
<p><strong>候选人</strong>：</p>
<p>好的，其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p>
<p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p>
<p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p>
</blockquote>
<h3 id="6-4-线程使用场景问题"><a href="#6-4-线程使用场景问题" class="headerlink" title="6.4 线程使用场景问题"></a>6.4 线程使用场景问题</h3><blockquote>
<p><strong>面试官</strong>：如果控制某一个方法允许并发访问线程的数量？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，我想一下</p>
<p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p>
<p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p>
<p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p>
<p><strong>面试官</strong>：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，刚才讲过了导致线程安全的原因，如果解决的话，jdk中也提供了很多的类帮助我们解决多线程安全的问题，比如：</p>
<ul>
<li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li>
<li>synchronized、volatile、LOCK，可以解决可见性问题</li>
<li>Happens-Before 规则可以解决有序性问题</li>
</ul>
<hr>
<p><strong>面试官</strong>：你在项目中哪里用了多线程？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，我想一下当时的场景[根据自己简历上的模块设计多线程场景]</p>
<p>参考场景一：</p>
<p>es数据批量导入</p>
<p>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。</p>
<p>参考场景二：</p>
<p>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行</p>
<p>参考场景三：</p>
<p>《黑马头条》项目中使用的</p>
<p>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用</p>
</blockquote>
<h3 id="6-5-其他"><a href="#6-5-其他" class="headerlink" title="6.5 其他"></a>6.5 其他</h3><blockquote>
<p><strong>面试官</strong>：谈谈你对ThreadLocal的理解</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的~~</p>
<p>ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了线程内的资源共享</p>
<p><strong>面试官</strong>：好的，那你知道ThreadLocal的底层原理实现吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道一些~</p>
<p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p>
<p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p>
<p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p>
<p><strong>面试官</strong>：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，我之前看过源码，我想一下~~</p>
<p>是应为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。</p>
<p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。</p>
</blockquote>
<h1 id="JVM相关面试题"><a href="#JVM相关面试题" class="headerlink" title="JVM相关面试题"></a>JVM相关面试题</h1><h2 id="1-JVM组成"><a href="#1-JVM组成" class="headerlink" title="1 JVM组成"></a>1 JVM组成</h2><h3 id="1-1-JVM由那些部分组成，运行流程是什么？"><a href="#1-1-JVM由那些部分组成，运行流程是什么？" class="headerlink" title="1.1 JVM由那些部分组成，运行流程是什么？"></a>1.1 JVM由那些部分组成，运行流程是什么？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p><strong>JVM是什么</strong></p>
<p>Java Virtual Machine Java程序的运行环境（java二进制字节码的运行环境）</p>
<p>好处：</p>
<ul>
<li><p>一次编写，到处运行</p>
</li>
<li><p>自动内存管理，垃圾回收机制</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230506094254360.png" alt="image-20230506094254360"></p>
<p><strong>JVM由哪些部分组成，运行流程是什么？</strong></p>
<p><img src="/blog/images/img/image-20230506094411247.png" alt="image-20230506094411247"></p>
<p>从图中可以看出 JVM 的主要组成部分</p>
<ul>
<li>ClassLoader（类加载器）</li>
<li>Runtime Data Area（运行时数据区，内存分区）</li>
<li>Execution Engine（执行引擎）</li>
<li>Native Method Library（本地库接口）</li>
</ul>
<p>运行流程：</p>
<p>（1）类加载器（ClassLoader）把Java代码转换为字节码</p>
<p>（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p>
<p>（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p>
<h3 id="1-2-什么是程序计数器？"><a href="#1-2-什么是程序计数器？" class="headerlink" title="1.2 什么是程序计数器？"></a>1.2 什么是程序计数器？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</p>
<blockquote>
<p>javap -verbose  xx.class    打印堆栈大小，局部变量的数量和方法的参数。</p>
</blockquote>
<p><img src="/blog/images/img/image-20230506094602329.png" alt="image-20230506094602329"></p>
<p>​	java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。</p>
<p>​	那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。</p>
<p>​	程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。</p>
<h3 id="1-3-你能给我详细的介绍Java堆吗"><a href="#1-3-你能给我详细的介绍Java堆吗" class="headerlink" title="1.3 你能给我详细的介绍Java堆吗?"></a>1.3 你能给我详细的介绍Java堆吗?</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程共享的区域：主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p>
<p><img src="/blog/images/img/image-20230506094803545.png" alt="image-20230506094803545"></p>
<ul>
<li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li>
<li>老年代主要保存生命周期长的对象，一般是一些老的对象</li>
<li>元空间保存的类信息、静态变量、常量、编译后的代码</li>
</ul>
<p>​	</p>
<p>为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做<strong>元空间</strong>。那么现在就可以避免掉OOM的出现了。</p>
<p><img src="/blog/images/img/image-20230506094938843.png" alt="image-20230506094938843"></p>
<h5 id="元空间-MetaSpace-介绍"><a href="#元空间-MetaSpace-介绍" class="headerlink" title="元空间(MetaSpace)介绍"></a>元空间(MetaSpace)介绍</h5><p>​	在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p>
<p>​	永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。</p>
<p>​	那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</p>
<p>官网给出了解释：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</span><br><span class="line"></span><br><span class="line">移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</span><br></pre></td></tr></table></figure>

<p>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</p>
<p>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</p>
<p>​	准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如<strong>类元信息、字段、静态属性、方法、常量</strong>等都移动到元空间区。比如 java&#x2F;lang&#x2F;Object 类元信息、静态属性 System.out、整型常量等。</p>
<p>​	元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<h3 id="1-4-什么是虚拟机栈"><a href="#1-4-什么是虚拟机栈" class="headerlink" title="1.4 什么是虚拟机栈"></a>1.4 什么是虚拟机栈</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>Java Virtual machine Stacks (java 虚拟机栈)</p>
<ul>
<li><p>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</p>
</li>
<li><p>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</p>
</li>
<li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230506095140595.png" alt="image-20230506095140595"></p>
<ol>
<li><p>垃圾回收是否涉及栈内存？</p>
<p>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放</p>
</li>
<li><p>栈内存分配越大越好吗？</p>
<p>未必，默认的栈内存通常为1024k</p>
<p>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p>
</li>
<li><p>方法内的局部变量是否线程安全？</p>
<ul>
<li><p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</p>
</li>
<li><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p>
</li>
<li><p>比如以下代码：</p>
<p><img src="/blog/images/img/image-20230506095306061.png" alt="image-20230506095306061"></p>
</li>
</ul>
</li>
</ol>
<p><strong>栈内存溢出情况</strong></p>
<ul>
<li><p>栈帧过多导致栈内存溢出，典型问题：递归调用</p>
<p><img src="/blog/images/img/image-20230506095401637.png" alt="image-20230506095401637"></p>
</li>
<li><p>栈帧过大导致栈内存溢出</p>
</li>
</ul>
<blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>组成部分：堆、方法区、栈、本地方法栈、程序计数器</p>
<p>1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。<br>2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。<br>3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。<br>4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。<br>5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p>
<h3 id="1-5-能不能解释一下方法区？"><a href="#1-5-能不能解释一下方法区？" class="headerlink" title="1.5 能不能解释一下方法区？"></a>1.5 能不能解释一下方法区？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="1-5-1-概述"><a href="#1-5-1-概述" class="headerlink" title="1.5.1 概述"></a>1.5.1 概述</h4><ul>
<li><p>方法区(Method Area)是各个线程共享的内存区域</p>
</li>
<li><p>主要存储类的信息、运行时常量池</p>
</li>
<li><p>虚拟机启动的时候创建，关闭虚拟机时释放</p>
</li>
<li><p>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230506095504213.png" alt="image-20230506095504213"></p>
<h4 id="1-5-2-常量池"><a href="#1-5-2-常量池" class="headerlink" title="1.5.2 常量池"></a>1.5.2 常量池</h4><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p>
<p>查看字节码结构（类的基本信息、常量池、方法定义）<code>javap -v xx.class</code></p>
<p>比如下面是一个Application类的main方法执行，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到类对应的class文件存放目录，执行命令：<code>javap -v Application.class</code>   查看字节码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\code\jvm-demo\target\classes\com\heima\jvm&gt;javap -v Application.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Classfile</span> /D:/code/jvm-demo/target/classes/com/heima/jvm/Application.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2023</span>-<span class="number">05</span>-<span class="number">07</span>; size <span class="number">564</span> bytes    <span class="comment">//最后修改的时间</span></span><br><span class="line">  MD5 checksum c1b64ed6491b9a16c2baab5061c64f88   <span class="comment">//签名</span></span><br><span class="line">  Compiled from <span class="string">&quot;Application.java&quot;</span>   <span class="comment">//从哪个源码编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.heima.jvm.Application   <span class="comment">//包名，类名</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span>     <span class="comment">//jdk版本</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER  <span class="comment">//修饰符</span></span><br><span class="line">Constant pool:   <span class="comment">//常量池</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">21.</span>#<span class="number">22</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">23</span>            <span class="comment">// hello world</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">24.</span>#<span class="number">25</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">26</span>            <span class="comment">// com/heima/jvm/Application</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">27</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/heima/jvm/Application;</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               args</span><br><span class="line">  #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">19</span> = Utf8               Application.java</span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">21</span> = Class              #<span class="number">28</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">29</span>:#<span class="number">30</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               hello world</span><br><span class="line">  #<span class="number">24</span> = Class              #<span class="number">31</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">25</span> = NameAndType        #<span class="number">32</span>:#<span class="number">33</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">26</span> = Utf8               com/heima/jvm/Application</span><br><span class="line">  #<span class="number">27</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">28</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">29</span> = Utf8               out</span><br><span class="line">  #<span class="number">30</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">31</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">32</span> = Utf8               println</span><br><span class="line">  #<span class="number">33</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.heima.jvm.Application();  <span class="comment">//构造方法</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/heima/jvm/Application;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;  <span class="comment">//main方法</span></span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Application.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>下图，左侧是main方法的指令信息，右侧constant pool  是常量池</p>
<p>main方法按照指令执行的时候，需要到常量池中查表翻译找到具体的类和方法地址去执行</p>
<p><img src="/blog/images/img/image-20230506095634842.png" alt="image-20230506095634842"></p>
<h4 id="1-5-3-运行时常量池"><a href="#1-5-3-运行时常量池" class="headerlink" title="1.5.3 运行时常量池"></a>1.5.3 运行时常量池</h4><p>常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p>
<p><img src="/blog/images/img/image-20230506100142724.png" alt="image-20230506100142724"></p>
<h3 id="1-6-你听过直接内存吗？"><a href="#1-6-你听过直接内存吗？" class="headerlink" title="1.6 你听过直接内存吗？"></a>1.6 你听过直接内存吗？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p>
<p>举例：</p>
<p>需求，在本地电脑中的一个较大的文件（超过100m）从一个磁盘挪到另外一个磁盘</p>
<p><img src="/blog/images/img/image-20230506100501905.png" alt="image-20230506100501905"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 ByteBuffer 作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_9</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;E:\\编程资料\\第三方教学视频\\youtube\\Getting Started with Spring Boot-sbPSjI4tt10.mp4&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;E:\\a.mp4&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        io(); <span class="comment">// io 用时：1535.586957 1766.963399 1359.240226</span></span><br><span class="line">        directBuffer(); <span class="comment">// directBuffer 用时：479.295165 702.291454 562.56592</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">             <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(bb);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bb.flip();</span><br><span class="line">                to.write(bb);</span><br><span class="line">                bb.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">io</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM);</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[_1Mb];</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(buf);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                to.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;io 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。</p>
<p>这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程</p>
<p><img src="/blog/images/img/image-20230506100548455.png" alt="image-20230506100548455"></p>
<p>下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。</p>
<p><img src="/blog/images/img/image-20230506100621146.png" alt="image-20230506100621146"></p>
<h3 id="1-7-堆栈的区别是什么？"><a href="#1-7-堆栈的区别是什么？" class="headerlink" title="1.7 堆栈的区别是什么？"></a>1.7 堆栈的区别是什么？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p>
<p>2、栈内存是线程私有的，而堆内存是线程共有的。</p>
<p>3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p>
<p>栈空间不足：java.lang.StackOverFlowError。</p>
<p>堆空间不足：java.lang.OutOfMemoryError。</p>
<h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h2><h3 id="2-1-什么是类加载器，类加载器有哪些"><a href="#2-1-什么是类加载器，类加载器有哪些" class="headerlink" title="2.1 什么是类加载器，类加载器有哪些?"></a>2.1 什么是类加载器，类加载器有哪些?</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>要想理解类加载器的话，务必要先清楚对于一个Java文件，它从编译到执行的整个过程。</p>
<p><img src="/blog/images/img/image-20220903233627146.png"></p>
<ul>
<li>类加载器：用于装载字节码文件(.class文件)</li>
<li>运行时数据区：用于分配存储空间</li>
<li>执行引擎：执行字节码文件或本地方法</li>
<li>垃圾回收器：用于对JVM中的垃圾内容进行回收</li>
</ul>
<p><strong>类加载器</strong></p>
<p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源</p>
<p><strong>类加载器种类</strong></p>
<p>类加载器根据各自加载范围的不同，划分为四种类加载器：</p>
<ul>
<li><p><strong>启动类加载器(BootStrap ClassLoader)：</strong></p>
<p>该类并不继承ClassLoader类，其是由C++编写实现。用于加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib</strong>目录下的类库。</p>
</li>
<li><p><strong>扩展类加载器(ExtClassLoader)：</strong></p>
<p>该类是ClassLoader的子类，主要加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</strong>目录中的类库。</p>
</li>
<li><p><strong>应用类加载器(AppClassLoader)：</strong></p>
<p>该类是ClassLoader的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。</p>
</li>
<li><p><strong>自定义类加载器：</strong></p>
<p>开发者自定义类继承ClassLoader，实现自定义类加载规则。</p>
</li>
</ul>
<p>上述三种类加载器的层次结构如下如下：</p>
<p><img src="/blog/images/img/image-20230506100746624.png" alt="image-20230506100746624"></p>
<p>类加载器的体系并不是“继承”体系，而是<strong>委派体系</strong>，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。</p>
<h3 id="2-2-什么是双亲委派模型？"><a href="#2-2-什么是双亲委派模型？" class="headerlink" title="2.2 什么是双亲委派模型？"></a>2.2 什么是双亲委派模型？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 </p>
<p><img src="/blog/images/img/image-20230506100920042.png" alt="image-20230506100920042"></p>
<h3 id="2-3-JVM为什么采用双亲委派机制"><a href="#2-3-JVM为什么采用双亲委派机制" class="headerlink" title="2.3 JVM为什么采用双亲委派机制"></a>2.3 JVM为什么采用双亲委派机制</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p>
<p>（2）为了安全，保证类库API不会被修改</p>
<p>在工程中新建java.lang包，接着在该包下新建String类，并定义main函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	此时执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法</p>
<p><img src="/blog/images/img/image-20220903144547378.png" alt="image-20220903144547378"></p>
<p>​	出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库。</p>
<h3 id="2-4-说一下类装载的执行过程？"><a href="#2-4-说一下类装载的执行过程？" class="headerlink" title="2.4 说一下类装载的执行过程？"></a>2.4 说一下类装载的执行过程？</h3><blockquote>
<p>难易程度：☆☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。</p>
<p><img src="/blog/images/img/image-20230506101032605.png" alt="image-20230506101032605"></p>
<p><strong>类加载过程详解</strong></p>
<p>1.加载</p>
<p><img src="/blog/images/img/image-20230506101115674.png" alt="image-20230506101115674"> </p>
<ul>
<li><p>通过类的全名，获取类的二进制数据流。</p>
</li>
<li><p>解析类的二进制数据流为方法区内的数据结构（Java类模型） </p>
</li>
<li><p>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230506101213373.png" alt="image-20230506101213373"></p>
<p>2.验证</p>
<p><img src="/blog/images/img/image-20230506101420202.png" alt="image-20230506101420202"></p>
<p><strong>验证类是否符合JVM规范，安全性检查</strong></p>
<p>(1)文件格式验证:是否符合Class文件的规范<br>(2)元数据验证<br>    这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）<br>    这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承）<br>    类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）						<br>(3)字节码验证<br>    主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。<br>(4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p>
<blockquote>
<p>比如：int i &#x3D; 3;<br>字面量：3<br>符号引用：i</p>
</blockquote>
<p>3.准备</p>
<p><img src="/blog/images/img/image-20230506101445898.png" alt="image-20230506101445898"></p>
<p><strong>为类变量分配内存并设置类变量初始值</strong></p>
<ul>
<li><p>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</p>
</li>
<li><p>static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成</p>
</li>
<li><p>static变量是final的引用类型，那么赋值也会在初始化阶段完成</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230506101824622.png" alt="image-20230506101824622"></p>
<p>4.解析</p>
<p><img src="/blog/images/img/image-20230506101504632.png" alt="image-20230506101504632"></p>
<p><strong>把类中的符号引用转换为直接引用</strong></p>
<p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p>
<p><img src="/blog/images/img/image-20230506102311951.png" alt="image-20230506102311951"></p>
<p>5.初始化</p>
<p><img src="/blog/images/img/image-20230506101625087.png" alt="image-20230506101625087"></p>
<p><strong>对类的静态变量，静态代码块执行初始化操作</strong></p>
<ul>
<li><p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
</li>
<li><p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
</li>
</ul>
<p>6.使用</p>
<p><img src="/blog/images/img/image-20230506101641837.png" alt="image-20230506101641837"></p>
<p>JVM 开始从入口方法开始执行用户的程序代码</p>
<ul>
<li><p>调用静态类成员信息（比如：静态字段、静态方法）</p>
</li>
<li><p>使用new关键字为其创建对象实例</p>
</li>
</ul>
<p>7.卸载</p>
<p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p>
<h2 id="3-垃圾收回"><a href="#3-垃圾收回" class="headerlink" title="3 垃圾收回"></a>3 垃圾收回</h2><h3 id="3-1-简述Java垃圾回收机制？（GC是什么？为什么要GC）"><a href="#3-1-简述Java垃圾回收机制？（GC是什么？为什么要GC）" class="headerlink" title="3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）"></a>3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p>
<p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p>
<p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p>
<p>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。</p>
<p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p>
<h3 id="3-2-对象什么时候可以被垃圾器回收"><a href="#3-2-对象什么时候可以被垃圾器回收" class="headerlink" title="3.2 对象什么时候可以被垃圾器回收"></a>3.2 对象什么时候可以被垃圾器回收</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p><img src="/blog/images/img/image-20230506104954777.png" alt="image-20230506104954777"></p>
<p>简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p>
<p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p>
<h4 id="3-2-1-引用计数法"><a href="#3-2-1-引用计数法" class="headerlink" title="3.2.1 引用计数法"></a>3.2.1 引用计数法</h4><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20230506111102825.png" alt="image-20230506111102825"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20230506111136231.png" alt="image-20230506111136231"></p>
<p>当对象间出现了循环引用的话，则引用计数法就会失效</p>
<p><img src="/blog/images/img/image-20230506111255401.png" alt="image-20230506111255401"></p>
<p>先执行右侧代码的前4行代码</p>
<p><img src="/blog/images/img/image-20230506111327590.png" alt="image-20230506111327590"></p>
<p>目前上方的引用关系和计数都是没问题的，但是，如果代码继续往下执行，如下图</p>
<p><img src="/blog/images/img/image-20230506111512450.png" alt="image-20230506111512450"></p>
<p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p>
<p>优点：</p>
<ul>
<li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li>
<li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。</li>
<li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li>
</ul>
<p>缺点：</p>
<ul>
<li>每次对象被引用时，都需要去更新计数器，有一点时间开销。 </li>
<li><strong>浪费CPU资源</strong>，即使内存够用，仍然在运行时进行计数器的统计。</li>
<li><strong>无法解决循环引用问题，会引发内存泄露</strong>。（最大的缺点）</li>
</ul>
<h4 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h4><p>​	现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。</p>
<p>​	会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。</p>
<blockquote>
<p>根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象</p>
<p>局部变量，静态方法，静态变量，类信息</p>
<p>核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收</p>
</blockquote>
<p><img src="/blog/images/img/image-20220904010634153.png" alt="image-20220904010634153"></p>
<p>​	X,Y这两个节点是可回收的，但是<strong>并不会马上的被回收！！</strong> 对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先<strong>会判断这个对象是否执行了finalize方法</strong>，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。</p>
<p>​	finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。</p>
<p><strong>GC ROOTS：</strong></p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * demo是栈帧中的本地变量，当 demo = null 时，由于此时 demo 充当了 GC Root 的作用，demo与原来指向的实例 new Demo() 断开了连接，对象被回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    	demo = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法区中类静态属性引用的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当栈帧中的本地变量 b = null 时，由于 b 原来指向的对象与 GC Root (变量 b) 断开了连接，所以 b 原来指向的对象会被回收，而由于我们给 a 赋值了变量的引用，a在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        b.a = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法区中常量引用的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常量 a 指向的对象并不会因为 demo 指向的对象被回收而回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Demo</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        demo = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<h3 id="3-3-JVM-垃圾回收算法有哪些？"><a href="#3-3-JVM-垃圾回收算法有哪些？" class="headerlink" title="3.3 JVM 垃圾回收算法有哪些？"></a>3.3 JVM 垃圾回收算法有哪些？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="3-3-1-标记清除算法"><a href="#3-3-1-标记清除算法" class="headerlink" title="3.3.1 标记清除算法"></a>3.3.1 标记清除算法</h4><p>标记清除算法，是将垃圾回收分为2个阶段，分别是<strong>标记和清除</strong>。</p>
<p>1.根据可达性分析算法得出的垃圾进行标记</p>
<p>2.对这些标记为可回收的内容进行垃圾回收</p>
<p><img src="/blog/images/img/image-20230506112047190.png" alt="image-20230506112047190"></p>
<p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p>
<p>同样，标记清除算法也是有缺点的：</p>
<ul>
<li>效率较低，<strong>标记和清除两个动作都需要遍历所有的对象</strong>，并且在GC时，<strong>需要停止应用程序</strong>，对于交互性要求比较高的应用而言这个体验是非常差的。</li>
<li>（<strong>重要</strong>）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li>
</ul>
<h4 id="3-3-2-复制算法"><a href="#3-3-2-复制算法" class="headerlink" title="3.3.2 复制算法"></a>3.3.2 复制算法</h4><p>​	复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p>
<p>​	如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。 </p>
<p><img src="/blog/images/img/image-20230506111919008.png" alt="image-20230506111919008"></p>
<p>1）将内存区域分成两部分，每次操作其中一个。</p>
<p>2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区域一次性清除。</p>
<p>3）周而复始。</p>
<p>优点：</p>
<ul>
<li>在垃圾对象多的情况下，效率较高</li>
<li>清理后，内存无碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li>
</ul>
<h4 id="3-3-3-标记整理算法"><a href="#3-3-3-标记整理算法" class="headerlink" title="3.3.3 标记整理算法"></a>3.3.3 标记整理算法</h4><p>​	标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p>
<p><img src="/blog/images/img/image-20230506111957793.png" alt="image-20230506111957793"></p>
<p>1）标记垃圾。</p>
<p>2）需要清除向右边走，不需要清除的向左边走。</p>
<p>3）清除边界以外的垃圾。</p>
<p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p>
<p>与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理</p>
<h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h4><p>在java8时，堆被分为了两份：<strong>新生代和老年代【1：2】</strong>，在java7时，还存在一个永久代。</p>
<p><img src="/blog/images/img/image-20230506131229649.png" alt="image-20230506131229649"></p>
<p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】</p>
<p>当对新生代产生GC：MinorGC【young GC】</p>
<p>当对老年代代产生GC：Major GC </p>
<p>当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
<h4 id="3-4-2工作机制"><a href="#3-4-2工作机制" class="headerlink" title="3.4.2工作机制"></a>3.4.2工作机制</h4><p><img src="/blog/images/img/image-20230506131308654.png" alt="image-20230506131308654"></p>
<ul>
<li>新创建的对象，都会先分配到eden区</li>
</ul>
<p><img src="/blog/images/img/image-20230506131415418.png" alt="image-20230506131415418"></p>
<ul>
<li><p>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</p>
</li>
<li><p>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230506131442503.png" alt="image-20230506131442503"></p>
<ul>
<li>经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区</li>
</ul>
<p><img src="/blog/images/img/image-20230506131544447.png" alt="image-20230506131544447"></p>
<p><img src="/blog/images/img/image-20230506131607645.png" alt="image-20230506131607645"></p>
<ul>
<li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li>
</ul>
<p><strong>MinorGC、 Mixed GC 、 FullGC的区别是什么</strong></p>
<p><img src="/blog/images/img/image-20230506131640893.png" alt="image-20230506131640893"></p>
<ul>
<li><p>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</p>
</li>
<li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p>
</li>
<li><p>FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免？</p>
</li>
</ul>
<blockquote>
<p>名词解释：</p>
<p>STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成</p>
</blockquote>
<h3 id="3-5-说一下-JVM-有哪些垃圾回收器？"><a href="#3-5-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="3.5 说一下 JVM 有哪些垃圾回收器？"></a>3.5 说一下 JVM 有哪些垃圾回收器？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>在jvm中，实现了多种垃圾收集器，包括：</p>
<ul>
<li><p>串行垃圾收集器</p>
</li>
<li><p>并行垃圾收集器</p>
</li>
<li><p>CMS（并发）垃圾收集器</p>
</li>
<li><p>G1垃圾收集器</p>
</li>
</ul>
<h4 id="3-5-1-串行垃圾收集器"><a href="#3-5-1-串行垃圾收集器" class="headerlink" title="3.5.1 串行垃圾收集器"></a>3.5.1 串行垃圾收集器</h4><p>Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p>
<ul>
<li><p>Serial 作用于新生代，采用复制算法</p>
</li>
<li><p>Serial Old 作用于老年代，采用标记-整理算法</p>
</li>
</ul>
<p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p>
<p><img src="/blog/images/img/image-20230506154006266.png" alt="image-20230506154006266"></p>
<h4 id="3-5-2-并行垃圾收集器"><a href="#3-5-2-并行垃圾收集器" class="headerlink" title="3.5.2 并行垃圾收集器"></a>3.5.2 并行垃圾收集器</h4><p>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p>
<ul>
<li><p>Parallel New作用于新生代，采用复制算法</p>
</li>
<li><p>Parallel Old作用于老年代，采用标记-整理算法</p>
</li>
</ul>
<p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p>
<p><img src="/blog/images/img/image-20230506154042673.png" alt="image-20230506154042673"></p>
<h4 id="3-5-2-CMS（并发）垃圾收集器"><a href="#3-5-2-CMS（并发）垃圾收集器" class="headerlink" title="3.5.2 CMS（并发）垃圾收集器"></a>3.5.2 CMS（并发）垃圾收集器</h4><p>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。</p>
<p><img src="/blog/images/img/image-20230506154117857.png" alt="image-20230506154117857"></p>
<p><img src="/blog/images/img/image-20230506154107944.png" alt="image-20230506154107944"></p>
<h3 id="3-6-详细聊一下G1垃圾回收器"><a href="#3-6-详细聊一下G1垃圾回收器" class="headerlink" title="3.6 详细聊一下G1垃圾回收器"></a>3.6 详细聊一下G1垃圾回收器</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h4><ul>
<li><p>应用于新生代和老年代，<strong>在<strong><strong>JDK9</strong></strong>之后默认使用****G1</strong></p>
</li>
<li><p>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</p>
</li>
<li><p>采用复制算法</p>
</li>
<li><p>响应时间与吞吐量兼顾</p>
</li>
<li><p>分成三个阶段：新生代回收、并发标记、混合收集</p>
</li>
<li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p>
</li>
</ul>
<p><img src="/blog/images/img/image-20230506154323950.png" alt="image-20230506154323950"></p>
<h4 id="3-6-2-Young-Collection-年轻代垃圾回收"><a href="#3-6-2-Young-Collection-年轻代垃圾回收" class="headerlink" title="3.6.2 Young Collection(年轻代垃圾回收)"></a>3.6.2 Young Collection(年轻代垃圾回收)</h4><ul>
<li><p>初始时，所有区域都处于空闲状态</p>
<p><img src="/blog/images/img/image-20230506154542687.png" alt="image-20230506154542687"></p>
</li>
<li><p>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</p>
<p><img src="/blog/images/img/image-20230506154607558.png" alt="image-20230506154607558"></p>
</li>
<li><p>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</p>
<p><img src="/blog/images/img/image-20230506154633118.png" alt="image-20230506154633118"></p>
<p><img src="/blog/images/img/image-20230506154705088.png" alt="image-20230506154705088"></p>
</li>
<li><p>随着时间流逝，伊甸园的内存又有不足</p>
</li>
<li><p>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</p>
<p><img src="/blog/images/img/image-20230506154759809.png" alt="image-20230506154759809"></p>
<p><img src="/blog/images/img/image-20230506154826981.png" alt="image-20230506154826981"></p>
<p><img src="/blog/images/img/image-20230506154859985.png" alt="image-20230506154859985"></p>
</li>
</ul>
<h4 id="3-6-3-Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记"><a href="#3-6-3-Young-Collection-Concurrent-Mark-年轻代垃圾回收-并发标记" class="headerlink" title="3.6.3 Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)"></a>3.6.3 Young Collection + Concurrent Mark (年轻代垃圾回收+并发标记)</h4><p>当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程</p>
<p><img src="/blog/images/img/image-20230506155000503.png" alt="image-20230506155000503"></p>
<ul>
<li><p>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。</p>
</li>
<li><p>这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</p>
<p><img src="/blog/images/img/image-20230506155047765.png" alt="image-20230506155047765"></p>
</li>
</ul>
<h4 id="3-6-4-Mixed-Collection-混合垃圾回收"><a href="#3-6-4-Mixed-Collection-混合垃圾回收" class="headerlink" title="3.6.4 Mixed Collection (混合垃圾回收)"></a>3.6.4 Mixed Collection (混合垃圾回收)</h4><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p>
<p><img src="/blog/images/img/image-20230506155116267.png" alt="image-20230506155116267"></p>
<p>其中H叫做巨型对象，如果对象非常大，会开辟一块连续的空间存储巨型对象</p>
<p><img src="/blog/images/img/image-20230506155146370.png" alt="image-20230506155146370"></p>
<h3 id="3-7-强引用、软引用、弱引用、虚引用的区别？"><a href="#3-7-强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="3.7 强引用、软引用、弱引用、虚引用的区别？"></a>3.7 强引用、软引用、弱引用、虚引用的区别？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="3-7-1-强引用"><a href="#3-7-1-强引用" class="headerlink" title="3.7.1 强引用"></a>3.7.1 强引用</h4><p>强引用：只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20230506155341703.png" alt="image-20230506155341703"></p>
<h4 id="3-7-2-软引用"><a href="#3-7-2-软引用" class="headerlink" title="3.7.2 软引用"></a>3.7.2 软引用</h4><p>软引用：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">softReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(user);</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20230506155416293.png" alt="image-20230506155416293"></p>
<h4 id="3-7-3-弱引用"><a href="#3-7-3-弱引用" class="headerlink" title="3.7.3 弱引用"></a>3.7.3 弱引用</h4><p>弱引用：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">weakReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(user);</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20230506155501557.png" alt="image-20230506155501557"></p>
<blockquote>
<p>延伸话题：ThreadLocal内存泄漏问题</p>
</blockquote>
<p>ThreadLocal用的就是弱引用，看以下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">         <span class="built_in">super</span>(k);</span><br><span class="line">         value = v; <span class="comment">//强引用，不会被回收</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Entry</code>的key是当前ThreadLocal，value值是我们要设置的数据。</p>
<p><code>WeakReference</code>表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。但是<code>value</code>是强引用，它不会被回收掉。</p>
<blockquote>
<p>ThreadLocal使用建议：使用完毕后注意调用清理方法。</p>
</blockquote>
<h4 id="3-7-4-虚引用"><a href="#3-7-4-虚引用" class="headerlink" title="3.7.4 虚引用"></a>3.7.4 虚引用</h4><p>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p>
<p><img src="/blog/images/img/image-20230506155518510.png" alt="image-20230506155518510"></p>
<p><img src="/blog/images/img/image-20230506155552693.png" alt="image-20230506155552693"></p>
<h2 id="4-JVM实践（调优）"><a href="#4-JVM实践（调优）" class="headerlink" title="4 JVM实践（调优）"></a>4 JVM实践（调优）</h2><h3 id="4-1-JVM-调优的参数可以在哪里设置参数值？"><a href="#4-1-JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="4.1 JVM 调优的参数可以在哪里设置参数值？"></a>4.1 JVM 调优的参数可以在哪里设置参数值？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="4-1-1-tomcat的设置vm参数"><a href="#4-1-1-tomcat的设置vm参数" class="headerlink" title="4.1.1 tomcat的设置vm参数"></a>4.1.1 tomcat的设置vm参数</h4><p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件，如下图</p>
<p><code>JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; </code></p>
<p><img src="/blog/images/img/image-20220904151948778.png" alt="image-20220904151948778"></p>
<h4 id="4-1-2-springboot项目jar文件启动"><a href="#4-1-2-springboot项目jar文件启动" class="headerlink" title="4.1.2 springboot项目jar文件启动"></a>4.1.2 springboot项目jar文件启动</h4><p>通常在linux系统下直接加参数启动springboot项目</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nohup  :  用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p>
<p>参数 <strong>&amp;</strong>  ：让命令在后台执行，终端退出后命令仍旧执行。</p>
</blockquote>
<h3 id="4-2-用的-JVM-调优的参数都有哪些？"><a href="#4-2-用的-JVM-调优的参数都有哪些？" class="headerlink" title="4.2 用的 JVM 调优的参数都有哪些？"></a>4.2 用的 JVM 调优的参数都有哪些？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>​	对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</p>
<p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
<p>1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小</span><br><span class="line"></span><br><span class="line">-Xmx：设置堆的最大大小</span><br></pre></td></tr></table></figure>

<p>2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p>
<p>的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3</span><br></pre></td></tr></table></figure>

<p>3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:newSize   设置年轻代的初始大小</span><br><span class="line">-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</span><br></pre></td></tr></table></figure>

<p>4）线程堆栈的设置：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xss   对每个线程stack大小的调整,-Xss128k</span><br></pre></td></tr></table></figure>

<p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小</p>
<p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p>
<p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold&#x3D;1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p>
<p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。</span><br><span class="line"></span><br><span class="line">（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。</span><br></pre></td></tr></table></figure>

<p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+LargePageSizeInBytes 设置内存页的大小</span><br></pre></td></tr></table></figure>

<p>10）使用非占用的垃圾收集器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。</span><br></pre></td></tr></table></figure>

<h3 id="4-3-说一下-JVM-调优的工具？"><a href="#4-3-说一下-JVM-调优的工具？" class="headerlink" title="4.3 说一下 JVM 调优的工具？"></a>4.3 说一下 JVM 调优的工具？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="4-3-1-命令工具"><a href="#4-3-1-命令工具" class="headerlink" title="4.3.1 命令工具"></a>4.3.1 命令工具</h4><h5 id="4-3-1-1-jps（Java-Process-Status）"><a href="#4-3-1-1-jps（Java-Process-Status）" class="headerlink" title="4.3.1.1 jps（Java Process Status）"></a>4.3.1.1 jps（Java Process Status）</h5><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)</p>
<p><img src="/blog/images/img/image-20220904104739581.png" alt="image-20220904104739581"></p>
<h5 id="4-3-1-2-jstack"><a href="#4-3-1-2-jstack" class="headerlink" title="4.3.1.2 jstack"></a>4.3.1.2 jstack</h5><p>查看java进程内<strong>线程的堆栈</strong>信息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jstack [option] &lt;pid&gt;  </span><br></pre></td></tr></table></figure>

<p>java案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用jstack查看进行堆栈运行信息</p>
<p><img src="/blog/images/img/image-20220904111059602.png" alt="image-20220904111059602"></p>
<h5 id="4-3-1-3-jmap"><a href="#4-3-1-3-jmap" class="headerlink" title="4.3.1.3 jmap"></a>4.3.1.3 jmap</h5><p>用于生成堆转存快照</p>
<blockquote>
<p>jmap [options] pid  内存映像信息</p>
<p>jmap -heap pid   显示Java堆的信息</p>
<p>jmap -dump:format&#x3D;b,file&#x3D;heap.hprof pid</p>
<p>​		format&#x3D;b表示以hprof二进制格式转储Java堆的内存<br>​		file&#x3D;<filename>用于指定快照dump文件的文件名。</p>
</blockquote>
<p>例：显示了某一个java运行的堆信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\yuhon&gt;jmap -heap <span class="number">53280</span></span><br><span class="line">Attaching to process ID <span class="number">53280</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.321</span>-b07</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">8</span> thread(s)   <span class="comment">//并行的垃圾回收器</span></span><br><span class="line"></span><br><span class="line">Heap Configuration:  <span class="comment">//堆配置</span></span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span>   <span class="comment">//空闲堆空间的最小百分比</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span>  <span class="comment">//空闲堆空间的最大百分比</span></span><br><span class="line">   MaxHeapSize              = <span class="number">8524922880</span> (<span class="number">8130.</span>0MB) <span class="comment">//堆空间允许的最大值</span></span><br><span class="line">   NewSize                  = <span class="number">178257920</span> (<span class="number">170.</span>0MB) <span class="comment">//新生代堆空间的默认值</span></span><br><span class="line">   MaxNewSize               = <span class="number">2841640960</span> (<span class="number">2710.</span>0MB) <span class="comment">//新生代堆空间允许的最大值</span></span><br><span class="line">   OldSize                  = <span class="number">356515840</span> (<span class="number">340.</span>0MB) <span class="comment">//老年代堆空间的默认值</span></span><br><span class="line">   NewRatio                 = <span class="number">2</span> <span class="comment">//新生代与老年代的堆空间比值，表示新生代：老年代=1：2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span> <span class="comment">//两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB) <span class="comment">//元空间的默认值</span></span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB) <span class="comment">//压缩类使用空间大小</span></span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB <span class="comment">//元空间允许的最大值</span></span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.</span>0MB)<span class="comment">//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</span></span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space: <span class="comment">//Eden使用情况</span></span><br><span class="line">   capacity = <span class="number">134217728</span> (<span class="number">128.</span>0MB)</span><br><span class="line">   used     = <span class="number">10737496</span> (<span class="number">10.</span>240074157714844MB)</span><br><span class="line">   free     = <span class="number">123480232</span> (<span class="number">117.</span>75992584228516MB)</span><br><span class="line">   <span class="number">8.000057935714722</span>% used</span><br><span class="line">From Space: <span class="comment">//Survivor-From 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space: <span class="comment">//Survivor-To 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation  <span class="comment">//老年代 使用情况</span></span><br><span class="line">   capacity = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">3185</span> interned Strings occupying <span class="number">261264</span> bytes.</span><br></pre></td></tr></table></figure>



<h5 id="4-3-1-4-jhat"><a href="#4-3-1-4-jhat" class="headerlink" title="4.3.1.4 jhat"></a>4.3.1.4 jhat</h5><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p>
<h5 id="4-3-1-5-jstat"><a href="#4-3-1-5-jstat" class="headerlink" title="4.3.1.5 jstat"></a>4.3.1.5 jstat</h5><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</p>
<p><strong>常见参数</strong>：</p>
<p>①总结垃圾回收统计</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jstat -gcutil pid</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20220904114511854.png" alt="image-20220904114511854"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S0</td>
<td>幸存1区当前使用比例</td>
</tr>
<tr>
<td>S1</td>
<td>幸存2区当前使用比例</td>
</tr>
<tr>
<td>E</td>
<td>伊甸园区使用比例</td>
</tr>
<tr>
<td>O</td>
<td>老年代使用比例</td>
</tr>
<tr>
<td>M</td>
<td>元数据区使用比例</td>
</tr>
<tr>
<td>CCS</td>
<td>压缩使用比例</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代垃圾回收消耗时间</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间</td>
</tr>
</tbody></table>
<p>②垃圾回收统计</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jstat -gc pid</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20220904115157363.png" alt="image-20220904115157363"></p>
<h4 id="4-3-2-可视化工具"><a href="#4-3-2-可视化工具" class="headerlink" title="4.3.2 可视化工具"></a>4.3.2 可视化工具</h4><h5 id="4-3-2-1-jconsole"><a href="#4-3-2-1-jconsole" class="headerlink" title="4.3.2.1 jconsole"></a>4.3.2.1 jconsole</h5><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p>
<p><img src="/blog/images/img/image-20220904115936095.png" alt="image-20220904115936095"></p>
<p>可以内存、线程、类等信息</p>
<p><img src="/blog/images/img/image-20220904120057211.png" alt="image-20220904120057211"></p>
<h5 id="4-3-2-2-VisualVM：故障处理工具"><a href="#4-3-2-2-VisualVM：故障处理工具" class="headerlink" title="4.3.2.2 VisualVM：故障处理工具"></a>4.3.2.2 VisualVM：故障处理工具</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>
<p><img src="/blog/images/img/image-20220904120356174.png" alt="image-20220904120356174"></p>
<p>监控程序运行情况</p>
<p><img src="/blog/images/img/image-20220904132011289.png" alt="image-20220904132011289"></p>
<p>查看运行中的dump</p>
<p><img src="/blog/images/img/image-20220904132134095.png" alt="image-20220904132134095"></p>
<p>查看堆中的信息</p>
<p><img src="/blog/images/img/image-20220904132346495.png" alt="image-20220904132346495"></p>
<h3 id="4-4-java内存泄露的排查思路？"><a href="#4-4-java内存泄露的排查思路？" class="headerlink" title="4.4 java内存泄露的排查思路？"></a>4.4 java内存泄露的排查思路？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>原因：</p>
<p>如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常</p>
<p>如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常</p>
<p>如果一次加载的类太多，元空间内存不足，则会报OutOfMemoryError: Metaspace</p>
<p><img src="/blog/images/img/image-20230506155704119.png" alt="image-20230506155704119"></p>
<p>1、通过jmap指定打印他的内存快照 dump</p>
<blockquote>
<p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：</p>
<p>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;app&#x2F;dumps&#x2F;      指定生成后文件的保存目录</p>
</blockquote>
<p>2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件</p>
<p>VisualVM可以加载离线的dump文件，如下图</p>
<p>文件–&gt;装入—&gt;选择dump文件即可查看堆快照信息</p>
<blockquote>
<p>如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化</p>
</blockquote>
<p><img src="/blog/images/img/image-20220904132925812.png" alt="image-20220904132925812"></p>
<p>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p>
<p><img src="/blog/images/img/image-20220904133722905.png" alt="image-20220904133722905"></p>
<p>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
<h3 id="4-5-CPU飙高排查方案与思路？"><a href="#4-5-CPU飙高排查方案与思路？" class="headerlink" title="4.5 CPU飙高排查方案与思路？"></a>4.5 CPU飙高排查方案与思路？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>1.使用top命令查看占用cpu的情况</p>
<p><img src="/blog/images/img/image-20220904161818255.png" alt="image-20220904161818255"></p>
<p>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978</p>
<p>3.查看当前线程中的进程信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 40940</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pid  进行id</p>
<p>tid   进程中的线程id</p>
<p>%  cpu使用率 </p>
</blockquote>
<p><img src="/blog/images/img/image-20220904162117022.png" alt="image-20220904162117022"></p>
<p>4.通过上图分析，在进程30978中的线程30979占用cpu较高</p>
<blockquote>
<p>注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称</p>
<p>转换方式：</p>
<p>在linux中执行命令</p>
<p><code>printf &quot;%x\n&quot; 30979</code></p>
<p><img src="/blog/images/img/image-20220904162654928.png" alt="image-20220904162654928"></p>
</blockquote>
<p>5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号</p>
<p>执行命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jstack 30978   此处是进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/img/image-20220904162941977.png" alt="image-20220904162941977"></p>
<h2 id="5-面试现场"><a href="#5-面试现场" class="headerlink" title="5.面试现场"></a>5.面试现场</h2><h3 id="5-1-JVM组成"><a href="#5-1-JVM组成" class="headerlink" title="5.1 JVM组成"></a>5.1 JVM组成</h3><blockquote>
<p><strong>面试官</strong>：JVM由那些部分组成，运行流程是什么？</p>
<p><strong>候选人:</strong></p>
<p>嗯，好的~~</p>
<p>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）</p>
<p>它们的运行流程是：</p>
<p>第一，类加载器（ClassLoader）把Java代码转换为字节码</p>
<p>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p>
<p>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p>
<p><strong>面试官</strong>：好的，你能详细说一下 JVM 运行时数据区吗？</p>
<p><strong>候选人:</strong></p>
<p>嗯，好~</p>
<p>运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。</p>
<ul>
<li>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</li>
<li>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</li>
<li>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</li>
<li>程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</li>
</ul>
<p><strong>面试官</strong>：好的，你再详细介绍一下程序计数器的作用？</p>
<p><strong>候选人:</strong></p>
<p>嗯，是这样~~</p>
<p>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。</p>
<p><strong>面试官</strong>：你能给我详细的介绍Java堆吗?</p>
<p><strong>候选人:</strong></p>
<p>好的~</p>
<p>Java中的堆术语线程共享的区域。主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p>
<p>​	在JAVA8中堆内会存在年轻代、老年代</p>
<p>​	1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p>
<p>​	2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。</p>
<p><strong>面试官</strong>：能不能解释一下方法区？</p>
<p><strong>候选人:</strong></p>
<p>好的~</p>
<p>与虚拟机栈类似。本地方法栈是为虚拟机<strong>执行本地方法时提供服务的</strong>。不需要进行GC。本地方法一般是由其他语言编写。</p>
<p><strong>面试官</strong>：你听过直接内存吗？</p>
<p><strong>候选人:</strong></p>
<p>嗯~~</p>
<p>它又叫做<strong>堆外内存</strong>，<strong>线程共享的区域</strong>，在 Java 8 之前有个<strong>永久代</strong>的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，<strong>主要存储类的信息，常量，静态变量</strong>，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。</p>
<p>​	所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。</p>
<p><strong>面试官</strong>：什么是虚拟机栈</p>
<p><strong>候选人:</strong></p>
<p>虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建<strong>栈桢</strong>。保存执行方法时的<strong>局部变量、动态连接信息、方法返回地址信息</strong>等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域<strong>不需要进行 GC</strong>。</p>
<p><strong>面试官</strong>：能说一下堆栈的区别是什么吗？</p>
<p><strong>候选人:</strong></p>
<p>嗯，好的，有这几个区别</p>
<p>第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p>
<p>第二、栈内存是线程私有的，而堆内存是线程共有的。</p>
<p>第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p>
<p>栈空间不足：java.lang.StackOverFlowError。</p>
<p>堆空间不足：java.lang.OutOfMemoryError。</p>
</blockquote>
<h3 id="5-2-类加载器"><a href="#5-2-类加载器" class="headerlink" title="5.2 类加载器"></a>5.2 类加载器</h3><blockquote>
<p><strong>面试官</strong>：什么是类加载器，类加载器有哪些?</p>
<p><strong>候选人:</strong></p>
<p>嗯，是这样的</p>
<p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p>
<p>常见的类加载器有4个</p>
<p>第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的类库。</p>
<p>第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类库。</p>
<p>第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</p>
<p>第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。</p>
<p><strong>面试官</strong>：说一下类装载的执行过程？</p>
<p><strong>候选人:</strong></p>
<p>嗯，这个过程还是挺多的。</p>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p>
<p>1.加载：查找和导入class文件</p>
<p>2.验证：保证加载类的准确性</p>
<p>3.准备：为类变量分配内存并设置类变量初始值</p>
<p>4.解析：把类中的符号引用转换为直接引用</p>
<p>5.初始化：对类的静态变量，静态代码块执行初始化操作</p>
<p>6.使用：JVM 开始从入口方法开始执行用户的程序代码</p>
<p>7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p>
<p><strong>面试官</strong>：什么是双亲委派模型？</p>
<p><strong>候选人:</strong></p>
<p>嗯，它是是这样的。</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载</p>
<p><strong>面试官</strong>：JVM为什么采用双亲委派机制</p>
<p><strong>候选人:</strong></p>
<p>主要有两个原因。</p>
<p>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p>
<p>第二、为了安全，保证类库API不会被修改</p>
</blockquote>
<h3 id="5-3-垃圾回收"><a href="#5-3-垃圾回收" class="headerlink" title="5.3 垃圾回收"></a>5.3 垃圾回收</h3><blockquote>
<p><strong>面试官</strong>：简述Java垃圾回收机制？（GC是什么？为什么要GC）</p>
<p><strong>候选人:</strong></p>
<p>嗯，是这样~~</p>
<p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p>
<p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p>
<p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p>
<p><strong>面试官</strong>：强引用、软引用、弱引用、虚引用的区别？</p>
<p><strong>候选人:</strong></p>
<p>嗯嗯~</p>
<p>强引用最为普通的引用方式，表示一个对象处于<strong>有用且必须</strong>的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p>
<p>软引用表示一个对象处于<strong>有用且非必须</strong>状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。</p>
<p>弱引用表示一个对象处于<strong>可能有用且非必须</strong>的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。</p>
<p>虚引用表示一个对象处于<strong>无用</strong>的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用</p>
<p><strong>面试官</strong>：对象什么时候可以被垃圾器回收</p>
<p><strong>候选人:</strong></p>
<p>思考一会~~</p>
<p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p>
<p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p>
<p>通常都使用可达性分析算法来确定是不是垃圾</p>
<p><strong>面试官</strong>： JVM 垃圾回收算法有哪些？</p>
<p><strong>候选人:</strong></p>
<p>我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收</p>
<p><strong>面试官</strong>： 你能详细聊一下分代回收吗？</p>
<p><strong>候选人:</strong></p>
<p>关于分代回收是这样的</p>
<p>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2</p>
<p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1</p>
<p>具体的工作机制是有些情况：</p>
<p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p>
<p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p>
<p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。</p>
<p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。</p>
<p>5）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong>  ），那么这个对象就会进入到老年代中。</p>
<p>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代</p>
<p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。</p>
<p><strong>面试官</strong>：讲一下新生代、老年代、永久代的区别？</p>
<p><strong>候选人:</strong></p>
<p>嗯！是这样的，简单说就是</p>
<p><strong>新生代</strong>主要用来存放新生的对象。</p>
<p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。</p>
<p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
<p><strong>面试官</strong>：说一下 JVM 有哪些垃圾回收器？</p>
<p><strong>候选人:</strong></p>
<p>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）</p>
<p><strong>面试官</strong>：Minor GC、Major GC、Full GC是什么</p>
<p><strong>候选人:</strong></p>
<p>嗯，其实它们指的是不同代之间的垃圾回收</p>
<p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>
<p>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长</p>
<p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
</blockquote>
<h3 id="5-4-JVM实践（调优）"><a href="#5-4-JVM实践（调优）" class="headerlink" title="5.4 JVM实践（调优）"></a>5.4 JVM实践（调优）</h3><blockquote>
<p><strong>面试官</strong>：JVM 调优的参数可以在哪里设置参数值？</p>
<p><strong>候选人:</strong></p>
<p>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了</p>
<p><strong>面试官</strong>：用的 JVM 调优的参数都有哪些？</p>
<p><strong>候选人:</strong></p>
<p>嗯，这些参数是比较多的</p>
<p>我记得当时我们设置过堆的大小，像-Xms和-Xmx</p>
<p>还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例</p>
<p>还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。</p>
<p><strong>面试官</strong>：嗯，好的，你们平时调试 JVM都用了哪些工具呢？</p>
<p><strong>候选人:</strong></p>
<p>嗯，我们一般都是使用jdk自带的一些工具，比如</p>
<p>jps 输出JVM中运行的进程状态信息</p>
<p>jstack查看java进程内<strong>线程的堆栈</strong>信息。</p>
<p>jmap 用于生成堆转存快照</p>
<p>jstat用于JVM统计监测工具</p>
<p>还有一些可视化工具，像jconsole和VisualVM等</p>
<p><strong>面试官</strong>：假如项目中产生了java内存泄露，你说一下你的排查思路？</p>
<p><strong>候选人:</strong></p>
<p>嗯，这个我在之前项目排查过</p>
<p>第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件</p>
<p>第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析</p>
<p>第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p>
<p>第四，找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
<p><strong>面试官</strong>：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？</p>
<p><strong>候选人:</strong></p>
<p>嗯，我思考一下~~</p>
<p>可以这么做~~</p>
<p>第一可以使用使用top命令查看占用cpu的情况</p>
<p>第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id</p>
<p>第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高</p>
<p>第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>5.条件注解</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/5.Spring%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h1><p>条件注解就是在满足某一个条件的情况下，生效的配置。</p>
<blockquote>
<p>1.条件注解<br>首先在 Windows 中如何获取操作系统信息？Windows 中查看文件夹目录的命令是 dir，Linux 中查看文件夹目录的命令是 ls，我现在希望当系统运行在 Windows 上时，自动打印出 Windows 上的目录展示命令，Linux 运行时，则自动展示 Linux 上的目录展示命令。</p>
</blockquote>
<p>首先定义一个显示文件夹目录的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShowCmd</span> &#123;</span><br><span class="line">    String <span class="title function_">showCmd</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，分别实现  Windows 下的实例和 Linux 下的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WinShowCmd</span> <span class="keyword">implements</span> <span class="title class_">ShowCmd</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showCmd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;dir&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinuxShowCmd</span> <span class="keyword">implements</span> <span class="title class_">ShowCmd</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showCmd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;ls&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，定义两个条件，一个是 Windows 下的条件，另一个是 Linux 下的条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinuxCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在定义 Bean 的时候，就可以去配置条件注解了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;showCmd&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(WindowsCondition.class)</span></span><br><span class="line">    ShowCmd <span class="title function_">winCmd</span><span class="params">()</span> &#123;</span><br><span class="line">        returnnew <span class="title function_">WinShowCmd</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;showCmd&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(LinuxCondition.class)</span></span><br><span class="line">    ShowCmd <span class="title function_">linuxCmd</span><span class="params">()</span> &#123;</span><br><span class="line">        returnnew <span class="title function_">LinuxShowCmd</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，一定要给两个 Bean 取相同的名字，这样在调用时，才可以自动匹配。然后，给每一个 Bean 加上条件注解，当条件中的 matches 方法返回 true 的时候，这个 Bean 的定义就会生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line">        <span class="type">ShowCmd</span> <span class="variable">showCmd</span> <span class="operator">=</span> (ShowCmd) ctx.getBean(<span class="string">&quot;showCmd&quot;</span>);</span><br><span class="line">        System.out.println(showCmd.showCmd());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.多环境切换<br>开发中，如何在 开发&#x2F;生产&#x2F;测试 环境之间进行快速切换？Spring 中提供了 Profile 来解决这个问题，Profile 的底层就是条件注解。这个从 @Profile 注解的定义就可以看出来：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(ProfileCondition.class)</span></span><br><span class="line"><span class="keyword">public</span><span class="meta">@interface</span> Profile &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The set of profiles for which the annotated component should be registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProfileCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">		MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">		<span class="keyword">if</span> (attrs != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Object value : attrs.get(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line">					returntrue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			returnfalse;</span><br><span class="line">		&#125;</span><br><span class="line">		returntrue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>
<p>我们定义一个 DataSource：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;DataSource&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在配置 Bean 时，通过 @Profile 注解指定不同的环境：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;ds&quot;)</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">DataSource <span class="title function_">devDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSource</span>();</span><br><span class="line">    dataSource.setUrl(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/dev&quot;</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean(&quot;ds&quot;)</span></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">DataSource <span class="title function_">prodDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSource</span>();</span><br><span class="line">    dataSource.setUrl(<span class="string">&quot;jdbc:mysql://192.158.222.33:3306/dev&quot;</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">&quot;jkldasjfkl&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;jfsdjflkajkld&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在加载配置类，注意，需要先设置当前环境，然后再去加载配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">        ctx.register(JavaConfig.class);</span><br><span class="line">        ctx.refresh();</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (DataSource) ctx.getBean(<span class="string">&quot;ds&quot;</span>);</span><br><span class="line">        System.out.println(ds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是在 Java 代码中配置的。环境的切换，也可以在 XML 文件中配置，如下配置在 XML 文件中，必须放在其他节点后面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.DataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///devdb&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.DataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://111.111.111.111/devdb&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jsdfaklfj789345fjsd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动类中设置当前环境并加载配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line">        ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;prod&quot;</span>);</span><br><span class="line">        ctx.setConfigLocation(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        ctx.refresh();</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>7.Spring Aop</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/7.SpringAop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Aop（Aspect Oriented Programming），面向切面编程，这是对面向对象思想的一种补充。</p>
<p>面向切面编程，就是在程序运行时，不改变程序源码的情况下，动态的增强方法的功能，常见的使用场景非常多：</p>
<p>日志<br>事务<br>数据库操作<br>….<br>这些操作中，无一例外，都有很多模板化的代码，而解决模板化代码，消除臃肿就是 Aop 的强项。</p>
<p>在 Aop 中，有几个常见的概念：</p>
<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>切点</td>
<td>要添加代码的地方，称作切点</td>
</tr>
<tr>
<td>通知（增强）</td>
<td>通知就是向切点动态添加的代码</td>
</tr>
<tr>
<td>切面</td>
<td>切点+通知</td>
</tr>
<tr>
<td>连接点</td>
<td>切点的定义</td>
</tr>
</tbody></table>
<blockquote>
<p>Aop 的实现</p>
</blockquote>
<p>在 Aop 实际上集基于 Java 动态代理来实现的。</p>
<p>Java 中的动态代理有两种实现方式：</p>
<ul>
<li>cglib</li>
<li>jdk<blockquote>
<p>动态代理<br>基于 JDK 的动态代理。</p>
</blockquote>
</li>
</ul>
<ol>
<li>定义一个计算器接口：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyCalculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义计算机接口的实现：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">MyCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义代理类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getInstance</span><span class="params">(<span class="keyword">final</span> MyCalculatorImpl myCalculator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(CalculatorProxy.class.getClassLoader(), myCalculator.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 代理的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args 方法的参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method.getName()+<span class="string">&quot;方法开始执行啦...&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(myCalculator, args);</span><br><span class="line">                System.out.println(method.getName()+<span class="string">&quot;方法执行结束啦...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Proxy.newProxyInstance 方法接收三个参数，第一个是一个 classloader，第二个是代理对象实现的接口，第三个是代理对象方法的处理器，所有要额外添加的行为都在 invoke 方法中实现。</li>
</ol>
<h1 id="五种通知"><a href="#五种通知" class="headerlink" title="五种通知"></a>五种通知</h1><p>Spring 中的 Aop 的通知类型有 5 种：</p>
<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>异常通知</li>
<li>返回通知</li>
<li>环绕通知<br>具体实现，这里的案例和 5.2 中的一样，依然是给计算器的方法增强功能。</li>
</ul>
<p>首先，在项目中，引入 Spring 依赖（这次需要引入 Aop 相关的依赖）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来，定义切点，这里介绍两种切点的定义方式：</p>
<ul>
<li>使用自定义注解</li>
<li>使用规则</li>
</ul>
<p>其中，使用自定义注解标记切点，是侵入式的，所以这种方式在实际开发中不推荐，仅作为了解，另一种使用规则来定义切点的方式，无侵入，一般推荐使用这种方式。</p>
<p>自定义注解</p>
<p>首先自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span><span class="meta">@interface</span> Action &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在需要拦截的方法上，添加该注解，在 add 方法上添加了 @Action 注解，表示该方法将会被 Aop 拦截，而其他未添加该注解的方法则不受影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">publicclass MyCalculatorImpl &#123;</span><br><span class="line">    <span class="meta">@Action</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(a + <span class="string">&quot;-&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a - b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，定义增强（通知、Advice）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表示这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 包含了目标方法的关键信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span> 注解表示这是一个前置通知，即在目标方法执行之前执行，注解中，需要填入切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;@annotation(Action)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法开始执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 包含了目标方法的所有关键信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@After</span> 表示这是一个后置通知，即在目标方法执行之后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;@annotation(Action)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法执行结束了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * @<span class="doctag">@AfterReturning</span> 表示这是一个返回通知，即有目标方法有返回值的时候才会触发，该注解中的 returning 属性表示目标方法返回值的变量名，这个需要和参数一一对应吗，注意：目标方法的返回值类型要和这里方法返回值参数的类型一致，否则拦截不到，如果想拦截所有（包括返回值为 void），则方法返回值参数可以为 Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;@annotation(Action)&quot;,returning = &quot;r&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returing</span><span class="params">(JoinPoint joinPoint,Integer r)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法返回：&quot;</span>+r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 目标方法所抛出的异常，注意，这个参数必须是目标方法所抛出的异常或者所抛出的异常的父类，只有这样，才会捕获。如果想拦截所有，参数类型声明为 Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;@annotation(Action)&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Exception e)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法抛异常了：&quot;</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 环绕通知是集大成者，可以用环绕通知实现上面的四个通知，这个方法的核心有点类似于在这里通过反射执行方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注意这里的返回值类型最好是 Object ，和拦截到的方法相匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(Action)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这个相当于 method.invoke 方法，我们可以在这个方法的前后分别添加日志，就相当于是前置/后置通知</span></span><br><span class="line">            proceed = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知定义完成后，接下来在配置类中，开启包扫描和自动代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span><span class="comment">//开启自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在 Main 方法中，开启调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line">        <span class="type">MyCalculatorImpl</span> <span class="variable">myCalculator</span> <span class="operator">=</span> ctx.getBean(MyCalculatorImpl.class);</span><br><span class="line">        myCalculator.add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        myCalculator.min(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来回顾 LogAspect 切面，我们发现，切点的定义不够灵活，之前的切点是直接写在注解里边的，这样，如果要修改切点，每个方法上都要修改，因此，我们可以将切点统一定义，然后统一调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表示这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以统一定义切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(Action)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 包含了目标方法的关键信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span> 注解表示这是一个前置通知，即在目标方法执行之前执行，注解中，需要填入切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法开始执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 包含了目标方法的所有关键信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@After</span> 表示这是一个后置通知，即在目标方法执行之后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法执行结束了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * @<span class="doctag">@AfterReturning</span> 表示这是一个返回通知，即有目标方法有返回值的时候才会触发，该注解中的 returning 属性表示目标方法返回值的变量名，这个需要和参数一一对应吗，注意：目标方法的返回值类型要和这里方法返回值参数的类型一致，否则拦截不到，如果想拦截所有（包括返回值为 void），则方法返回值参数可以为 Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointcut()&quot;,returning = &quot;r&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returing</span><span class="params">(JoinPoint joinPoint,Integer r)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法返回：&quot;</span>+r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 目标方法所抛出的异常，注意，这个参数必须是目标方法所抛出的异常或者所抛出的异常的父类，只有这样，才会捕获。如果想拦截所有，参数类型声明为 Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointcut()&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Exception e)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法抛异常了：&quot;</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 环绕通知是集大成者，可以用环绕通知实现上面的四个通知，这个方法的核心有点类似于在这里通过反射执行方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注意这里的返回值类型最好是 Object ，和拦截到的方法相匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这个相当于 method.invoke 方法，我们可以在这个方法的前后分别添加日志，就相当于是前置/后置通知</span></span><br><span class="line">            proceed = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，大家也注意到，使用注解是侵入式的，我们还可以继续优化，改为非侵入式的。重新定义切点，新切点的定义就不在需要 @Action 注解了，要拦截的目标方法上也不用添加 @Action 注解。下面这种方式是更为通用的拦截方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表示这是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以统一定义切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(Action)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以统一定义切点</span></span><br><span class="line"><span class="comment">     * 第一个 * 表示要拦截的目标方法返回值任意（也可以明确指定返回值类型</span></span><br><span class="line"><span class="comment">     * 第二个 * 表示包中的任意类（也可以明确指定类</span></span><br><span class="line"><span class="comment">     * 第三个 * 表示类中的任意方法</span></span><br><span class="line"><span class="comment">     * 最后面的两个点表示方法参数任意，个数任意，类型任意</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* org.javaboy.aop.commons.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 包含了目标方法的关键信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span> 注解表示这是一个前置通知，即在目标方法执行之前执行，注解中，需要填入切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法开始执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 包含了目标方法的所有关键信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@After</span> 表示这是一个后置通知，即在目标方法执行之后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法执行结束了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * @<span class="doctag">@AfterReturning</span> 表示这是一个返回通知，即有目标方法有返回值的时候才会触发，该注解中的 returning 属性表示目标方法返回值的变量名，这个需要和参数一一对应吗，注意：目标方法的返回值类型要和这里方法返回值参数的类型一致，否则拦截不到，如果想拦截所有（包括返回值为 void），则方法返回值参数可以为 Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointcut()&quot;,returning = &quot;r&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returing</span><span class="params">(JoinPoint joinPoint,Integer r)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法返回：&quot;</span>+r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 目标方法所抛出的异常，注意，这个参数必须是目标方法所抛出的异常或者所抛出的异常的父类，只有这样，才会捕获。如果想拦截所有，参数类型声明为 Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointcut()&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Exception e)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法抛异常了：&quot;</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 环绕通知是集大成者，可以用环绕通知实现上面的四个通知，这个方法的核心有点类似于在这里通过反射执行方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注意这里的返回值类型最好是 Object ，和拦截到的方法相匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这个相当于 method.invoke 方法，我们可以在这个方法的前后分别添加日志，就相当于是前置/后置通知</span></span><br><span class="line">            proceed = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="XML-配置-Aop"><a href="#XML-配置-Aop" class="headerlink" title="XML 配置 Aop"></a>XML 配置 Aop</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来，定义通知&#x2F;增强，但是单纯定义自己的行为即可，不再需要注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法开始执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法执行结束了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returing</span><span class="params">(JoinPoint joinPoint,Integer r)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法返回：&quot;</span>+r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Exception e)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;方法抛异常了：&quot;</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这个相当于 method.invoke 方法，我们可以在这个方法的前后分别添加日志，就相当于是前置/后置通知</span></span><br><span class="line">            proceed = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在 spring 中配置 Aop：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.javaboy.aop.LogAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;logAspect&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* org.javaboy.aop.commons.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;returing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;r&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;e&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，在 Main 方法中加载配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">MyCalculatorImpl</span> <span class="variable">myCalculator</span> <span class="operator">=</span> ctx.getBean(MyCalculatorImpl.class);</span><br><span class="line">        myCalculator.add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        myCalculator.min(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>9.Spring 事务</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/9.Spring%20%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Spring 中的事务主要是利用 Aop 思想，简化事务的配置，可以通过 Java 配置也可以通过 XML 配置。</p>
<blockquote>
<p>1.XML 配置<br>XML  中配置事务一共分为三个步骤：</p>
</blockquote>
<ol>
<li>配置 TransactionManager</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>配置事务要处理的方法<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意，一旦配置了方法名称规则之后，service 中的方法一定要按照这里的名称规则来，否则事务配置不会生效</p>
<ol start="3">
<li>配置 Aop<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* org.demo.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.Java 配置<br>如果要开启 Java 注解配置，在 XML 配置中添加如下配置：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
这行配置，可以代替下面两个配置：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* org.demo.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>然后，在需要添加事务的方法上，添加 @Transactional 注解，表示该方法开启事务，当然，这个注解也可以放在类上，表示这个类中的所有方法都开启事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.addMoney(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        userDao.minMoney(<span class="string">&quot;lisi&quot;</span>, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="事务的传播性"><a href="#事务的传播性" class="headerlink" title="事务的传播性"></a>事务的传播性</h1><table>
<thead>
<tr>
<th>传播性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>创建一个新的事务，如果当前存在事务，则把当前事务挂起</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>以非事务方式运行，如果当前存在事务，则把当前事务挂起</td>
</tr>
<tr>
<td>NEVER</td>
<td>以非事务方式运行，如果当前存在事务，则抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED</td>
</tr>
</tbody></table>
<blockquote>
<p>更新时间2023年9月19日21点35分</p>
</blockquote>
<p>问题：在service业务类中，一个非事务方法调用一个用@Transactional注解的事务方法，事务方法会失效，为什么？</p>
<p>@Transactional注解的方法必须是<strong>代理对象</strong>的方法。而service业务类中调用的注解方法是当前service对象，故事务方法会失效。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>8.Spring JdbcTemplate</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/spring/8.Spring%20JdbcTemplate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// 省去setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java配置"><a href="#java配置" class="headerlink" title="java配置"></a>java配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///testjpa?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JdbcConfig.class);</span><br><span class="line">        jdbcTemplate = ctx.getBean(JdbcTemplate.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;insert into t_user (name,address) values (?,?);&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update t_user set name=? where id=?&quot;</span>, <span class="string">&quot;javaboy123&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;delete from t_user where id=?&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select * from t_user where id=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), <span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在查询时，如果使用了 BeanPropertyRowMapper，要求查出来的字段必须和 Bean 的属性名一一对应。如果不一样，则不要使用 BeanPropertyRowMapper，此时需要自定义 RowMapper 或者给查询的字段取别名。</p>
<ol>
<li>给查询出来的列取别名<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select id,name as name,address from t_user where id=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), <span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>自定义 RowMapper<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select * from t_user where id=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;User&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">mapRow</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            u.setId(id);</span><br><span class="line">            u.setName(username);</span><br><span class="line">            u.setAddress(address);</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///testjpa?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Springboot2整合Session共享</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/10.Springboot2%E6%95%B4%E5%90%88Session%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>在传统的单服务架构中，一般来说，只有一个服务器，那么不存在 Session 共享问题，但是在分布式&#x2F;集群项目中，Session 共享则是一个必须面对的问题，先看一个简单的架构图：<br><img src="/blog/images/img/session001.png" alt="session001"></p>
<p>在这样的架构中，会出现一些单服务中不存在的问题，例如客户端发起一个请求，这个请求到达 Nginx 上之后，被 Nginx 转发到 Tomcat A 上，然后在 Tomcat A 上往 session 中保存了一份数据，下次又来一个请求，这个请求被转发到 Tomcat B  上，此时再去 Session 中获取数据，发现没有之前的数据。对于这一类问题的解决，思路很简单，就是将各个服务之间需要共享的数据，保存到一个公共的地方（主流方案就是 Redis）：<br><img src="/blog/images/img/session002.png" alt="session002"></p>
<p>当所有 Tomcat 需要往 Session 中写数据时，都往 Redis 中写，当所有 Tomcat 需要读数据时，都从 Redis 中读。这样，不同的服务就可以使用相同的 Session 数据了。 这样的方案，可以由开发者手动实现，即手动往 Redis 中存储数据，手动从 Redis 中读取数据，相当于使用一些 Redis 客户端工具来实现这样的功能，毫无疑问，手动实现工作量还是蛮大的。 </p>
<p>一个简化的方案就是使用 Spring Session 来实现这一功能，Spring Session 就是使用 Spring 中的代理过滤器，将所有的 Session 操作拦截下来，自动的将数据 同步到 Redis 中，或者自动的从 Redis 中读取数据。 对于开发者来说，所有关于 Session 同步的操作都是透明的，开发者使用 Spring Session，一旦配置完成后，具体的用法就像使用一个普通的 Session 一样。</p>
<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p>配置完成后 ，就可以使用 Spring Session 了，其实就是使用普通的 HttpSession ，其他的 Session 同步到 Redis 等操作，框架已经自动帮你完成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    Integer port;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">set</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;javaboy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> session.getAttribute(<span class="string">&quot;user&quot;</span>) + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="打包，启动"><a href="#打包，启动" class="headerlink" title="打包，启动"></a>打包，启动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后先访问 localhost:8080&#x2F;set 向 8080 这个服务的 Session 中保存一个变量，访问完成后，数据就已经自动同步到 Redis  中 了 .然后，再调用 localhost:8081&#x2F;get 接口，就可以获取到 8080 服务的 session 中的数据</p>
<p>此时关于 session 共享的配置就已经全部完成了，session 共享的效果我们已经看到了，但是每次访问都是我自己手动切换服务实例，因此，接下来我们来引入 Nginx ，实现服务实例自动切换。</p>
<h1 id="引入nginx"><a href="#引入nginx" class="headerlink" title="引入nginx"></a>引入nginx</h1><p>很简单，进入  Nginx 的安装目录的 conf 目录下（默认是在 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf），编辑 nginx.conf 文件:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">upstream zhangjie.<span class="keyword">com</span>&#123;</span><br><span class="line">        server <span class="number">192.168</span>.<span class="number">13.106</span>:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">        server <span class="number">192.168</span>.<span class="number">13.106</span>:<span class="number">8081</span> weight=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.<span class="built_in">log</span>  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">           proxy_pass http://zhangjie.<span class="keyword">com</span>;</span><br><span class="line">           proxy_redirect default;</span><br><span class="line">           #root   html;</span><br><span class="line">           #index  <span class="built_in">index</span>.html <span class="built_in">index</span>.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在这段配置中： </p>
<ul>
<li>upstream 表示配置上游服务器 </li>
<li>zhangjie.com 表示服务器集群的名字，这个可以随意取名字 </li>
<li>upstream 里边配置的是一个个的单独服务 </li>
<li>weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上 </li>
<li>location 中的 proxy_pass 表示请求转发的地址，&#x2F; 表示拦截到所有的请求，转发转发到刚刚配置好的服务集群中 </li>
<li>proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）。</li>
</ul>
<p>重启nginx，访问<a href="http://zhangjie.com/set">http://zhangjie.com/set</a> 和<a href="http://zhangjie.com/get">http://zhangjie.com/get</a></p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Spring Boot2 @ControllerAdvice 的三种使用场景</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/1.Spring%20Boot2@ControllerAdvice%20%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><p>使用 @ControllerAdvice 实现全局异常处理，只需要定义类，添加该注解即可定义方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">customerException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;系统错误:&quot;</span>+e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。</p>
<p>@ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来。</p>
<h1 id="全局数据绑定"><a href="#全局数据绑定" class="headerlink" title="全局数据绑定"></a>全局数据绑定</h1><p>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个  Controller 的接口中，就都能够访问导致这些数据。</p>
<p>使用步骤，首先定义全局数据，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute(name = &quot;md&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">mydata</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">99</span>);</span><br><span class="line">    map.put(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 @ModelAttribute 注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。</p>
<p>定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = model.asMap();</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="全局数据预处理"><a href="#全局数据预处理" class="headerlink" title="全局数据预处理"></a>全局数据预处理</h1><p>考虑我有两个实体类，Book 和 Author，分别定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicclass Book &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Long price;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br><span class="line">publicclass Author &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果我定义一个数据添加接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book, Author author)</span> &#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">    System.out.println(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过 @ControllerAdvice 的全局数据预处理可以解决这个问题</p>
<p>解决步骤如下:</p>
<p>1.给接口中的变量取别名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(<span class="meta">@ModelAttribute(&quot;b&quot;)</span> Book book, <span class="meta">@ModelAttribute(&quot;a&quot;)</span> Author author)</span> &#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">    System.out.println(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.进行请求数据预处理<br>在 @ControllerAdvice 标记的类中添加如下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InitBinder(&quot;b&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(<span class="string">&quot;b.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@InitBinder(&quot;a&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(<span class="string">&quot;a.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@InitBinder(“b”) 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀.</p>
<p>3.发送请求</p>
<p>请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.</p>
<p><img src="/blog/images/img/640.png" alt="640"></p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Spring Boot2 自定义starter</title>
    <url>/blog/2023/06/02/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/11.Spring%20Boot2%20%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="自定义springboot-starter"><a href="#自定义springboot-starter" class="headerlink" title="自定义springboot starter"></a>自定义springboot starter</h1><h2 id="定义步骤"><a href="#定义步骤" class="headerlink" title="定义步骤"></a>定义步骤</h2><p>1.创建maven工程</p>
<p>2.定义Starter需要的配置类(Properties)</p>
<p>3.编写Starter项目的业务功能</p>
<p>4.编写自动配置类</p>
<p>5.编写spring.factories文件加载自动配置类</p>
<p>6.打包安装</p>
<p>7.其它项目引用</p>
<h1 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h1><h2 id="短信发送功能"><a href="#短信发送功能" class="headerlink" title="短信发送功能"></a>短信发送功能</h2><p>1.创建一个maven工程（工程名称以xx-spring-boot-starter）</p>
<p>2.引入springboot 自动配置依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">3.配置属性类，用@ConfigurationProperties控制</span><br><span class="line">```java</span><br><span class="line">@ConfigurationProperties(&quot;common.sms&quot;)</span><br><span class="line">public class SmsProperties implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    // 访问id</span><br><span class="line">    private String accessKeyId;</span><br><span class="line">    // 访问密码</span><br><span class="line">    private String accessKeySecret;</span><br><span class="line"></span><br><span class="line">    public String getAccessKeyId() &#123;</span><br><span class="line">        return accessKeyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccessKeyId(String accessKeyId) &#123;</span><br><span class="line">        this.accessKeyId = accessKeyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAccessKeySecret() &#123;</span><br><span class="line">        return accessKeySecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccessKeySecret(String accessKeySecret) &#123;</span><br><span class="line">        this.accessKeySecret = accessKeySecret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.编写Starter项目的业务功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISmsService</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送短信</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> phone        要发送的手机号</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> signName     短信签名-在短信控制台中找</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> templateCode 短信模板-在短信控制台中找</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data         要发送的内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String phone, String signName, String templateCode, String data)</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ISmsService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;<span class="comment">//访问ID、即帐号</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;<span class="comment">//访问凭证，即密码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsServiceImpl</span><span class="params">(String accessKeyId, String accessKeySecret)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accessKeyId = accessKeyId;</span><br><span class="line">        <span class="built_in">this</span>.accessKeySecret = accessKeySecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String phone, String signName, String templateCode, String data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接入短信系统，accessKeyId=&quot;</span> + accessKeyId + <span class="string">&quot;,accessKeySecret=&quot;</span> + accessKeySecret);</span><br><span class="line">        System.out.println(<span class="string">&quot;短信发送，phone=&quot;</span> + phone + <span class="string">&quot;,signName=&quot;</span> + signName + <span class="string">&quot;,templateCode=&quot;</span> + templateCode + <span class="string">&quot;,data=&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写自动配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;SmsProperties.class&#125;)</span> <span class="comment">// 使@ConfigurationProperties生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsAutoConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SmsProperties smsProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ISmsService <span class="title function_">smsServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>(smsProperties.getAccessKeyId(),smsProperties.getAccessKeySecret());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.编写spring.factories文件加载自动配置类</p>
<p>6.1.在resources下新建META-INF文件夹，然后创建spring.factories文件</p>
<p>6.2.在该文件中加入如下配置，该配置指定上步骤中定义的配置类为自动装配的配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">    com.zhangjie.sms.config.SmsAutoConfig</span><br></pre></td></tr></table></figure>

<p>注1：其中AutoConfig是starter配置文件的类限定名，多个之间逗号分割，还可以\进行转义即相当于去掉后面换行和空格符号，如下所示</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.baomidou.mybatisplus.autoconfigure.MybatisPlusLanguageDriverAutoConfiguration,\</span><br><span class="line">com.baomidou.mybatisplus.autoconfigure.MybatisPlusAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>7.打包安装</p>
<p>8.引用</p>
<h1 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h1><h2 id="打印web请求日志"><a href="#打印web请求日志" class="headerlink" title="打印web请求日志"></a>打印web请求日志</h2><p>1.创建一个maven工程（工程名称以xx-spring-boot-starter）</p>
<p>2.引入springboot 自动配置依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">3.配置属性类，用@ConfigurationProperties控制</span><br><span class="line">```java</span><br><span class="line">@ConfigurationProperties(&quot;common.web-log&quot;)</span><br><span class="line">public class WebLogProperties implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private Boolean enabled;</span><br><span class="line"></span><br><span class="line">    public Boolean getEnabled() &#123;</span><br><span class="line">        return enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEnabled(Boolean enabled) &#123;</span><br><span class="line">        this.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.编写Starter项目的业务功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* *..*Controller.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 接收到请求，记录请求内容</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录下请求内容</span></span><br><span class="line">        log.info(<span class="string">&quot;开始服务:&#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">        log.info(<span class="string">&quot;客户端IP :&#123;&#125;&quot;</span> , request.getRemoteAddr());</span><br><span class="line">        log.info(<span class="string">&quot;参数值 :&#123;&#125;&quot;</span>, Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 处理完请求，返回内容</span></span><br><span class="line">        log.info(<span class="string">&quot;返回值 : &#123;&#125;&quot;</span> , ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写自动配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表示这个类为配置类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebLogProperties.class&#125;)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * matchIfMissing属性：默认情况下matchIfMissing为false，也* 就是说如果未进行属性配置，则自动配置不生效。</span></span><br><span class="line"><span class="comment"> * 如果matchIfMissing为true，则表示如果没有对应的属性配置，* 则自动配置默认生效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;common.web-log&quot;,value = &quot;enabled&quot;,matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAutoConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在<span class="doctag">@Bean</span>定义上，它的作用就是在容器加载它作用的bean时，* 检查容器中是否存在目标类型（ConditionalOnMissingBean</span></span><br><span class="line"><span class="comment">     * 注解的value值）的bean了，如果存在这跳过原始bean的</span></span><br><span class="line"><span class="comment">     * BeanDefinition加载动作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> WebLogAspect <span class="title function_">webLogAspect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebLogAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.编写spring.factories文件加载自动配置类</p>
<p>6.1.在resources下新建META-INF文件夹，然后创建spring.factories文件</p>
<p>6.2.在该文件中加入如下配置，该配置指定上步骤中定义的配置类为自动装配的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.zhangjie.WebLogAutoConfig</span><br></pre></td></tr></table></figure>
<p>7.打包安装</p>
<p>8.引用</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Spring Boot2 CORS 解决跨域问题</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/2.Spring%20Boot2CORS%20%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>很多人对跨域有一种误解，以为这是前端的事，和后端没关系，其实不是这样的，说到跨域，就不得不说说浏览器的同源策略。</p>
<p>同源策略是由 Netscape 提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是 JSONP，JSONP 虽然能解决跨域但是有一个很大的局限性，那就是只支持 GET 请求，不支持其他类型的请求，而今天我们说的 CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）是一个 W3C 标准，它是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是 JSONP 模式的现代版。</p>
<p>在 Spring 框架中，对于 CORS 也提供了相应的解决方案，今天我们就来看看 SpringBoot 中如何实现 CORS。</p>
<ol>
<li>@CrossOrigin</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line">publicclass HelloController &#123;</span><br><span class="line">    <span class="meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;post hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>WebMvcConfigurer</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">publicclass WebMvcConfig <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">        .allowedOrigins(<span class="string">&quot;http://localhost:8081&quot;</span>)</span><br><span class="line">        .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">        .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>了解了整个 CORS 的工作过程之后，我们通过 Ajax 发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是 CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法，举个例子：</p>
<blockquote>
<p>假如一家银行用以运行转账操作的URL地址如下：<a href="http://icbc.com/aa?bb=cc%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B8%8A%E6%94%BE%E7%BD%AE%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%9A%60%60%60">http://icbc.com/aa?bb=cc，那么，一个恶意攻击者可以在另一个网站上放置如下代码：```</a><img src="http://icbc.com/aa?bb=cc">&#96;&#96;&#96;，如果用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会遭受损失。</p>
</blockquote>
<p>基于此，浏览器在实际操作中，会对请求进行分类，分为简单请求，预先请求，带凭证的请求等，预先请求会首先发送一个 options 探测请求，和浏览器进行协商是否接受请求。默认情况下跨域请求是不需要凭证的，但是服务端可以配置要求客户端提供凭证，这样就可以有效避免 csrf 攻击。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Spring Boot2整合swagger2</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/4.Spring%20Boot2%E6%95%B4%E5%90%88swagger2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote>
<p>引入pom依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>增加一个docket配置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .pathMapping(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.example.springbootdemo.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build().apiInfo(<span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                        .title(<span class="string">&quot;SpringBoot整合Swagger&quot;</span>)</span><br><span class="line">                        .description(<span class="string">&quot;SpringBoot整合Swagger，详细信息......&quot;</span>)</span><br><span class="line">                        .version(<span class="string">&quot;9.0&quot;</span>)</span><br><span class="line">                        .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;ceshi&quot;</span>,<span class="string">&quot;blog.csdn.net&quot;</span>,<span class="string">&quot;aaa@gmail.com&quot;</span>))</span><br><span class="line">                        .license(<span class="string">&quot;The Apache License&quot;</span>)</span><br><span class="line">                        .licenseUrl(<span class="string">&quot;http://www.javaboy.org&quot;</span>)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;用户管理相关接口&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;添加用户的接口&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;username&quot;, value = &quot;用户名&quot;, defaultValue = &quot;李四&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;address&quot;, value = &quot;用户地址&quot;, defaultValue = &quot;深圳&quot;, required = true)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RespDto <span class="title function_">addUser</span><span class="params">(String username, <span class="meta">@RequestParam(required = true)</span> String address)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RespDto.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id查询用户的接口&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, defaultValue = &quot;99&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id更新用户的接口&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUserById</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>@Api 注解可以用来标记当前 Controller 的功能。</li>
<li>@ApiOperation 注解用来标记一个方法的作用。</li>
<li>@ApiImplicitParam 注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。</li>
<li>如果有多个参数，则需要使用多个 @ApiImplicitParam 注解来描述，多个 @ApiImplicitParam 注解需要放在一个 @ApiImplicitParams 注解中。</li>
<li>需要注意的是，@ApiImplicitParam 注解中虽然可以指定参数是必填的，但是却不能代替 @RequestParam(required &#x3D; true) ，前者的必填只是在 Swagger2 框架内必填，抛弃了 Swagger2 ，这个限制就没用了，所以假如开发者需要指定一个参数必填， @RequestParam(required &#x3D; true) 注解还是不能省略。</li>
<li>如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line">publicclass User &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户地址&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Spring Boot2 JPA</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/3.Spring%20Boot2JPA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java Persistence API：用于对象持久化的 API </p>
<p>首先需要向大伙介绍一下 Jpa，Jpa（Java Persistence API）Java 持久化 API，它是一套 ORM 规范，而不是具体的实现，Jpa 的江湖地位类似于 JDBC，只提供规范，所有的数据库厂商提供实现（即具体的数据库驱动）</p>
<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql:///testjpa?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="comment"># 每次启动项目时，数据库初始化策略</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">hibernate:</span></span><br><span class="line">      <span class="comment"># 指定默认的存储引擎为InnoD</span></span><br><span class="line">        <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.MySQL57Dialect</span></span><br></pre></td></tr></table></figure>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>ORM(Object Relational Mapping) 框架表示对象关系映射，使用 ORM 框架我们不必再去创建表，框架会自动根据当前项目中的实体类创建相应的数据表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;biz_student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Column(length = 50)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(length = 12)</span></span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, number=&#x27;&quot;</span> + number + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先 @Entity 注解表示这是一个实体类，那么在项目启动时会自动针对该类生成一张表，默认的表名为类名，@Entity 注解的 name 属性表示自定义生成的表名。@Id 注解表示这个字段是一个 id，@GeneratedValue 注解表示主键的自增长策略，对于类中的其他属性，默认都会根据属性名在表中生成相应的字段，字段名和属性名相同，如果开发者想要对字段进行定制，可以使用 @Column 注解，去配置字段的名称，长度，是否为空等等。</p>
<p>做完这一切之后，启动 Spring Boot 项目，就会发现数据库中多了一个名为 biz_student 的表了。 针对该表的操作，则需要我们提供一个 Repository，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Student, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Student <span class="title function_">findStudentByNumber</span><span class="params">(String number)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，自定义 StudentDao 接口继承自 JpaRepository，JpaRepository 提供了一些基本的数据操作方法，例如保存，更新，删除，分页查询等，开发者也可以在接口中自己声明相关的方法，只需要方法名称符合规范即可，在 Spring Data 中，只要按照既定的规范命名方法，Spring Data Jpa 就知道你想干嘛，这样就不用写 SQL 了，那么规范是什么呢？参考下图：<br><img src="/blog/images/img/jpa001.jpeg" alt="jpa001"></p>
<p>当然，这种方法命名主要是针对查询，但是一些特殊需求，可能并不能通过这种方式解决，例如想要查询 id 最大的用户，这时就需要开发者自定义查询 SQL 了。 如上代码所示，自定义查询 SQL，使用 @Query 注解，在注解中写自己的 SQL，默认使用的查询语言不是 SQL，而是 JPQL，这是一种数据库平台无关的面向对象的查询语言，有点定位类似于 Hibernate 中的 HQL，在 @Query 注解中设置 nativeQuery 属性为 true 则表示使用原生查询，即大伙所熟悉的 SQL。上面代码中的只是一个很简单的例子，还有其他一些点，例如如果这个方法中的 SQL 涉及到数据操作，则需要使用 @Modifying 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootJpaDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> getLogger(SpringbootJpaDemoApplicationTests.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        student.setNumber(DateUtil.yearOf(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot;0002&quot;</span>);</span><br><span class="line">        studentDao.save(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectStudentByNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentDao.findStudentByNumber(<span class="string">&quot;20230001&quot;</span>);</span><br><span class="line">        logger.info(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        Optional&lt;Student&gt; optional = studentDao.findById(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!optional.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> optional.get();</span><br><span class="line">            logger.info(student.toString());</span><br><span class="line">            student.setName(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">            studentDao.saveAndFlush(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Student&gt; all = studentDao.findAll();</span><br><span class="line">        logger.info(all.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectByPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pageable</span> <span class="variable">page</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>,<span class="number">10</span>, Sort.by(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        Page&lt;Student&gt; all = studentDao.findAll(page);</span><br><span class="line">        System.out.println(all.getTotalPages());</span><br><span class="line">        System.out.println(all.getTotalElements());</span><br><span class="line">        System.out.println(all.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">()</span> &#123;</span><br><span class="line">        studentDao.deleteById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>5.Spring Boot2模板thymeleaf制作邮件模板</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/5.Spring%20Boot2%E6%A8%A1%E6%9D%BFthymeleaf%E5%88%B6%E4%BD%9C%E9%82%AE%E4%BB%B6%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Thymeleaf 是新一代 Java 模板引擎，它类似于 Velocity、FreeMarker 等传统 Java 模板引擎，但是与传统 Java 模板引擎不同的是，Thymeleaf 支持 HTML 原型。</p>
<p>它既可以让前端工程师在浏览器中直接打开查看样式，也可以让后端工程师结合真实数据查看显示效果，同时，SpringBoot 提供了 Thymeleaf 自动化配置解决方案，因此在 SpringBoot 中使用 Thymeleaf 非常方便。</p>
<p>事实上， Thymeleaf 除了展示基本的 HTML ，进行页面渲染之外，也可以作为一个 HTML 片段进行渲染，例如我们在做邮件发送时，可以使用 Thymeleaf 作为<strong>邮件发送模板</strong>。</p>
<p>另外，由于 Thymeleaf 模板后缀为 .html，可以直接被浏览器打开，因此，预览时非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 发送内容</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">    context.setVariable(<span class="string">&quot;typeName&quot;</span>,<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">    <span class="type">ProductDto</span> <span class="variable">productDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductDto</span>();</span><br><span class="line">    productDto.setManager(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    productDto.setProductName(<span class="string">&quot;mojar基金1号&quot;</span>);</span><br><span class="line">    productDto.setProductCode(<span class="string">&quot;HK0023231&quot;</span>);</span><br><span class="line">    context.setVariable(<span class="string">&quot;product&quot;</span>,productDto);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mailTemplate</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;mailTemplate&quot;</span>, context);</span><br><span class="line">    EmailUtil.send(<span class="string">&quot;XXX@qq.com&quot;</span>,<span class="string">&quot;测试邮件&quot;</span>,mailTemplate,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<pre><code class="html">&lt;p&gt;您好！&lt;/p&gt;
&lt;p style=&quot;text-indent: 2em;&quot;&gt;现有如下产品投资的债券临近[[$&#123;typeName==null?&quot;&quot;:typeName&#125;]]，请注意关注！&lt;/p&gt;
&lt;p style=&quot;text-indent: 2em;&quot;&gt;管理人：[[$&#123;product!=null?product.manager:&quot;&quot;&#125;]]&lt;/p&gt;
&lt;p style=&quot;text-indent: 2em;&quot;&gt;产品名称：[[$&#123;product!=null?product.productName:&quot;&quot;&#125;]]&lt;/p&gt;
&lt;p style=&quot;text-indent: 2em;&quot;&gt;产品编码：&lt;i style=&quot;color: red&quot;&gt;[[$&#123;product!=null?product.productCode:&quot;&quot;&#125;]]&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p style=&quot;text-indent: 2em;&quot;&gt;谢谢！&lt;/p&gt;
</code></pre>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>6.Spring Boot2自动化配置原理</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/6.Spring%20Boot2%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="springboot自动化配置原理"><a href="#springboot自动化配置原理" class="headerlink" title="springboot自动化配置原理"></a>springboot自动化配置原理</h1><p>starter底层依赖的是一个叫条件注解的注解@Conditional。这个注解的作用就是根据不同的条件在spring容器中创建bean。</p>
<p>这个注解的属性是一个接口（Condition），接口中只有一个方法，实现这个方法，就可以控制是否创建当前bean。常用的@Profile<br>注解底层也是用的条件注解。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>7.Spring Boot2通过cache接口整合redis</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/7.Spring%20Boot2%E9%80%9A%E8%BF%87cache%E6%8E%A5%E5%8F%A3%E6%95%B4%E5%90%88redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote>
<p>经过 Spring Boot 的整合封装与自动化配置，在 Spring Boot 中整合Redis 已经变得非常容易了，开发者只需要引入 Spring Data Redis 依赖，然后简单配下 redis 的基本信息，系统就会提供一个 RedisTemplate 供开发者使用。Spring3.1 中开始引入了令人激动的 Cache，在 Spring Boot 中，可以非常方便的使用 Redis 来作为 Cache 的实现，进而实现数据的缓存。</p>
</blockquote>
<ol>
<li>增加依赖<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>增加配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">cache-names:</span> <span class="string">c1</span></span><br></pre></td></tr></table></figure></li>
<li>注解开启缓存<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootdemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用缓存<blockquote>
<p>@CacheConfig</p>
</blockquote>
</li>
</ol>
<p>这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;c1&quot;)</span></span><br><span class="line">publicclass UserService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Cacheable</p>
</blockquote>
<p>这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的 key 就是方法的参数，缓存的 value 就是方法的返回值。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Integer id,String username)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;getUserById&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> getUserFromDBById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@CachePut</p>
</blockquote>
<p>这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的 key 上，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">updateUserById</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@CacheEvict</p>
</blockquote>
<p>这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（condition 属性）或者或者配置清除所有缓存（allEntries 属性），示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUserById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//在这里执行删除操作， 删除是去数据库中删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>8.Spring Boot2邮件发送</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/8.Spring%20Boot2%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote>
<p>邮件基础<br>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。</p>
</blockquote>
<p>SMTP 是一个基于 TCP&#x2F;IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP&#x2F;IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。</p>
<p>生活中我们投递一封邮件要经过如下几个步骤：</p>
<ol>
<li>深圳的小王先将邮件投递到深圳的邮局</li>
<li>深圳的邮局将邮件运送到上海的邮局</li>
<li>上海的小张来邮局取邮件<br>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:&#97;&#x61;&#97;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#97;&#x61;&#97;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a> 发送邮件到 <a href="mailto:&#x31;&#x31;&#49;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#109;">&#x31;&#x31;&#49;&#x40;&#x31;&#54;&#51;&#46;&#99;&#111;&#109;</a> ：</li>
</ol>
<p><a href="mailto:&#x61;&#x61;&#x61;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;">&#x61;&#x61;&#x61;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;</a> 先将邮件投递到腾讯的邮件服务器<br>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器<br><a href="mailto:&#49;&#49;&#49;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#49;&#49;&#49;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a> 登录网易的邮件服务器查看邮件<br>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。</p>
<p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p>
<p>也就是说 <a href="mailto:&#97;&#97;&#x61;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#97;&#97;&#x61;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p>
<p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:&#49;&#49;&#49;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;">&#49;&#49;&#49;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p>
<p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。</p>
<blockquote>
<p>添加POM依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置信息</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxxx@qq.com</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mehyawyqqydqifdi</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>简单邮件发送</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">    message.setSubject(<span class="string">&quot;这是一封测试邮件&quot;</span>);</span><br><span class="line">    message.setFrom(<span class="string">&quot;208xxxx@qq.com&quot;</span>);</span><br><span class="line">    message.setTo(<span class="string">&quot;109xxxx@qq.com&quot;</span>);</span><br><span class="line">    message.setText(<span class="string">&quot;简单邮件&quot;</span>);</span><br><span class="line">    javaMailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>制作邮件模板邮件发送</p>
</blockquote>
<ol>
<li>引入thymeleaf<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>制作模板<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>您好！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-indent: 2em;&quot;</span>&gt;</span>现有如下产品投资的债券临近[[$&#123;typeName==null?&quot;&quot;:typeName&#125;]]，请注意关注！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-indent: 2em;&quot;</span>&gt;</span>管理人：[[$&#123;product!=null?product.manager:&quot;&quot;&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-indent: 2em;&quot;</span>&gt;</span>产品名称：[[$&#123;product!=null?product.productName:&quot;&quot;&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-indent: 2em;&quot;</span>&gt;</span>产品编码：<span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>[[$&#123;product!=null?product.productCode:&quot;&quot;&#125;]]<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;text-indent: 2em;&quot;</span>&gt;</span>谢谢！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sendHtmlMail</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> javaMailSender.createMimeMessage();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line">        helper.setSubject(<span class="string">&quot;这是一封测试邮件&quot;</span>);</span><br><span class="line">        helper.setFrom(<span class="string">&quot;20868xxx@qq.com&quot;</span>);</span><br><span class="line">        helper.setTo(<span class="string">&quot;1093xxx@qq.com&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送内容</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setVariable(<span class="string">&quot;typeName&quot;</span>,<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        <span class="type">ProductDto</span> <span class="variable">productDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductDto</span>();</span><br><span class="line">        productDto.setManager(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        productDto.setProductName(<span class="string">&quot;mojar基金1号&quot;</span>);</span><br><span class="line">        productDto.setProductCode(<span class="string">&quot;HK0023231&quot;</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;product&quot;</span>,productDto);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mailTemplate</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;mailTemplate&quot;</span>, context);</span><br><span class="line">        helper.setText(mailTemplate,<span class="literal">true</span>);</span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>9.Spring Boot2配置https</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springboot2/9.Spring%20Boot2%E9%85%8D%E7%BD%AEhttps/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="1-生成证书"><a href="#1-生成证书" class="headerlink" title="1.生成证书"></a>1.生成证书</h1><p>可以用 Java 自带的 JDK 管理工具 keytool 来生成一个免费的 https 证书。</p>
<pre><code>keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048  -keystore D:\mojar.p12 -validity 365
</code></pre>
<p>命令含义如下：</p>
<p>genkey 表示要创建一个新的密钥。</p>
<p>alias 表示 keystore 的别名。</p>
<p>keyalg 表示使用的加密算法是 RSA ，一种非对称加密算法。</p>
<p>keysize 表示密钥的长度。</p>
<p>keystore 表示生成的密钥存放位置。</p>
<p>validity 表示密钥的有效时间，单位为天。</p>
<h1 id="2-配置https"><a href="#2-配置https" class="headerlink" title="2.配置https"></a>2.配置https</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">      <span class="attr">ssl:</span></span><br><span class="line">          <span class="attr">key-store:</span> <span class="string">classpath:mojar.p12</span></span><br><span class="line">          <span class="attr">key-alias:</span> <span class="string">tomcathttps</span></span><br><span class="line">          <span class="attr">key-store-password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h1 id="3-请求转发"><a href="#3-请求转发" class="headerlink" title="3.请求转发"></a>3.请求转发</h1><p>考虑到 Spring Boot 不支持同时启动 HTTP 和 HTTPS ，为了解决这个问题，我们这里可以配置一个请求转发，当用户发起 HTTP 调用时，自动转发到 HTTPS 上。</p>
<p>具体配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">publicclass TomcatConfig &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">                <span class="type">SecurityConstraint</span> <span class="variable">constraint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityConstraint</span>();</span><br><span class="line">                constraint.setUserConstraint(<span class="string">&quot;CONFIDENTIAL&quot;</span>);</span><br><span class="line">                <span class="type">SecurityCollection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityCollection</span>();</span><br><span class="line">                collection.addPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Connector <span class="title function_">createTomcatConnector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">Connector</span>(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        connector.setScheme(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">        connector.setPort(<span class="number">8081</span>);</span><br><span class="line">        connector.setSecure(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 转发端口要和yml配置端口一致</span></span><br><span class="line">        connector.setRedirectPort(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们配置了 Http 的请求端口为 8081，所有来自 8081 的请求，将被自动重定向到 8080 这个 https 的端口上。</p>
<p>如此之后，我们再去访问 http 请求，就会自动重定向到 https。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringBoot2</category>
      </categories>
      <tags>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title>0-activiti7简介</title>
    <url>/blog/2024/01/11/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti7/0-activiti7%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="建模语言BPMN"><a href="#建模语言BPMN" class="headerlink" title="建模语言BPMN"></a>建模语言BPMN</h1><p>BPM软件在企业中应用非常广泛，凡是有业务流程的地方都可以使用BPM进行管理。比如企业人事办公管理、采购流程管理</p>
<p>BPMN是Business Process Model And Notation 业务流程模型和符号，就是用来描述业务流程的一种建模标准。使用BPMN可以快速定义业务流程。</p>
<p>整个BPMN是用一组符号来描述业务流程中发生的各种事件的。BPMN通过在这些符号事件之间连线来描述一个完整的业务流程。</p>
<p>对于一个完整的BPMN图形流程，其实最终是通过XML进行描述的</p>
<p>通常，会将BPMN流程最终保存为一个.bpmn的文件，然后可以使用文本编辑器打开进行查看。而图形与xml文件之间，会有专门的软件来进行转换。</p>
<p><img src="/blog/images/img/BPMN.png" alt="BPMN"></p>
<h1 id="表结构解读"><a href="#表结构解读" class="headerlink" title="表结构解读"></a>表结构解读</h1><p>activiti的表都以act_开头。第二个部分表示表的用途。用途也和服务的API对应</p>
<p>ACT_RE_ : ‘RE’表示repository（存储库）。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）</p>
<p>ACT_RU_: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快</p>
<p>ACT_ID_ : ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等</p>
<p>ACT_HI_: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等</p>
<p>ACT_GE_*: 通用数据， 用于不同场景下</p>
<p><img src="/blog/images/img/tables.png" alt="tables"></p>
<h1 id="activiti-工作流不支持分布式"><a href="#activiti-工作流不支持分布式" class="headerlink" title="activiti 工作流不支持分布式"></a>activiti 工作流不支持分布式</h1><p>原因是：在Activiti工作流的act_ge_property表中通常情况下有3条记录：</p>
<p>next.dbid<br>schema.history<br>schema.version</p>
<p>其中next.dbid对应的值为数据库中当前最近一次增长后的最大记录id，每次增长的步长为2500，protected int idBlockSize &#x3D; 2500; （在ProcessEngineConfiguration类中）</p>
<p>Activiti中所有的id（如：Task的id，Execution的id，ProcessInstance的id等）都是通过IdGenerator来生成的<br>IdGenerator的默认实现是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**2  * <span class="doctag">@author</span> Tom Baeyens3  */</span><span class="number">4</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbIdGenerator</span> <span class="keyword">implements</span> <span class="title class_">IdGenerator</span> &#123;<span class="number">5</span> <span class="number">6</span>   <span class="keyword">protected</span> <span class="type">int</span> idBlockSize;<span class="number">7</span>   <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">0</span>;<span class="number">8</span>   <span class="keyword">protected</span> <span class="type">long</span> <span class="variable">lastId</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="number">9</span>   </span><br><span class="line"><span class="number">10</span>   <span class="keyword">protected</span> CommandExecutor commandExecutor;</span><br><span class="line"><span class="number">11</span>   <span class="keyword">protected</span> CommandConfig commandConfig;</span><br><span class="line"><span class="number">12</span>   </span><br><span class="line"><span class="number">13</span>   <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getNextId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">if</span> (lastId&lt;nextId) &#123;</span><br><span class="line"><span class="number">15</span>       getNewBlock();</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span>     <span class="type">long</span> <span class="variable">_nextId</span> <span class="operator">=</span> nextId++;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> Long.toString(_nextId);</span><br><span class="line"><span class="number">19</span>   &#125;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>   <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getNewBlock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">22</span>     <span class="type">IdBlock</span> <span class="variable">idBlock</span> <span class="operator">=</span> commandExecutor.execute(commandConfig, <span class="keyword">new</span> <span class="title class_">GetNextIdBlockCmd</span>(idBlockSize));</span><br><span class="line"><span class="number">23</span>     <span class="built_in">this</span>.nextId = idBlock.getNextId();</span><br><span class="line"><span class="number">24</span>     <span class="built_in">this</span>.lastId = idBlock.getLastId();</span><br><span class="line"><span class="number">25</span>   &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，获取下一个id的方法是加锁的，<br>也就是在一台服务器上id的增长是没有问题的，但是如果将Activiti部署在多台服务器上就会有两个问题</p>
<p>从代码的第17，18行可以看出id是本地自增，如果有多台服务器就会出现id相同的情况（由并发写造成的）；<br>获取lastId的方法是操作同一个数据库的，会有问题，代码22中通过执行GetNextIdBlockCmd来获取数据库中的next.dbid的值，如果在多台服务器上由于一台服务器修改后，其他服务器无法知道</p>
<h1 id="Activiti-入门"><a href="#Activiti-入门" class="headerlink" title="Activiti 入门"></a>Activiti 入门</h1><p><img src="/blog/images/img/rm.png" alt="rm"></p>
<h2 id="定义和实例的概念"><a href="#定义和实例的概念" class="headerlink" title="定义和实例的概念"></a>定义和实例的概念</h2><p>流程定义：ProcessDefinition</p>
<p>类 Class ： 离职工作流定义</p>
<p>流程实例：ProcessInstance</p>
<p>对象 Obj ： 张三离职单流程</p>
<h2 id="加载最新的流程定义id"><a href="#加载最新的流程定义id" class="headerlink" title="加载最新的流程定义id"></a>加载最新的流程定义id</h2><p>查询所有流程定义，依次放入map集合；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 加载最新的流程定义的id</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> [相关类/方法](可选)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> [产品/模块版本](可选)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findLastVersionProcessDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">     List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionVersion().asc().list();</span><br><span class="line">     Map&lt;String, ProcessDefinition&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, ProcessDefinition&gt;();</span><br><span class="line">     <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (ProcessDefinition pd : list) &#123;</span><br><span class="line">             map.put(pd.getKey(), pd);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     List&lt;ProcessDefinition&gt; pdList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ProcessDefinition&gt;(map.values());</span><br><span class="line">     <span class="keyword">if</span> (pdList != <span class="literal">null</span> &amp;&amp; pdList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (ProcessDefinition pd : pdList) &#123;</span><br><span class="line">             System.out.println(pd.getName() + <span class="string">&quot;  ----  &quot;</span> + pd.getId());</span><br><span class="line">             InitializationBean.activitiMap.put(pd.getName(), pd.getId());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动流程</span></span><br><span class="line"><span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> repositoryService.createProcessDefinitionQuery().processDefinitionId(activitiProcdId).singleResult();</span><br><span class="line">Map&lt;String, String&gt; param = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">param.put(<span class="string">&quot;departureCode&quot;</span>, departureCode);</span><br><span class="line"><span class="type">ProcessInstance</span> <span class="variable">pi</span> <span class="operator">=</span> formService.submitStartFormData(processDefinition.getId(), param);</span><br><span class="line">logHelper.LoggerSendINFO(<span class="string">&quot;离职申请：&quot;</span> + departureCode + <span class="string">&quot; , 已提交，过程实例id： &quot;</span> + pi.getId());</span><br><span class="line">System.out.println(<span class="string">&quot;离职申请：&quot;</span> + departureCode + <span class="string">&quot; , 已提交，过程实例id： &quot;</span> + pi.getId());</span><br><span class="line"><span class="keyword">return</span> pi.getId();</span><br></pre></td></tr></table></figure>
<h2 id="部门经理审批"><a href="#部门经理审批" class="headerlink" title="部门经理审批"></a>部门经理审批</h2><p>结果标记字段：</p>
<p>拒绝离职： String departureRemark &#x3D; “false”;</p>
<p>同意离职：departureRemark &#x3D; “true”;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Boolean <span class="title function_">approvalTask</span><span class="params">(String departureCode, String procId, String departureRemark)</span> &#123;</span><br><span class="line">     <span class="comment">// 查询task</span></span><br><span class="line">     <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.queryTask(procId);</span><br><span class="line">     <span class="keyword">if</span> (<span class="literal">null</span> != task) &#123;</span><br><span class="line">         Map&lt;String, String&gt; properties = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">         properties.put(<span class="string">&quot;departureCode&quot;</span>, departureCode);</span><br><span class="line">         properties.put(<span class="string">&quot;departureRemark&quot;</span>, departureRemark);</span><br><span class="line">         formService.submitTaskFormData(task.getId(), properties);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据流程实例id 查询任务节点</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> procId 流程实例id</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 任务节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> Task <span class="title function_">queryTask</span><span class="params">(String procId)</span> &#123;</span><br><span class="line">     List&lt;Task&gt; tasks = taskService.createTaskQuery().processInstanceId(procId).list();</span><br><span class="line">     <span class="keyword">return</span> tasks.get(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="财务审批"><a href="#财务审批" class="headerlink" title="财务审批"></a>财务审批</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 查询task</span></span><br><span class="line"> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.queryTask(procId);</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">null</span> != task) &#123;</span><br><span class="line">     Map&lt;String, String&gt; properties = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">     properties.put(<span class="string">&quot;departureCode&quot;</span>, departureCode);</span><br><span class="line">     formService.submitTaskFormData(task.getId(), properties);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;工作流找不到&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据流程实例id 查询任务节点</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> procId 流程实例id</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 任务节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> Task <span class="title function_">queryTask</span><span class="params">(String procId)</span> &#123;</span><br><span class="line">     List&lt;Task&gt; tasks = taskService.createTaskQuery().processInstanceId(procId).list();</span><br><span class="line">     <span class="keyword">return</span> tasks.get(<span class="number">0</span>);</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<h1 id="Activiti-进阶"><a href="#Activiti-进阶" class="headerlink" title="Activiti 进阶"></a>Activiti 进阶</h1><p>流程定义 ProcessDefinition 和流程实例 ProcessInstance是Activiti中非常重要的两个概念。</p>
<p>他们的关系其实类似于JAVA中类和对象的概念。</p>
<p>流程定义ProcessDefinition是以BPMN文件定义的一个工作流程，是一组工作规范；</p>
<p>流程实例ProcessInstance则是指一个具体的业务流程。例如某个员工发起一次请假，就会实例化一个请假的流程实例，并且每个不同的流程实例之间是互不影响的。</p>
<p>在后台的表结构中，有很多张表都包含了流程定义ProcessDefinetion和流程实例ProcessInstance的字段。流程定义的字段通常是PROC_DEF_ID，而流程实例的字段通常是PROC_INST_ID。</p>
<h2 id="启动流程实例时，添加Businesskey"><a href="#启动流程实例时，添加Businesskey" class="headerlink" title="启动流程实例时，添加Businesskey"></a>启动流程实例时，添加Businesskey</h2><p>当我们去查看下startProcessInstanceByKey这个方法时，会看到这个方法有好几个<br>重载的实现方法，可以传一些不同的参数。其中几个重要的参数包括：</p>
<p>String processDefinitionKey：流程定义的唯一键 不能为空</p>
<p>String businessKey：每个线程实例上下文中关联的唯一键。这个也是我们这一章节要介绍的重点。</p>
<p>Map&lt;String,Object&gt; variables：在线程实例中传递的流程变量。这个流程变量可以在整个流程实例中使用，后面会介绍到。</p>
<p>String tenantId：租户ID，这是Activiti的多租户设计。相当于每个租户可以上来获取一个相对独立的运行环境。</p>
<h2 id="挂起和激活-流程实例"><a href="#挂起和激活-流程实例" class="headerlink" title="挂起和激活 流程实例"></a>挂起和激活 流程实例</h2><p>一种是将整个流程定义Process Definition挂起，这样，这个流程定义下的所有流程实例都将挂起，无法继续执行</p>
<p>另一种方式是将某一个具体的流程实例挂起。</p>
<h2 id="流程变量"><a href="#流程变量" class="headerlink" title="流程变量"></a>流程变量</h2><p>流程变量的类型是Map&lt;String,Object&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; param = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">            param.put(<span class="string">&quot;departureCode&quot;</span>, departureCode);</span><br><span class="line">            <span class="type">ProcessInstance</span> <span class="variable">pi</span> <span class="operator">=</span> formService.submitStartFormData(processDefinition.getId(), param);</span><br></pre></td></tr></table></figure>
<p>配置了这个流程后，可以配合流程变量使用。例如：执行完成后，可以在act_ru_variable表中看到刚才map中的数据<br>流程变量比业务关键字要强大很多。变量值不仅仅是字符串，也可以是POJO对象。但是当需要将一个POJO对象放入流程变量时，要注意这个对象必须要实现序列化接口</p>
<h3 id="流程变量的作用域"><a href="#流程变量的作用域" class="headerlink" title="流程变量的作用域"></a>流程变量的作用域</h3><p>变量的作用域可以设置为Global和Local两种</p>
<p>Global变量</p>
<p>这个是流程变量的默认作用域，表示是一个完整的流程实例。 Global变量中变量名不能重复。如果设置了相同的变量名，后面设置的值会直接覆盖前面设置的变量值。</p>
<p>Local 变量</p>
<p>Local变量的作用域只针对一个任务或一个执行实例的范围，没有流程实例大。</p>
<p>Local变量由于作用在不同的任务或不同的执行实例中，所以不同变量的作用域是互不影响的，变量名可以相同。Local变量名也可以和Global变量名相同，不会有影响。</p>
<h3 id="使用流程变量"><a href="#使用流程变量" class="headerlink" title="使用流程变量"></a>使用流程变量</h3><p>定义好流程变量后，就可以在整个流程定义中使用这些流程变量了。<br>设置Global流程变量</p>
<p>1） 启动流程时设置变量</p>
<p>2） 任务办理时设置变量</p>
<p>3） 通过当前流程实例设置</p>
<p>4） 通过当前任务设置</p>
<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>网关是用来控制流程流向的重要组件，通常都会要结合流程变量来使用。</p>
<h2 id="排他网关ExclusiveGateway（常用）"><a href="#排他网关ExclusiveGateway（常用）" class="headerlink" title="排他网关ExclusiveGateway（常用）"></a>排他网关ExclusiveGateway（常用）</h2><p>排他网关，用来在流程中实现决策。</p>
<p>当流程执行到这个网关，所有分支都会判断条件是否为true，如果为true则执行该分支</p>
<p>注意 ：</p>
<p>排他网关只会选择一个为true的分支执行。如果有两个分支条件都为true，排他网关会选择id值较小的一条分支去执行。</p>
<p>如果从网关出去的线所有条件都不满足则系统抛出异常。</p>
<p>例如下面流程，请假天数小于等于1天，科任老师老师批准，请假流程结束；请假天数大于1天，就需要班主任批准。</p>
<p><img src="/blog/images/img/exclusiveGateway.png" alt="exclusiveGateway"></p>
<h2 id="并行网关ParallelGateway"><a href="#并行网关ParallelGateway" class="headerlink" title="并行网关ParallelGateway"></a>并行网关ParallelGateway</h2><p>并行网关允许将流程分成多条分支，也可以把多条分支汇聚到一起，并行网关的功能是基于进入和外出顺序流的：并行网关在业务应用中常用于会签任务，会签任务即多个参与者共同办理的任务</p>
<p>与其他网关的主要区别是，并行网关不会解析条件。 即使顺序流中定义了条件，也会被忽略。</p>
<p>例如下面流程，需要科任老师批准、班主任批准，请假流程才能结束。</p>
<p><img src="/blog/images/img/parallelGateway.png" alt="parallelGateway"></p>
<h2 id="包含网关InclusiveGateway"><a href="#包含网关InclusiveGateway" class="headerlink" title="包含网关InclusiveGateway"></a>包含网关InclusiveGateway</h2><p>包含网关可以看做是排他网关和并行网关的结合体。</p>
<p>包含网关的功能是基于进入和外出顺序流的：</p>
<p>分支： 所有外出顺序流的条件都会被解析，结果为true的顺序流会以并行方式继续执行， 会为每个顺序流创建一个分支。</p>
<p>汇聚： 所有并行分支到达包含网关，会进入等待状态， 直到每个包含流程token的进入顺序流的分支都到达。</p>
<p>例如下面流程，请假天数小于等于1天，科任老师老师批准，请假流程结束；请假天数大于1天，班主任批准，请假流程结束；请假天数大于三天，就需要班主任批准、校长批准，请假流程才能结束。</p>
<p><img src="/blog/images/img/inclusiveGateway.png" alt="inclusiveGateway"></p>
<h2 id="事件网关EventGateway"><a href="#事件网关EventGateway" class="headerlink" title="事件网关EventGateway"></a>事件网关EventGateway</h2><h1 id="组任务分配"><a href="#组任务分配" class="headerlink" title="组任务分配"></a>组任务分配</h1><h2 id="设置多个候选责任人"><a href="#设置多个候选责任人" class="headerlink" title="设置多个候选责任人"></a>设置多个候选责任人</h2><p>某个订单合同，需要找部门经理级别的负责人签字。而公司中有多个部门经理，业务上只需要找其中任意一个人完成审批就可以了。</p>
<p>这种场景下，我们就无法通过设置流程变量的方式来设置负责人。这时，就需要用到Activiti提供的另一个利器-任务候选人Candidate Users。</p>
<h2 id="组任务办理流程"><a href="#组任务办理流程" class="headerlink" title="组任务办理流程"></a>组任务办理流程</h2><p>给任务分配了候选人后，后续就需要这些候选人主动认领自己的业务，然后进行处理。</p>
<p>先查询任务</p>
<p>再认领任务（也可以退还任务）</p>
<p>最后完成任务</p>
<h1 id="Activiti-核心类"><a href="#Activiti-核心类" class="headerlink" title="Activiti 核心类"></a>Activiti 核心类</h1><h2 id="RepositoryService-仓储服务"><a href="#RepositoryService-仓储服务" class="headerlink" title="RepositoryService-仓储服务"></a>RepositoryService-仓储服务</h2><p>Activiti的资源管理类，提供了管理和控制流程发布包和流程定义的操作。</p>
<p>仓储服务可以用来部署我们的流程图，还可以创建我们的流程部署查询对象，用于查询刚刚部署的流程列表，便于我们管理流程，方法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//这个是部署流程的方法，流程图以inputStream流的形式传入	 </span></span><br><span class="line"><span class="type">DeploymentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> repositoryService.createDeployment(); </span><br><span class="line">builder.name(process.getName()); </span><br><span class="line">builder.addInputStream(fileName, inputStream); </span><br><span class="line"><span class="type">Deployment</span> <span class="variable">deployment</span> <span class="operator">=</span> builder.deploy(); </span><br><span class="line"><span class="comment">//这个是流程部署列表查询的方法 </span></span><br><span class="line"><span class="type">DeploymentQuery</span> <span class="variable">deploymentQuery</span> <span class="operator">=</span> repositoryService.createDeploymentQuery(); </span><br><span class="line"><span class="comment">//可以根据很多条件查询，我这是根据部署名称模糊查询 </span></span><br><span class="line">List&lt;Deployment&gt; list = deploymentQuery.deploymentNameLike(<span class="string">&quot;%&quot;</span>+name+<span class="string">&quot;%&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="RuntimeService-activiti运行时服务"><a href="#RuntimeService-activiti运行时服务" class="headerlink" title="RuntimeService-activiti运行时服务"></a>RuntimeService-activiti运行时服务</h2><p>Activiti的流程运行管理类。可以从这个服务类中获取很多关于流程执行相关的信息</p>
<p>运行时服务主要用来开启流程实例，一个流程实例对应多个任务，也就是多个流程节点，好比如请假审批是一个流程实例，部门主管，部门经理，总经理都是节点，我们开启服务是通过流程定义key或者流程定义id来开启的，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先根据部署id创建流程定义 </span></span><br><span class="line"><span class="type">ProcessDefinition</span> <span class="variable">def</span> <span class="operator">=</span> repositoryService.createProcessDefinitionQuery().deploymentId(form.getDeployId()).singleResult(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//然后根据流程定义id或者key开启流程实例	 </span></span><br><span class="line"><span class="type">ProcessInstance</span> <span class="variable">proInst</span> <span class="operator">=</span> runtimeService.startProcessInstanceById(def.getId());</span><br></pre></td></tr></table></figure>

<p>备注：当我们用仓储服务部署了流程图之后，就会产生一个流程部署id，一个流程部署id对应一个流程定义，一个流程定义对应多个流程实例，一个流程实例对应多个任务节点</p>
<h2 id="TaskService-任务服务"><a href="#TaskService-任务服务" class="headerlink" title="TaskService-任务服务"></a>TaskService-任务服务</h2><p>任务服务是用来可以用来领取，完成，查询任务列表功能的，使用方法分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据任务id和用户领取任务 </span></span><br><span class="line">taskService.claim(String taskId, String userId) </span><br><span class="line"><span class="comment">//根据任务id完成自己节点的任务 </span></span><br><span class="line">taskService.complete(String taskId) </span><br><span class="line"><span class="comment">//创建任务查询对象之后根据候选人也就是任务处理人查询自己的任务列表 </span></span><br><span class="line">taskService.createTaskQuery().taskAssignee(String assignee)</span><br></pre></td></tr></table></figure>
<h2 id="HistoryService-历史服务"><a href="#HistoryService-历史服务" class="headerlink" title="HistoryService-历史服务"></a>HistoryService-历史服务</h2><p>历史服务可以查看审批人曾经审批完成了哪些项目，审批项目总共花了多少时间，以及在哪个环节比较耗费时间等等，便于审批人查看历史信息，方法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据审批人查看该审批人审批了哪些项目 </span></span><br><span class="line">List&lt;HistoricTaskInstance&gt; = historyService.createHistoricTaskInstanceQuery().</span><br><span class="line">taskAssignee(String assignee).finished().list();</span><br></pre></td></tr></table></figure>
<p>历史任务对象HistoricTaskInstance，它里面封装了任务开始时间，结束时间，该节点花费的时间等等信息。</p>
<h2 id="FormService-表单服务"><a href="#FormService-表单服务" class="headerlink" title="FormService-表单服务"></a>FormService-表单服务</h2><p>主要是操作用户信息，用户分组信息等，组信息包括如部门表和职位表</p>
]]></content>
      <categories>
        <category>工作流</category>
        <category>activiti7</category>
        <category>简介</category>
      </categories>
  </entry>
  <entry>
    <title>1-创建流程引擎</title>
    <url>/blog/2024/01/14/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti7/1-%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="创建springboot工程，引入maven依赖"><a href="#创建springboot工程，引入maven依赖" class="headerlink" title="创建springboot工程，引入maven依赖"></a>创建springboot工程，引入maven依赖</h1><p>IDEA创建springboot工程，项目名称 activiti-demo</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>activiti-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>activiti-demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.0.M6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="创建工作流引擎"><a href="#创建工作流引擎" class="headerlink" title="创建工作流引擎"></a>创建工作流引擎</h1><h2 id="第一种读取xml方式"><a href="#第一种读取xml方式" class="headerlink" title="第一种读取xml方式"></a>第一种读取xml方式</h2><p>在项目resources文件夹下创建activiti.cfg.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在默认方式下 bean的id  固定为 processEngineConfiguration--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置数据库相关的信息--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcDriver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库链接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activiti-demo?nullCatalogMeansCurrent=true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUsername&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcPassword&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--actviti数据库表在生成时的策略</span></span><br><span class="line"><span class="comment">        true - 如果数据库中已经存在相应的表，那么直接使用，</span></span><br><span class="line"><span class="comment">               如果不存在，那么会创建--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建单元测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getDefaultProcessEngine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    System.out.println(defaultProcessEngine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第二种java代码方式"><a href="#第二种java代码方式" class="headerlink" title="第二种java代码方式"></a>第二种java代码方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">buildProcessEngine</span><span class="params">()</span> &#123;</span><br><span class="line">    ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration()</span><br><span class="line">            .setJdbcDriver(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span><br><span class="line">            .setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/activiti7?nullCatalogMeansCurrent=true&quot;</span>)</span><br><span class="line">            .setJdbcUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">            .setJdbcPassword(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">            .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE)</span><br><span class="line">            .buildProcessEngine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式创建完后，数据库都会创建25张表。</p>
]]></content>
      <categories>
        <category>工作流</category>
        <category>activiti7</category>
        <category>创建流程引擎</category>
      </categories>
  </entry>
  <entry>
    <title>4-发起流程</title>
    <url>/blog/2024/01/14/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti7/4-%E5%8F%91%E8%B5%B7%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="发起流程"><a href="#发起流程" class="headerlink" title="发起流程"></a>发起流程</h1><p>发起一个流程后，act_ru_task会增加一条记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">startProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> defaultProcessEngine.getRuntimeService();</span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.startProcessInstanceById(<span class="string">&quot;test1:1:3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;processInstance.getId() = &quot;</span> + processInstance.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="待办查询"><a href="#待办查询" class="headerlink" title="待办查询"></a>待办查询</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询待办任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">queryTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> defaultProcessEngine.getTaskService();</span><br><span class="line">    List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(<span class="string">&quot;zhangsan&quot;</span>).list();</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task.getId() = &quot;</span> + task.getId());</span><br><span class="line">            System.out.println(<span class="string">&quot;task.getName() = &quot;</span> + task.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;task.getAssignee() = &quot;</span> + task.getAssignee());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前没有待办任务~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行待办任务"><a href="#执行待办任务" class="headerlink" title="执行待办任务"></a>执行待办任务</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行待办任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> defaultProcessEngine.getTaskService();</span><br><span class="line">    List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(<span class="string">&quot;zhangsan&quot;</span>).list();</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Task task : list) &#123;</span><br><span class="line">            taskService.complete(task.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前没有待办任务~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>工作流</category>
        <category>activiti7</category>
        <category>发起流程</category>
      </categories>
  </entry>
  <entry>
    <title>5-任务分配</title>
    <url>/blog/2024/01/15/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti7/5-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="值表达式"><a href="#值表达式" class="headerlink" title="值表达式"></a>值表达式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$&#123;变量名称&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$&#123;bean.demo&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>返回是一个执行人名称</p>
<h1 id="监听器配置"><a href="#监听器配置" class="headerlink" title="监听器配置"></a>监听器配置</h1><p>实现TaskListener接口</p>
]]></content>
      <categories>
        <category>工作流</category>
        <category>activiti7</category>
        <category>任务分配</category>
      </categories>
  </entry>
  <entry>
    <title>2-activiti自带流程设计器</title>
    <url>/blog/2024/01/14/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti7/2-activiti%E8%87%AA%E5%B8%A6%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="Activiti官网下载Activiti-6-0"><a href="#Activiti官网下载Activiti-6-0" class="headerlink" title="Activiti官网下载Activiti 6.0"></a>Activiti官网下载Activiti 6.0</h1><p><img src="/blog/images/img/activiti01.png" alt="activiti01"></p>
<h1 id="解压后把wars文件下的三个war包放到tomcat8中发布（jdk环境为1-8）"><a href="#解压后把wars文件下的三个war包放到tomcat8中发布（jdk环境为1-8）" class="headerlink" title="解压后把wars文件下的三个war包放到tomcat8中发布（jdk环境为1.8）"></a>解压后把wars文件下的三个war包放到tomcat8中发布（jdk环境为1.8）</h1><h1 id="访问流程设计器，开始设计流程图"><a href="#访问流程设计器，开始设计流程图" class="headerlink" title="访问流程设计器，开始设计流程图"></a>访问流程设计器，开始设计流程图</h1><p>访问<a href="http://localhost:8080/activiti-app">http://localhost:8080/activiti-app</a> 输入账号密码（admin&#x2F;test）</p>
]]></content>
      <categories>
        <category>工作流</category>
        <category>activiti7</category>
        <category>自带流程设计器</category>
      </categories>
  </entry>
  <entry>
    <title>3-部署一个流程</title>
    <url>/blog/2024/01/14/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti7/3-%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="部署一个流程"><a href="#部署一个流程" class="headerlink" title="部署一个流程"></a>部署一个流程</h1><p>下载流程设计器的流程模板，放到工程resource下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部署流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createDeployment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> defaultProcessEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;process/test1.bpmn20.xml&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;第一个测试流程&quot;</span>)</span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(deploy.getId());</span><br><span class="line">    System.out.println(deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完后，流程定义表（act_re_procdef）和流程部署表（act_re_deployment）会分别记录相关信息。</p>
<h1 id="查询部署的流程"><a href="#查询部署的流程" class="headerlink" title="查询部署的流程"></a>查询部署的流程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询流程部署</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">queryProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> defaultProcessEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">// 获取部署查询对象（部署了多少个流程）</span></span><br><span class="line">    <span class="type">DeploymentQuery</span> <span class="variable">deploymentQuery</span> <span class="operator">=</span> repositoryService.createDeploymentQuery();</span><br><span class="line">    List&lt;Deployment&gt; list = deploymentQuery.list();</span><br><span class="line">    <span class="keyword">for</span> (Deployment deployment : list) &#123;</span><br><span class="line">        System.out.println(deployment.getId()+<span class="string">&quot;:&quot;</span>+deployment.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取流程定义查询对象（流程定义了多少个）</span></span><br><span class="line">    <span class="type">ProcessDefinitionQuery</span> <span class="variable">processDefinitionQuery</span> <span class="operator">=</span> repositoryService.createProcessDefinitionQuery();</span><br><span class="line">    List&lt;ProcessDefinition&gt; list1 = processDefinitionQuery.list();</span><br><span class="line">    <span class="keyword">for</span> (ProcessDefinition processDefinition : list1) &#123;</span><br><span class="line">        System.out.println(processDefinition.getId()+<span class="string">&quot;:&quot;</span>+processDefinition.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作流</category>
        <category>activiti7</category>
        <category>部署流程</category>
      </categories>
  </entry>
  <entry>
    <title>6-流程变量</title>
    <url>/blog/2024/01/15/%E5%B7%A5%E4%BD%9C%E6%B5%81/activiti7/6-%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="运行时变量"><a href="#运行时变量" class="headerlink" title="运行时变量"></a>运行时变量</h1><p>全局变量、局部变量、历史变量</p>
]]></content>
      <categories>
        <category>工作流</category>
        <category>activiti7</category>
        <category>流程变量</category>
      </categories>
  </entry>
  <entry>
    <title>1.SpringMVC简介</title>
    <url>/blog/2023/06/02/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/1.SpringMVC%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="1-1-Spring-Web-MVC是什么"><a href="#1-1-Spring-Web-MVC是什么" class="headerlink" title="1.1 Spring Web MVC是什么"></a>1.1 Spring Web MVC是什么</h1><p>Spring Web MVC 是一种基于 Java 的实现了 Web MVC 设计模式的请求驱动类型的轻量级 Web 框架，即使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC 也是要简化我们日常 Web 开发的。在 传统的 Jsp&#x2F;Servlet 技术体系中，如果要开发接口，一个接口对应一个 Servlet，会导致我们开发出许多 Servlet，使用 SpringMVC 可以有效的简化这一步骤。 </p>
<p>Spring Web MVC 也是服务到工作者模式的实现，但进行可优化。前端控制器是 DispatcherServlet；应用控制器可以拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View Resolver)进行视图管理；页面控制器&#x2F;动作&#x2F;处理器为 Controller 接口（仅包含 ModelAndView handleRequest(request, response) 方法，也有人称作 Handler）的实现（也可以是任何的 POJO 类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。 </p>
<h1 id="1-2-Spring-Web-MVC能帮我们做什么"><a href="#1-2-Spring-Web-MVC能帮我们做什么" class="headerlink" title="1.2 Spring Web MVC能帮我们做什么"></a>1.2 Spring Web MVC能帮我们做什么</h1><p>让我们能非常简单的设计出干净的 Web 层和薄薄的 Web 层； 进行更简洁的 Web 层的开发； 天生与 Spring 框架集成（如 IoC 容器、AOP 等）； 提供强大的约定大于配置的契约式编程支持； 能简单的进行 Web 层的单元测试； 支持灵活的 URL 到页面控制器的映射； 非常容易与其他视图技术集成，如 Velocity、FreeMarker 等等，因为模型数据不放在特定的 API 里，而是放在一个 Model 里（Map 数据结构实现，因此很容易被其他框架使用）； 非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现特定框架的 API； 提供一套强大的 JSP 标签库，简化 JSP 开发； 支持灵活的本地化、主题等解析； 更加简单的异常处理； 对静态资源的支持； 支持 RESTful 风格</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>12.SpringMVC静态资源访问</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/11.SpringMVC%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>在 SpringMVC 中，静态资源，默认都是被拦截的，例如 html、js、css、jpg、png、txt、pdf 等等，都是无法直接访问的。因为所有请求都被拦截了，所以，针对静态资源，我们要做额外处理，处理方式很简单，直接在 SpringMVC 的配置文件中，添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/static/html/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/static/html/&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mapping 表示映射规则，也是拦截规则，就是说，如果请求地址是 &#x2F;static&#x2F;html 这样的格式的话，那么对应的资源就去 &#x2F;static&#x2F;html&#x2F; 这个目录下查找。 在映射路径的定义中，最后是两个 *，这是一种 Ant 风格的路径匹配符号，一共有三个通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>**</td>
<td>匹配多层路径</td>
</tr>
<tr>
<td>*</td>
<td>匹配一层路径</td>
</tr>
<tr>
<td>？</td>
<td>任意匹配单个字符</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>11.RESTful</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/10.RESTful/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>越来越多的人开始意识到，网站即软件，而且是一种新型的软件。这种”互联网软件”采用客户端&#x2F;服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。 </p>
<p>RESTful 架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 </p>
<p>但是，到底什么是 RESTful 架构，并不是一个容易说清楚的问题。</p>
<p>下面，我就谈谈我理解的 RESTful 架构。、 RESTful 它不是一个具体的架构，不是一个软件，不是一个框架，而是一种规范。在移动互联网兴起之前，我们都很少提及 RESTful，主要是因为用的少，移动互联网兴起后，RESTful 得到了非常广泛的应用，因为在移动互联网兴起之后，我们再开发后端应用，就不仅仅只是开发一个网站了，还对应了多个前端（Android、iOS、HTML5 等等），这个时候，我们在设计后端接口是，就需要考虑接口的形式，格式，参数的传递等等诸多问题了。 </p>
<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>REST 这个词，是 Roy Thomas Fielding 在他 2000 年的博士论文中提出的。 </p>
<p>Fielding 是一个非常重要的人，他是 HTTP 协议（1.0版和1.1版）的主要设计者、Apache 服务器软件的作者之一、Apache 基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。 </p>
<p>他这样介绍论文的写作目的： </p>
<p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。” </p>
<h1 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h1><p>Fielding 将他对互联网软件的架构原则，定名为REST，即 Representational State Transfer 的缩写。我对这个词组的翻译是”表现层状态转化”。 </p>
<p>如果一个架构符合 REST 原则，就称它为 RESTful 架构。 </p>
<p>要理解 RESTful 架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。 </p>
<h1 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h1><p>REST 的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 </p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI （统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。 </p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的 URI。</p>
<blockquote>
<p>在 RESTful 风格的应用中，每一个 URI 都代表了一个资源。 </p>
</blockquote>
<h1 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h1><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 </p>
<p>比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。 </p>
<p>URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 “.html” 后缀名是不必要的，因为这个后缀名表示格式，属于 “表现层” 范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。 </p>
<h1 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h1><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 </p>
<p>互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 </p>
<p>客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p>
<p>它们分别对应四种基本操作： </p>
<ul>
<li>GET 用来获取资源 </li>
<li>POST 用来新建资源（也可以用于更新资源） </li>
<li>PUT 用来更新资源 </li>
<li>DELETE 用来删除资源</li>
</ul>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>综合上面的解释，我们总结一下什么是 RESTful 架构： </p>
<ul>
<li>每一个 URI 代表一种资源； </li>
<li>客户端和服务器之间，传递这种资源的某种表现层； </li>
<li>客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ul>
<h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><p>RESTful 架构有一些典型的设计误区。 </p>
<p>最常见的一种设计错误，就是 URI 包含动词。因为”资源”表示一种实体，所以应该是名词，URI 不应该有动词，动词应该放在 HTTP 协议中。 举例来说，某个 URI 是 &#x2F;posts&#x2F;show&#x2F;1，其中 show 是动词，这个 URI 就设计错了，正确的写法应该是 &#x2F;posts&#x2F;1，然后用 GET 方法表示 show。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>13.SpringMVC拦截器</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/12.SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>SpringMVC 中的拦截器，相当于 Jsp&#x2F;Servlet 中的过滤器，只不过拦截器的功能更为强大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1:preHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1:postHandle&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1:afterCompletion&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor2</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor2:preHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor2:postHandle&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor2:afterCompletion&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>拦截器定义好之后，需要在 SpringMVC 的配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果存在多个拦截器，拦截规则如下： </p>
<ul>
<li>preHandle 按拦截器定义顺序调用 </li>
<li>postHandler 按拦截器定义逆序调用 </li>
<li>afterCompletion 按拦截器定义逆序调用 </li>
<li>postHandler 在拦截器链内所有拦截器返成功调用 </li>
<li>afterCompletion 只有 preHandle 返回 true 才调用</li>
</ul>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>3.SpringMvc工作流</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/3.SpringMvc%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="/blog/images/img/springmvc.png" alt="springmvc工作流"></p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>5.SpringMVC DispatcherServlet</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/5.SpringMVCDispatcherServlet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="DispatcherServlet作用"><a href="#DispatcherServlet作用" class="headerlink" title="DispatcherServlet作用"></a>DispatcherServlet作用</h1><p>DispatcherServlet 是前端控制器设计模式的实现，提供 Spring Web MVC 的集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成，从而可以获得 Spring 的所有好处。DispatcherServlet 主要用作职责调度工作，本身主要用于控制流程，主要职责如下： 文件上传解析，如果请求类型是 multipart 将通过 MultipartResolver 进行文件上传解析； 通过 HandlerMapping，将请求映射到处理器（返回一个 HandlerExecutionChain，它包括一个处理器、多个 HandlerInterceptor 拦截器）； 通过 HandlerAdapter 支持多种类型的处理器(HandlerExecutionChain 中的处理器)； 通过 ViewResolver 解析逻辑视图名到具体视图实现； 本地化解析； 渲染具体的视图等； 如果执行过程中遇到异常将交给 HandlerExceptionResolver 来解析 </p>
<h1 id="5-2-DispathcherServlet配置详解"><a href="#5-2-DispathcherServlet配置详解" class="headerlink" title="5.2 DispathcherServlet配置详解"></a>5.2 DispathcherServlet配置详解</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>load-on-startup：表示启动容器时初始化该 Servlet； </li>
<li>url-pattern：表示哪些请求交给 Spring Web MVC 处理， “&#x2F;“ 是用来定义默认 servlet 映射的。也可以如 *.html 表示拦截所有以 html 为扩展名的请求 </li>
<li>contextConfigLocation：表示 SpringMVC 配置文件的路径</li>
</ul>
<h1 id="两个容器"><a href="#两个容器" class="headerlink" title="两个容器"></a>两个容器</h1><p>当 Spring 和 SpringMVC 同时出现，我们的项目中将存在两个容器，一个是 Spring 容器，另一个是 SpringMVC 容器，Spring 容器通过 ContextLoaderListener 来加载，SpringMVC 容器则通过 DispatcherServlet 来加载，这两个容器不一样：<br><img src="/blog/images/img/springmvc002.png" alt="springmvc002"><br>从图中可以看出： </p>
<ul>
<li>ContextLoaderListener 初始化的上下文加载的 Bean 是对于整个应用程序共享的，不管是使用什么表现层技术，一般如 DAO 层、Service 层 Bean； </li>
<li>DispatcherServlet 初始化的上下文加载的 Bean 是只对 Spring Web MVC 有效的 Bean，如 Controller、HandlerMapping、HandlerAdapter 等等，该初始化上下文应该只加载 Web相关组件。 <blockquote>
<p>为什么不在 Spring 容器中扫描所有 Bean？ 这个是不可能的。</p>
</blockquote>
</li>
</ul>
<p>因为请求达到服务端后，找 DispatcherServlet 去处理，只会去 SpringMVC 容器中找，这就意味着 Controller 必须在 SpringMVC 容器中扫描。 </p>
<blockquote>
<p>为什么不在 SpringMVC 容器中扫描所有 Bean？ </p>
</blockquote>
<p>这个是可以的，可以在 SpringMVC 容器中扫描所有 Bean。不写在一起，有两个方面的原因： 为了方便配置文件的管理 在 Spring+SpringMVC+Hibernate 组合中，实际上也不支持这种写法</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>4.SpringMvc中的组件</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/4.SpringMvc%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><ol>
<li>DispatcherServlet：前端控制器</li>
</ol>
<p>用户请求到达前端控制器，它就相当于 mvc 模式中的c，DispatcherServlet 是整个流程控制的中心，相当于是 SpringMVC 的大脑，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 </p>
<h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><ol start="2">
<li>HandlerMapping：处理器映射器</li>
</ol>
<p>HandlerMapping 负责根据用户请求找到 Handler 即处理器（也就是我们所说的 Controller），SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等，在实际开发中，我们常用的方式是注解方式。 </p>
<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><ol start="3">
<li>Handler：处理器</li>
</ol>
<p>Handler 是继 DispatcherServlet 前端控制器的后端控制器，在DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 Handler。（这里所说的 Handler 就是指我们的 Controller） </p>
<h1 id="HandlAdapter"><a href="#HandlAdapter" class="headerlink" title="HandlAdapter"></a>HandlAdapter</h1><ol start="4">
<li>HandlAdapter：处理器适配器</li>
</ol>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 </p>
<h1 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h1><ol start="5">
<li>ViewResolver：视图解析器</li>
</ol>
<p>ViewResolver 负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>2.SpringMVCHelloWorld</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/2.SpringMVCHelloWorld/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol>
<li><p>利用 Maven 创建一个 web 工程（参考 Maven 教程）。</p>
</li>
<li><p>在 pom.xml 文件中，添加 spring-webmvc 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SpringMVC坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Servlet坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Jsp坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加了 spring-webmvc 依赖之后，其他的 spring-web、spring-aop、spring-context 等等就全部都加入进来了。</p>
</li>
<li><p>准备一个 Controller，即一个处理浏览器请求的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">hello</span><span class="params">(ModelAndView mav)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">        mav.setViewName(<span class="string">&quot;index.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建视图 这里我们就采用 jsp 作为视图，在 webapp 目录下创建 index.jsp 文件，内容如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello &lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在 resources 目录下，创建一个名为 spring-mvc.xml 的 springmvc 的配置文件，这里，我们先写一个简单的 demo ，因此可以先不用添加 spring 的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhangjie&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>加载 springmvc 配置文件 在 web 项目启动时，加载 springmvc 配置文件，这个配置是在 web.xml 中完成的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;的作用</span></span><br><span class="line"><span class="comment">           1)load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其init()方法)。</span></span><br><span class="line"><span class="comment">           2)它的值必须是一个整数，表示servlet应该被载入的顺序</span></span><br><span class="line"><span class="comment">           3)当值为0或者大于0时，表示容器在应用启动时就加载并初始化这个servlet；</span></span><br><span class="line"><span class="comment">           4)当值小于0或者没有指定时，则表示容器在该servlet被选择时才会去加载。</span></span><br><span class="line"><span class="comment">           5)正数的值越小，该servlet的优先级越高，应用启动时就越先加载。</span></span><br><span class="line"><span class="comment">           6)当值相同时，容器就会自己选择顺序来加载。</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>配置并启动项目（参考 Maven 教程） </p>
</li>
<li><p>项目启动成功后，浏览器输入 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 就可以看到如下页面：</p>
</li>
</ol>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>7.SpringMVC文件上传</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/7.SpringMVC%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>SpringMVC 中对文件上传做了封装，我们可以更加方便的实现文件上传。从 Spring3.1 开始，对于文件上传，提供了两个处理器： </p>
<ul>
<li>CommonsMultipartResolver </li>
<li>StandardServletMultipartResolver</li>
</ul>
<p>第一个处理器兼容性较好，可以兼容 Servlet3.0 之前的版本，但是它依赖了 commons-fileupload 这个第三方工具，所以如果使用这个，一定要添加 commons-fileupload 依赖。 </p>
<p>第二个处理器兼容性较差，它适用于 Servlet3.0 之后的版本，它不依赖第三方工具，使用它，可以直接做文件上传。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>6.SpringMVC处理器详解</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/6.SpringMVC%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><blockquote>
<p>注意，下文所说的处理器即我们平时所见到的 Controller </p>
</blockquote>
<p>HandlerMapping ，中文译作处理器映射器，在 SpringMVC 中，系统提供了很多 HandlerMapping：<br><img src="/blog/images/img/springmvc003.png" alt="springmvc003"></p>
<p>HandlerMapping 是负责根据 request 请求找到对应的 Handler 处理器及 Interceptor 拦截器，将它们封装在 HandlerExecutionChain 对象中返回给前端控制器。</p>
<h1 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h1><p>HandlerAdapter，中文译作处理器适配器。 HandlerAdapter 会根据适配器接口对后端控制器进行包装（适配），包装后即可对处理器进行执行，通过扩展处理器适配器可以执行多种类型的处理器，这里使用了适配器设计模式。</p>
]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>8.SpringMVC全局异常处理</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/8.SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>项目中，可能会抛出多个异常，我们不可以直接将异常的堆栈信息展示给用户，有两个原因： </p>
<ul>
<li>用户体验不好 </li>
<li>非常不安全</li>
</ul>
<p>所以，针对异常，我们可以自定义异常处理，SpringMVC 中，针对全局异常也提供了相应的解决方案，主要是通过 @ControllerAdvice 和 @ExceptionHandler 两个注解来处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//表示这是一个增强版的 Controller，主要用来做全局数据处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">fileuploadException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        error.addObject(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里： @ControllerAdvice 表示这是一个增强版的 Controller，主要用来做全局数据处理 @ExceptionHandler 表示这是一个异常处理方法，这个注解的参数，表示需要拦截的异常，参数为 Exception 表示拦截所有异常，这里也可以具体到某一个异常，如果具体到某一个异常，那么发生了其他异常则不会被拦截到。 异常方法的定义，和 Controller 中方法的定义一样，可以返回 ModelAndview，也可以返回 String 或者 void</p>
<p>例如如下代码，指挥拦截文件上传异常，其他异常和它没关系，不会进入到自定义异常处理的方法中来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//表示这是一个增强版的 Controller，主要用来做全局数据处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(MaxUploadSizeExceededException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">fileuploadException</span><span class="params">(MaxUploadSizeExceededException e)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        error.addObject(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>10.SpringMVC JSON处理</title>
    <url>/blog/2023/06/01/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/springmvc/9.SpringMVC%20JSON%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>目前主流的 JSON 处理工具主要有三种： </p>
<ul>
<li>jackson </li>
<li>gson </li>
<li>fastjson</li>
</ul>
<p>在 SpringMVC 中，对 jackson 和 gson 都提供了相应的支持，就是如果使用这两个作为 JSON 转换器，只需要添加对应的依赖就可以了，返回的对象和返回的集合、Map 等都会自动转为 JSON，但是，如果使用 fastjson，除了添加相应的依赖之外，还需要自己手动配置 HttpMessageConverter 转换器。其实前两个也是使用 HttpMessageConverter 转换器，但是是 SpringMVC  自动提供的，SpringMVC 没有给 fastjson 提供相应的转换器。</p>
<h1 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a>jackson</h1><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们想自己定制返回日期的格式，简单的办法，可以通过添加注解来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;Asia/Shanghai&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date publish;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，这种方式有一个弊端，这个注解可以加在属性上，也可以加在类上，也就说，最大可以作用到一个类中的所有日期属性上。如果项目中有很多实体类都需要做日期格式化，使用这种方式就比较麻烦了，这个时候，我们可以自己提供一个 jackson 的 HttpMesageConverter 实例，在这个实例中，自己去配置相关属性，这里的配置将是一个全局配置。 在 SpringMVC 配置文件中，添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;httpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span> <span class="attr">id</span>=<span class="string">&quot;httpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;java.text.SimpleDateFormat&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeZone&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="gson"><a href="#gson" class="headerlink" title="gson"></a>gson</h1><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果项目中，同时存在 jackson 和 gson 的话，那么默认使用的是 jackson，为社么呢？在 org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter 类的构造方法中，加载顺序就是先加载 jackson 的HttpMessageConverter，后加载 gson 的 HttpMessageConverter。 加完依赖之后，就可以直接返回 JSON 字符串了。使用 Gson 时，如果想做自定义配置，则需要自定义 HttpMessageConverter。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;httpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.GsonHttpMessageConverter&quot;</span> <span class="attr">id</span>=<span class="string">&quot;httpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gson&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.google.gson.Gson&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;gsonBuilder&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;create&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.google.gson.GsonBuilder&quot;</span> <span class="attr">id</span>=<span class="string">&quot;gsonBuilder&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h1><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;httpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span> <span class="attr">id</span>=<span class="string">&quot;httpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fastJsonConfig&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>fastjson 默认中文乱码，添加如下配置解决：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;httpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span> <span class="attr">id</span>=<span class="string">&quot;httpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fastJsonConfig&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="接受json"><a href="#接受json" class="headerlink" title="接受json"></a>接受json</h1><p>使用注解 @RequestBody</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/addbook3&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook3</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>工作流简介</title>
    <url>/blog/2024/01/11/%E5%B7%A5%E4%BD%9C%E6%B5%81/%E7%AE%80%E4%BB%8B/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="工作流介绍"><a href="#工作流介绍" class="headerlink" title="工作流介绍"></a>工作流介绍</h1><p>工作流（Workflow），指“业务过程的部分或整体在计算机应用环境下的自动化”。是对工作流程及其各操作步骤之间业务规则的抽象、概括描述。在计算机中，工作流属于计算机支持的协同工作（CSCW）的一部分。后者是普遍地研究一个群体如何在计算机的帮助下实现协同工作的。</p>
<p>工作流主要解决的主要问题是：为了实现某个业务目标，利用计算机在多个参与者之间按某种预定规则自动传递文档、信息或者任务。</p>
<p>工作流管理系统(Workflow Management System, WfMS)是一个软件系统，它完成工作量的定义和管理，按照在系统中预先定义好的工作流逻辑进行工作流实例的执行。</p>
<h1 id="选型的几个标准："><a href="#选型的几个标准：" class="headerlink" title="选型的几个标准："></a>选型的几个标准：</h1><ul>
<li>社区活跃，至少在Github上能排上名的</li>
<li>至少支持BPMN2协议的</li>
<li>免费、开源</li>
</ul>
<p>根据上面的标准，目前几大工作流引擎就只有Activiti、Flowable和Camunda了，有些人会问为什么没有AirFlow相关的呢？很明显，AirFlow属于编排类流程引擎，跟工作流没太大关系，他们的共同点就是流程控制，工作流引擎&gt;&#x3D;编排类引擎。先给一个表格，下面给一些具体解释。</p>
<p><img src="/blog/images/img/workflow.png" alt="workflow"></p>
<p>Activiti：Activiti在目前来看有点不思进取，核心功能和内核的优化并没有太大进步，着力点全在商业版和云上面，核心只支持BPMN2协议，跟6版本没有什么区别。如果你是一个老的Activiti使用者，并且只是用BPMN2协议，可以选用Activiti（非Cloud版本）。</p>
<p>Flowable：Flowable不管是功能层面还是在代码层面来讲，都是这3个中最重的，当初跟Activiti分道扬镳的原因也是因为理念不一样，Flowable更注重其功能性、扩展性和性能。在上面表格中，历史异步归档和异步任务全局锁都是对性能的极大优化，特别是异步任务这一项，当年在使用Activiti的使用是一个极大的困扰，因为异步任务的吞吐反而会随着实例数的增加而加速恶化。Flowable比较臃肿，它支持了太多的东西，以致于如果想做POC或者Demo，环境搭建这一步都够呛。但是如果你本身就想做一个扩展性强的，性能高的工作流平台（SaaS\PaaS），Flowable是不二的选择。</p>
<p>Camunda：Camunda是这3个里面比较轻量的一个，但是它并没有去掉PVM这个性能较差的流程推动引擎，所以如果你对性能要求很高的话，PVM肯定是不能满足的（Activiti已经在6.X版本的时候放弃了PVM，Flowable亦是如此）。但是Camunda有一个好东西就是它的编辑器，它是基于<a href="http://bpmn.io的bpmn.js,cmmn.js,dmn.js来开发的,并且开源了自己的组件库,所以,如果你想做一个轻巧的、灵活的、定制性强的编辑器,工作流是嵌入式的,那么camunda是一个好选择./">http://bpmn.io的bpmn.js,cmmn.js,dmn.js来开发的，并且开源了自己的组件库，所以，如果你想做一个轻巧的、灵活的、定制性强的编辑器，工作流是嵌入式的，那么Camunda是一个好选择。</a></p>
]]></content>
      <categories>
        <category>工作流</category>
        <category>工作流简介</category>
      </categories>
  </entry>
</search>
